import {
  __commonJS
} from "./chunk-F4AF7QOS.js";

// node_modules/agora-rtc-sdk-ng/AgoraRTC_N-production.js
var require_AgoraRTC_N_production = __commonJS({
  "node_modules/agora-rtc-sdk-ng/AgoraRTC_N-production.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).AgoraRTC = t();
    }(exports, function() {
      "use strict";
      function e(e2, t2) {
        return t2.forEach(function(t3) {
          t3 && "string" != typeof t3 && !Array.isArray(t3) && Object.keys(t3).forEach(function(i2) {
            if ("default" !== i2 && !(i2 in e2)) {
              var n2 = Object.getOwnPropertyDescriptor(t3, i2);
              Object.defineProperty(e2, i2, n2.get ? n2 : { enumerable: true, get: function() {
                return t3[i2];
              } });
            }
          });
        }), Object.freeze(e2);
      }
      var t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, i = function(e2) {
        try {
          return !!e2();
        } catch (e3) {
          return true;
        }
      }, n = !i(function() {
        var e2 = function() {
        }.bind();
        return "function" != typeof e2 || e2.hasOwnProperty("prototype");
      }), r = n, o = Function.prototype, s = o.bind, a = o.call, c = r && s.bind(a, a), d = r ? function(e2) {
        return e2 && c(e2);
      } : function(e2) {
        return e2 && function() {
          return a.apply(e2, arguments);
        };
      }, u = d({}.isPrototypeOf), l = function(e2) {
        return e2 && e2.Math == Math && e2;
      }, h = l("object" == typeof globalThis && globalThis) || l("object" == typeof window && window) || l("object" == typeof self && self) || l("object" == typeof t && t) || function() {
        return this;
      }() || Function("return this")(), p = n, _ = Function.prototype, E = _.apply, m = _.call, f = "object" == typeof Reflect && Reflect.apply || (p ? m.bind(E) : function() {
        return m.apply(E, arguments);
      }), S = function(e2) {
        return "function" == typeof e2;
      }, T = {}, g = !i(function() {
        return 7 != Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1];
      }), R = n, I = Function.prototype.call, C = R ? I.bind(I) : function() {
        return I.apply(I, arguments);
      }, v = {}, y = {}.propertyIsEnumerable, A = Object.getOwnPropertyDescriptor, O = A && !y.call({ 1: 2 }, 1);
      v.f = O ? function(e2) {
        var t2 = A(this, e2);
        return !!t2 && t2.enumerable;
      } : y;
      var N, b, w = function(e2, t2) {
        return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t2 };
      }, D = d, P = D({}.toString), L = D("".slice), k = function(e2) {
        return L(P(e2), 8, -1);
      }, M = d, U = i, x = k, V = h.Object, j = M("".split), F = U(function() {
        return !V("z").propertyIsEnumerable(0);
      }) ? function(e2) {
        return "String" == x(e2) ? j(e2, "") : V(e2);
      } : V, B = h.TypeError, G = function(e2) {
        if (null == e2)
          throw B("Can't call method on " + e2);
        return e2;
      }, W = F, H = G, K = function(e2) {
        return W(H(e2));
      }, Y = S, q = function(e2) {
        return "object" == typeof e2 ? null !== e2 : Y(e2);
      }, J = {}, X = J, z = h, Q = S, Z = function(e2) {
        return Q(e2) ? e2 : void 0;
      }, $ = function(e2, t2) {
        return arguments.length < 2 ? Z(X[e2]) || Z(z[e2]) : X[e2] && X[e2][t2] || z[e2] && z[e2][t2];
      }, ee = $("navigator", "userAgent") || "", te = h, ie = ee, ne = te.process, re = te.Deno, oe = ne && ne.versions || re && re.version, se = oe && oe.v8;
      se && (b = (N = se.split("."))[0] > 0 && N[0] < 4 ? 1 : +(N[0] + N[1])), !b && ie && (!(N = ie.match(/Edge\/(\d+)/)) || N[1] >= 74) && (N = ie.match(/Chrome\/(\d+)/)) && (b = +N[1]);
      var ae = b, ce = ae, de = i, ue = !!Object.getOwnPropertySymbols && !de(function() {
        var e2 = Symbol();
        return !String(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && ce && ce < 41;
      }), le = ue && !Symbol.sham && "symbol" == typeof Symbol.iterator, he = $, pe = S, _e = u, Ee = le, me = h.Object, fe = Ee ? function(e2) {
        return "symbol" == typeof e2;
      } : function(e2) {
        var t2 = he("Symbol");
        return pe(t2) && _e(t2.prototype, me(e2));
      }, Se = h.String, Te = function(e2) {
        try {
          return Se(e2);
        } catch (e3) {
          return "Object";
        }
      }, ge = S, Re = Te, Ie = h.TypeError, Ce = function(e2) {
        if (ge(e2))
          return e2;
        throw Ie(Re(e2) + " is not a function");
      }, ve = Ce, ye = function(e2, t2) {
        var i2 = e2[t2];
        return null == i2 ? void 0 : ve(i2);
      }, Ae = C, Oe = S, Ne = q, be = h.TypeError, we = { exports: {} }, De = h, Pe = Object.defineProperty, Le = function(e2, t2) {
        try {
          Pe(De, e2, { value: t2, configurable: true, writable: true });
        } catch (i2) {
          De[e2] = t2;
        }
        return t2;
      }, ke = "__core-js_shared__", Me = h[ke] || Le(ke, {}), Ue = Me;
      (we.exports = function(e2, t2) {
        return Ue[e2] || (Ue[e2] = void 0 !== t2 ? t2 : {});
      })("versions", []).push({ version: "3.20.3", mode: "pure", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.20.3/LICENSE", source: "https://github.com/zloirock/core-js" });
      var xe = G, Ve = h.Object, je = function(e2) {
        return Ve(xe(e2));
      }, Fe = je, Be = d({}.hasOwnProperty), Ge = Object.hasOwn || function(e2, t2) {
        return Be(Fe(e2), t2);
      }, We = d, He = 0, Ke = Math.random(), Ye = We(1 .toString), qe = function(e2) {
        return "Symbol(" + (void 0 === e2 ? "" : e2) + ")_" + Ye(++He + Ke, 36);
      }, Je = h, Xe = we.exports, ze = Ge, Qe = qe, Ze = ue, $e = le, et = Xe("wks"), tt = Je.Symbol, it = tt && tt.for, nt = $e ? tt : tt && tt.withoutSetter || Qe, rt = function(e2) {
        if (!ze(et, e2) || !Ze && "string" != typeof et[e2]) {
          var t2 = "Symbol." + e2;
          Ze && ze(tt, e2) ? et[e2] = tt[e2] : et[e2] = $e && it ? it(t2) : nt(t2);
        }
        return et[e2];
      }, ot = C, st = q, at = fe, ct = ye, dt = function(e2, t2) {
        var i2, n2;
        if ("string" === t2 && Oe(i2 = e2.toString) && !Ne(n2 = Ae(i2, e2)))
          return n2;
        if (Oe(i2 = e2.valueOf) && !Ne(n2 = Ae(i2, e2)))
          return n2;
        if ("string" !== t2 && Oe(i2 = e2.toString) && !Ne(n2 = Ae(i2, e2)))
          return n2;
        throw be("Can't convert object to primitive value");
      }, ut = rt, lt = h.TypeError, ht = ut("toPrimitive"), pt = function(e2, t2) {
        if (!st(e2) || at(e2))
          return e2;
        var i2, n2 = ct(e2, ht);
        if (n2) {
          if (void 0 === t2 && (t2 = "default"), i2 = ot(n2, e2, t2), !st(i2) || at(i2))
            return i2;
          throw lt("Can't convert object to primitive value");
        }
        return void 0 === t2 && (t2 = "number"), dt(e2, t2);
      }, _t = fe, Et = function(e2) {
        var t2 = pt(e2, "string");
        return _t(t2) ? t2 : t2 + "";
      }, mt = q, ft = h.document, St = mt(ft) && mt(ft.createElement), Tt = function(e2) {
        return St ? ft.createElement(e2) : {};
      }, gt = Tt, Rt = !g && !i(function() {
        return 7 != Object.defineProperty(gt("div"), "a", { get: function() {
          return 7;
        } }).a;
      }), It = g, Ct = C, vt = v, yt = w, At = K, Ot = Et, Nt = Ge, bt = Rt, wt = Object.getOwnPropertyDescriptor;
      T.f = It ? wt : function(e2, t2) {
        if (e2 = At(e2), t2 = Ot(t2), bt)
          try {
            return wt(e2, t2);
          } catch (e3) {
          }
        if (Nt(e2, t2))
          return yt(!Ct(vt.f, e2, t2), e2[t2]);
      };
      var Dt = i, Pt = S, Lt = /#|\.prototype\./, kt = function(e2, t2) {
        var i2 = Ut[Mt(e2)];
        return i2 == Vt || i2 != xt && (Pt(t2) ? Dt(t2) : !!t2);
      }, Mt = kt.normalize = function(e2) {
        return String(e2).replace(Lt, ".").toLowerCase();
      }, Ut = kt.data = {}, xt = kt.NATIVE = "N", Vt = kt.POLYFILL = "P", jt = kt, Ft = Ce, Bt = n, Gt = d(d.bind), Wt = function(e2, t2) {
        return Ft(e2), void 0 === t2 ? e2 : Bt ? Gt(e2, t2) : function() {
          return e2.apply(t2, arguments);
        };
      }, Ht = {}, Kt = g && i(function() {
        return 42 != Object.defineProperty(function() {
        }, "prototype", { value: 42, writable: false }).prototype;
      }), Yt = h, qt = q, Jt = Yt.String, Xt = Yt.TypeError, zt = function(e2) {
        if (qt(e2))
          return e2;
        throw Xt(Jt(e2) + " is not an object");
      }, Qt = g, Zt = Rt, $t = Kt, ei = zt, ti = Et, ii = h.TypeError, ni = Object.defineProperty, ri = Object.getOwnPropertyDescriptor, oi = "enumerable", si = "configurable", ai = "writable";
      Ht.f = Qt ? $t ? function(e2, t2, i2) {
        if (ei(e2), t2 = ti(t2), ei(i2), "function" == typeof e2 && "prototype" === t2 && "value" in i2 && ai in i2 && !i2.writable) {
          var n2 = ri(e2, t2);
          n2 && n2.writable && (e2[t2] = i2.value, i2 = { configurable: si in i2 ? i2.configurable : n2.configurable, enumerable: oi in i2 ? i2.enumerable : n2.enumerable, writable: false });
        }
        return ni(e2, t2, i2);
      } : ni : function(e2, t2, i2) {
        if (ei(e2), t2 = ti(t2), ei(i2), Zt)
          try {
            return ni(e2, t2, i2);
          } catch (e3) {
          }
        if ("get" in i2 || "set" in i2)
          throw ii("Accessors not supported");
        return "value" in i2 && (e2[t2] = i2.value), e2;
      };
      var ci = Ht, di = w, ui = g ? function(e2, t2, i2) {
        return ci.f(e2, t2, di(1, i2));
      } : function(e2, t2, i2) {
        return e2[t2] = i2, e2;
      }, li = h, hi = f, pi = d, _i = S, Ei = T.f, mi = jt, fi = J, Si = Wt, Ti = ui, gi = Ge, Ri = function(e2) {
        var t2 = function(i2, n2, r2) {
          if (this instanceof t2) {
            switch (arguments.length) {
              case 0:
                return new e2();
              case 1:
                return new e2(i2);
              case 2:
                return new e2(i2, n2);
            }
            return new e2(i2, n2, r2);
          }
          return hi(e2, this, arguments);
        };
        return t2.prototype = e2.prototype, t2;
      }, Ii = function(e2, t2) {
        var i2, n2, r2, o2, s2, a2, c2, d2, u2 = e2.target, l2 = e2.global, h2 = e2.stat, p2 = e2.proto, _2 = l2 ? li : h2 ? li[u2] : (li[u2] || {}).prototype, E2 = l2 ? fi : fi[u2] || Ti(fi, u2, {})[u2], m2 = E2.prototype;
        for (r2 in t2)
          i2 = !mi(l2 ? r2 : u2 + (h2 ? "." : "#") + r2, e2.forced) && _2 && gi(_2, r2), s2 = E2[r2], i2 && (a2 = e2.noTargetGet ? (d2 = Ei(_2, r2)) && d2.value : _2[r2]), o2 = i2 && a2 ? a2 : t2[r2], i2 && typeof s2 == typeof o2 || (c2 = e2.bind && i2 ? Si(o2, li) : e2.wrap && i2 ? Ri(o2) : p2 && _i(o2) ? pi(o2) : o2, (e2.sham || o2 && o2.sham || s2 && s2.sham) && Ti(c2, "sham", true), Ti(E2, r2, c2), p2 && (gi(fi, n2 = u2 + "Prototype") || Ti(fi, n2, {}), Ti(fi[n2], r2, o2), e2.real && m2 && !m2[r2] && Ti(m2, r2, o2)));
      }, Ci = Math.ceil, vi = Math.floor, yi = function(e2) {
        var t2 = +e2;
        return t2 != t2 || 0 === t2 ? 0 : (t2 > 0 ? vi : Ci)(t2);
      }, Ai = yi, Oi = Math.min, Ni = function(e2) {
        return e2 > 0 ? Oi(Ai(e2), 9007199254740991) : 0;
      }, bi = function(e2) {
        return Ni(e2.length);
      }, wi = Ce, Di = je, Pi = F, Li = bi, ki = h.TypeError, Mi = function(e2) {
        return function(t2, i2, n2, r2) {
          wi(i2);
          var o2 = Di(t2), s2 = Pi(o2), a2 = Li(o2), c2 = e2 ? a2 - 1 : 0, d2 = e2 ? -1 : 1;
          if (n2 < 2)
            for (; ; ) {
              if (c2 in s2) {
                r2 = s2[c2], c2 += d2;
                break;
              }
              if (c2 += d2, e2 ? c2 < 0 : a2 <= c2)
                throw ki("Reduce of empty array with no initial value");
            }
          for (; e2 ? c2 >= 0 : a2 > c2; c2 += d2)
            c2 in s2 && (r2 = i2(r2, s2[c2], c2, o2));
          return r2;
        };
      }, Ui = { left: Mi(false), right: Mi(true) }, xi = i, Vi = function(e2, t2) {
        var i2 = [][e2];
        return !!i2 && xi(function() {
          i2.call(null, t2 || function() {
            throw 1;
          }, 1);
        });
      }, ji = "process" == k(h.process), Fi = Ui.left, Bi = ae, Gi = ji;
      Ii({ target: "Array", proto: true, forced: !Vi("reduce") || !Gi && Bi > 79 && Bi < 83 }, { reduce: function(e2) {
        var t2 = arguments.length;
        return Fi(this, e2, t2, t2 > 1 ? arguments[1] : void 0);
      } });
      var Wi = J, Hi = function(e2) {
        return Wi[e2 + "Prototype"];
      }, Ki = Hi("Array").reduce, Yi = u, qi = Ki, Ji = Array.prototype, Xi = function(e2) {
        var t2 = e2.reduce;
        return e2 === Ji || Yi(Ji, e2) && t2 === Ji.reduce ? qi : t2;
      }, zi = Xi;
      let Qi = true, Zi = true;
      function $i(e2, t2, i2) {
        const n2 = e2.match(t2);
        return n2 && n2.length >= i2 && parseInt(n2[i2], 10);
      }
      function en(e2, t2, i2) {
        if (!e2.RTCPeerConnection)
          return;
        const n2 = e2.RTCPeerConnection.prototype, r2 = n2.addEventListener;
        n2.addEventListener = function(e3, n3) {
          if (e3 !== t2)
            return r2.apply(this, arguments);
          const o3 = (e4) => {
            const t3 = i2(e4);
            t3 && (n3.handleEvent ? n3.handleEvent(t3) : n3(t3));
          };
          return this._eventMap = this._eventMap || {}, this._eventMap[t2] || (this._eventMap[t2] = /* @__PURE__ */ new Map()), this._eventMap[t2].set(n3, o3), r2.apply(this, [e3, o3]);
        };
        const o2 = n2.removeEventListener;
        n2.removeEventListener = function(e3, i3) {
          if (e3 !== t2 || !this._eventMap || !this._eventMap[t2])
            return o2.apply(this, arguments);
          if (!this._eventMap[t2].has(i3))
            return o2.apply(this, arguments);
          const n3 = this._eventMap[t2].get(i3);
          return this._eventMap[t2].delete(i3), 0 === this._eventMap[t2].size && delete this._eventMap[t2], 0 === Object.keys(this._eventMap).length && delete this._eventMap, o2.apply(this, [e3, n3]);
        }, Object.defineProperty(n2, "on" + t2, { get() {
          return this["_on" + t2];
        }, set(e3) {
          this["_on" + t2] && (this.removeEventListener(t2, this["_on" + t2]), delete this["_on" + t2]), e3 && this.addEventListener(t2, this["_on" + t2] = e3);
        }, enumerable: true, configurable: true });
      }
      function tn(e2) {
        return "boolean" != typeof e2 ? new Error("Argument type: " + typeof e2 + ". Please use a boolean.") : (Qi = e2, e2 ? "adapter.js logging disabled" : "adapter.js logging enabled");
      }
      function nn(e2) {
        return "boolean" != typeof e2 ? new Error("Argument type: " + typeof e2 + ". Please use a boolean.") : (Zi = !e2, "adapter.js deprecation warnings " + (e2 ? "disabled" : "enabled"));
      }
      function rn() {
        if ("object" == typeof window) {
          if (Qi)
            return;
          "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments);
        }
      }
      function on(e2, t2) {
        Zi && console.warn(e2 + " is deprecated, please use " + t2 + " instead.");
      }
      function sn(e2) {
        const t2 = { browser: null, version: null };
        if (void 0 === e2 || !e2.navigator)
          return t2.browser = "Not a browser.", t2;
        const { navigator: i2 } = e2;
        if (i2.mozGetUserMedia)
          t2.browser = "firefox", t2.version = $i(i2.userAgent, /Firefox\/(\d+)\./, 1);
        else if (i2.webkitGetUserMedia || false === e2.isSecureContext && e2.webkitRTCPeerConnection)
          t2.browser = "chrome", t2.version = $i(i2.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
        else {
          if (!e2.RTCPeerConnection || !i2.userAgent.match(/AppleWebKit\/(\d+)\./))
            return t2.browser = "Not a supported browser.", t2;
          t2.browser = "safari", t2.version = $i(i2.userAgent, /AppleWebKit\/(\d+)\./, 1), t2.supportsUnifiedPlan = e2.RTCRtpTransceiver && "currentDirection" in e2.RTCRtpTransceiver.prototype;
        }
        return t2;
      }
      function an(e2) {
        return "[object Object]" === Object.prototype.toString.call(e2);
      }
      function cn(e2) {
        var t2;
        return an(e2) ? zi(t2 = Object.keys(e2)).call(t2, function(t3, i2) {
          const n2 = an(e2[i2]), r2 = n2 ? cn(e2[i2]) : e2[i2], o2 = n2 && !Object.keys(r2).length;
          return void 0 === r2 || o2 ? t3 : Object.assign(t3, { [i2]: r2 });
        }, {}) : e2;
      }
      function dn(e2, t2, i2) {
        const n2 = i2 ? "outbound-rtp" : "inbound-rtp", r2 = /* @__PURE__ */ new Map();
        if (null === t2)
          return r2;
        const o2 = [];
        return e2.forEach((e3) => {
          "track" === e3.type && e3.trackIdentifier === t2.id && o2.push(e3);
        }), o2.forEach((t3) => {
          e2.forEach((i3) => {
            i3.type === n2 && i3.trackId === t3.id && function e3(t4, i4, n3) {
              i4 && !n3.has(i4.id) && (n3.set(i4.id, i4), Object.keys(i4).forEach((r3) => {
                r3.endsWith("Id") ? e3(t4, t4.get(i4[r3]), n3) : r3.endsWith("Ids") && i4[r3].forEach((i5) => {
                  e3(t4, t4.get(i5), n3);
                });
              }));
            }(e2, i3, r2);
          });
        }), r2;
      }
      var un = we.exports, ln = qe, hn = un("keys"), pn = function(e2) {
        return hn[e2] || (hn[e2] = ln(e2));
      }, _n = !i(function() {
        function e2() {
        }
        return e2.prototype.constructor = null, Object.getPrototypeOf(new e2()) !== e2.prototype;
      }), En = h, mn = Ge, fn = S, Sn = je, Tn = _n, gn = pn("IE_PROTO"), Rn = En.Object, In = Rn.prototype, Cn = Tn ? Rn.getPrototypeOf : function(e2) {
        var t2 = Sn(e2);
        if (mn(t2, gn))
          return t2[gn];
        var i2 = t2.constructor;
        return fn(i2) && t2 instanceof i2 ? i2.prototype : t2 instanceof Rn ? In : null;
      }, vn = h, yn = S, An = vn.String, On = vn.TypeError, Nn = d, bn = zt, wn = function(e2) {
        if ("object" == typeof e2 || yn(e2))
          return e2;
        throw On("Can't set " + An(e2) + " as a prototype");
      }, Dn = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var e2, t2 = false, i2 = {};
        try {
          (e2 = Nn(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(i2, []), t2 = i2 instanceof Array;
        } catch (e3) {
        }
        return function(i3, n2) {
          return bn(i3), wn(n2), t2 ? e2(i3, n2) : i3.__proto__ = n2, i3;
        };
      }() : void 0), Pn = {}, Ln = yi, kn = Math.max, Mn = Math.min, Un = function(e2, t2) {
        var i2 = Ln(e2);
        return i2 < 0 ? kn(i2 + t2, 0) : Mn(i2, t2);
      }, xn = K, Vn = Un, jn = bi, Fn = function(e2) {
        return function(t2, i2, n2) {
          var r2, o2 = xn(t2), s2 = jn(o2), a2 = Vn(n2, s2);
          if (e2 && i2 != i2) {
            for (; s2 > a2; )
              if ((r2 = o2[a2++]) != r2)
                return true;
          } else
            for (; s2 > a2; a2++)
              if ((e2 || a2 in o2) && o2[a2] === i2)
                return e2 || a2 || 0;
          return !e2 && -1;
        };
      }, Bn = { includes: Fn(true), indexOf: Fn(false) }, Gn = {}, Wn = Ge, Hn = K, Kn = Bn.indexOf, Yn = Gn, qn = d([].push), Jn = function(e2, t2) {
        var i2, n2 = Hn(e2), r2 = 0, o2 = [];
        for (i2 in n2)
          !Wn(Yn, i2) && Wn(n2, i2) && qn(o2, i2);
        for (; t2.length > r2; )
          Wn(n2, i2 = t2[r2++]) && (~Kn(o2, i2) || qn(o2, i2));
        return o2;
      }, Xn = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], zn = Jn, Qn = Xn.concat("length", "prototype");
      Pn.f = Object.getOwnPropertyNames || function(e2) {
        return zn(e2, Qn);
      };
      var Zn = {};
      Zn.f = Object.getOwnPropertySymbols;
      var $n = $, er = Pn, tr = Zn, ir = zt, nr = d([].concat), rr = $n("Reflect", "ownKeys") || function(e2) {
        var t2 = er.f(ir(e2)), i2 = tr.f;
        return i2 ? nr(t2, i2(e2)) : t2;
      }, or = Ge, sr = rr, ar = T, cr = Ht, dr = {}, ur = Jn, lr = Xn, hr = Object.keys || function(e2) {
        return ur(e2, lr);
      }, pr = g, _r = Kt, Er = Ht, mr = zt, fr = K, Sr = hr;
      dr.f = pr && !_r ? Object.defineProperties : function(e2, t2) {
        mr(e2);
        for (var i2, n2 = fr(t2), r2 = Sr(t2), o2 = r2.length, s2 = 0; o2 > s2; )
          Er.f(e2, i2 = r2[s2++], n2[i2]);
        return e2;
      };
      var Tr, gr = $("document", "documentElement"), Rr = zt, Ir = dr, Cr = Xn, vr = Gn, yr = gr, Ar = Tt, Or = pn("IE_PROTO"), Nr = function() {
      }, br = function(e2) {
        return "<script>" + e2 + "<\/script>";
      }, wr = function(e2) {
        e2.write(br("")), e2.close();
        var t2 = e2.parentWindow.Object;
        return e2 = null, t2;
      }, Dr = function() {
        try {
          Tr = new ActiveXObject("htmlfile");
        } catch (e3) {
        }
        var e2, t2;
        Dr = "undefined" != typeof document ? document.domain && Tr ? wr(Tr) : ((t2 = Ar("iframe")).style.display = "none", yr.appendChild(t2), t2.src = String("javascript:"), (e2 = t2.contentWindow.document).open(), e2.write(br("document.F=Object")), e2.close(), e2.F) : wr(Tr);
        for (var i2 = Cr.length; i2--; )
          delete Dr.prototype[Cr[i2]];
        return Dr();
      };
      vr[Or] = true;
      var Pr = Object.create || function(e2, t2) {
        var i2;
        return null !== e2 ? (Nr.prototype = Rr(e2), i2 = new Nr(), Nr.prototype = null, i2[Or] = e2) : i2 = Dr(), void 0 === t2 ? i2 : Ir.f(i2, t2);
      }, Lr = d("".replace), kr = String(Error("zxcasd").stack), Mr = /\n\s*at [^:]*:[^\n]*/, Ur = Mr.test(kr), xr = q, Vr = ui, jr = {}, Fr = jr, Br = rt("iterator"), Gr = Array.prototype, Wr = {};
      Wr[rt("toStringTag")] = "z";
      var Hr = "[object z]" === String(Wr), Kr = h, Yr = Hr, qr = S, Jr = k, Xr = rt("toStringTag"), zr = Kr.Object, Qr = "Arguments" == Jr(function() {
        return arguments;
      }()), Zr = Yr ? Jr : function(e2) {
        var t2, i2, n2;
        return void 0 === e2 ? "Undefined" : null === e2 ? "Null" : "string" == typeof (i2 = function(e3, t3) {
          try {
            return e3[t3];
          } catch (e4) {
          }
        }(t2 = zr(e2), Xr)) ? i2 : Qr ? Jr(t2) : "Object" == (n2 = Jr(t2)) && qr(t2.callee) ? "Arguments" : n2;
      }, $r = Zr, eo = ye, to = jr, io = rt("iterator"), no = function(e2) {
        if (null != e2)
          return eo(e2, io) || eo(e2, "@@iterator") || to[$r(e2)];
      }, ro = C, oo = Ce, so = zt, ao = Te, co = no, uo = h.TypeError, lo = C, ho = zt, po = ye, _o = Wt, Eo = C, mo = zt, fo = Te, So = function(e2) {
        return void 0 !== e2 && (Fr.Array === e2 || Gr[Br] === e2);
      }, To = bi, go = u, Ro = function(e2, t2) {
        var i2 = arguments.length < 2 ? co(e2) : t2;
        if (oo(i2))
          return so(ro(i2, e2));
        throw uo(ao(e2) + " is not iterable");
      }, Io = no, Co = function(e2, t2, i2) {
        var n2, r2;
        ho(e2);
        try {
          if (!(n2 = po(e2, "return"))) {
            if ("throw" === t2)
              throw i2;
            return i2;
          }
          n2 = lo(n2, e2);
        } catch (e3) {
          r2 = true, n2 = e3;
        }
        if ("throw" === t2)
          throw i2;
        if (r2)
          throw n2;
        return ho(n2), i2;
      }, vo = h.TypeError, yo = function(e2, t2) {
        this.stopped = e2, this.result = t2;
      }, Ao = yo.prototype, Oo = function(e2, t2, i2) {
        var n2, r2, o2, s2, a2, c2, d2, u2 = i2 && i2.that, l2 = !(!i2 || !i2.AS_ENTRIES), h2 = !(!i2 || !i2.IS_ITERATOR), p2 = !(!i2 || !i2.INTERRUPTED), _2 = _o(t2, u2), E2 = function(e3) {
          return n2 && Co(n2, "normal", e3), new yo(true, e3);
        }, m2 = function(e3) {
          return l2 ? (mo(e3), p2 ? _2(e3[0], e3[1], E2) : _2(e3[0], e3[1])) : p2 ? _2(e3, E2) : _2(e3);
        };
        if (h2)
          n2 = e2;
        else {
          if (!(r2 = Io(e2)))
            throw vo(fo(e2) + " is not iterable");
          if (So(r2)) {
            for (o2 = 0, s2 = To(e2); s2 > o2; o2++)
              if ((a2 = m2(e2[o2])) && go(Ao, a2))
                return a2;
            return new yo(false);
          }
          n2 = Ro(e2, r2);
        }
        for (c2 = n2.next; !(d2 = Eo(c2, n2)).done; ) {
          try {
            a2 = m2(d2.value);
          } catch (e3) {
            Co(n2, "throw", e3);
          }
          if ("object" == typeof a2 && a2 && go(Ao, a2))
            return a2;
        }
        return new yo(false);
      }, No = Zr, bo = h.String, wo = function(e2) {
        if ("Symbol" === No(e2))
          throw TypeError("Cannot convert a Symbol value to a string");
        return bo(e2);
      }, Do = wo, Po = w, Lo = !i(function() {
        var e2 = Error("a");
        return !("stack" in e2) || (Object.defineProperty(e2, "stack", Po(1, 7)), 7 !== e2.stack);
      }), ko = Ii, Mo = h, Uo = u, xo = Cn, Vo = Dn, jo = function(e2, t2, i2) {
        for (var n2 = sr(t2), r2 = cr.f, o2 = ar.f, s2 = 0; s2 < n2.length; s2++) {
          var a2 = n2[s2];
          or(e2, a2) || i2 && or(i2, a2) || r2(e2, a2, o2(t2, a2));
        }
      }, Fo = Pr, Bo = ui, Go = w, Wo = function(e2, t2) {
        if (Ur && "string" == typeof e2)
          for (; t2--; )
            e2 = Lr(e2, Mr, "");
        return e2;
      }, Ho = function(e2, t2) {
        xr(t2) && "cause" in t2 && Vr(e2, "cause", t2.cause);
      }, Ko = Oo, Yo = function(e2, t2) {
        return void 0 === e2 ? arguments.length < 2 ? "" : t2 : Do(e2);
      }, qo = Lo, Jo = rt("toStringTag"), Xo = Mo.Error, zo = [].push, Qo = function(e2, t2) {
        var i2, n2 = arguments.length > 2 ? arguments[2] : void 0, r2 = Uo(Zo, this);
        Vo ? i2 = Vo(new Xo(), r2 ? xo(this) : Zo) : (i2 = r2 ? this : Fo(Zo), Bo(i2, Jo, "Error")), void 0 !== t2 && Bo(i2, "message", Yo(t2)), qo && Bo(i2, "stack", Wo(i2.stack, 1)), Ho(i2, n2);
        var o2 = [];
        return Ko(e2, zo, { that: o2 }), Bo(i2, "errors", o2), i2;
      };
      Vo ? Vo(Qo, Xo) : jo(Qo, Xo, { name: true });
      var Zo = Qo.prototype = Fo(Xo.prototype, { constructor: Go(1, Qo), message: Go(1, ""), name: Go(1, "AggregateError") });
      ko({ global: true }, { AggregateError: Qo });
      var $o = S, es = Me, ts = d(Function.toString);
      $o(es.inspectSource) || (es.inspectSource = function(e2) {
        return ts(e2);
      });
      var is, ns, rs, os = es.inspectSource, ss = S, as = os, cs = h.WeakMap, ds = ss(cs) && /native code/.test(as(cs)), us = h, ls = d, hs = q, ps = ui, _s = Ge, Es = Me, ms = pn, fs = Gn, Ss = "Object already initialized", Ts = us.TypeError, gs = us.WeakMap;
      if (ds || Es.state) {
        var Rs = Es.state || (Es.state = new gs()), Is = ls(Rs.get), Cs = ls(Rs.has), vs = ls(Rs.set);
        is = function(e2, t2) {
          if (Cs(Rs, e2))
            throw new Ts(Ss);
          return t2.facade = e2, vs(Rs, e2, t2), t2;
        }, ns = function(e2) {
          return Is(Rs, e2) || {};
        }, rs = function(e2) {
          return Cs(Rs, e2);
        };
      } else {
        var ys = ms("state");
        fs[ys] = true, is = function(e2, t2) {
          if (_s(e2, ys))
            throw new Ts(Ss);
          return t2.facade = e2, ps(e2, ys, t2), t2;
        }, ns = function(e2) {
          return _s(e2, ys) ? e2[ys] : {};
        }, rs = function(e2) {
          return _s(e2, ys);
        };
      }
      var As, Os, Ns, bs = { set: is, get: ns, has: rs, enforce: function(e2) {
        return rs(e2) ? ns(e2) : is(e2, {});
      }, getterFor: function(e2) {
        return function(t2) {
          var i2;
          if (!hs(t2) || (i2 = ns(t2)).type !== e2)
            throw Ts("Incompatible receiver, " + e2 + " required");
          return i2;
        };
      } }, ws = g, Ds = Ge, Ps = Function.prototype, Ls = ws && Object.getOwnPropertyDescriptor, ks = Ds(Ps, "name"), Ms = { EXISTS: ks, PROPER: ks && "something" === function() {
      }.name, CONFIGURABLE: ks && (!ws || ws && Ls(Ps, "name").configurable) }, Us = ui, xs = function(e2, t2, i2, n2) {
        n2 && n2.enumerable ? e2[t2] = i2 : Us(e2, t2, i2);
      }, Vs = i, js = S, Fs = Pr, Bs = Cn, Gs = xs, Ws = rt("iterator"), Hs = false;
      [].keys && ("next" in (Ns = [].keys()) ? (Os = Bs(Bs(Ns))) !== Object.prototype && (As = Os) : Hs = true);
      var Ks = null == As || Vs(function() {
        var e2 = {};
        return As[Ws].call(e2) !== e2;
      });
      js((As = Ks ? {} : Fs(As))[Ws]) || Gs(As, Ws, function() {
        return this;
      });
      var Ys = { IteratorPrototype: As, BUGGY_SAFARI_ITERATORS: Hs }, qs = Zr, Js = Hr ? {}.toString : function() {
        return "[object " + qs(this) + "]";
      }, Xs = Hr, zs = Ht.f, Qs = ui, Zs = Ge, $s = Js, ea = rt("toStringTag"), ta = function(e2, t2, i2, n2) {
        if (e2) {
          var r2 = i2 ? e2 : e2.prototype;
          Zs(r2, ea) || zs(r2, ea, { configurable: true, value: t2 }), n2 && !Xs && Qs(r2, "toString", $s);
        }
      }, ia = Ys.IteratorPrototype, na = Pr, ra = w, oa = ta, sa = jr, aa = function() {
        return this;
      }, ca = Ii, da = C, ua = function(e2, t2, i2, n2) {
        var r2 = t2 + " Iterator";
        return e2.prototype = na(ia, { next: ra(+!n2, i2) }), oa(e2, r2, false, true), sa[r2] = aa, e2;
      }, la = Cn, ha = ta, pa = xs, _a = jr, Ea = Ms.PROPER, ma = Ys.BUGGY_SAFARI_ITERATORS, fa = rt("iterator"), Sa = "keys", Ta = "values", ga = "entries", Ra = function() {
        return this;
      }, Ia = function(e2, t2, i2, n2, r2, o2, s2) {
        ua(i2, t2, n2);
        var a2, c2, d2, u2 = function(e3) {
          if (e3 === r2 && E2)
            return E2;
          if (!ma && e3 in p2)
            return p2[e3];
          switch (e3) {
            case Sa:
            case Ta:
            case ga:
              return function() {
                return new i2(this, e3);
              };
          }
          return function() {
            return new i2(this);
          };
        }, l2 = t2 + " Iterator", h2 = false, p2 = e2.prototype, _2 = p2[fa] || p2["@@iterator"] || r2 && p2[r2], E2 = !ma && _2 || u2(r2), m2 = "Array" == t2 && p2.entries || _2;
        if (m2 && (a2 = la(m2.call(new e2()))) !== Object.prototype && a2.next && (ha(a2, l2, true, true), _a[l2] = Ra), Ea && r2 == Ta && _2 && _2.name !== Ta && (h2 = true, E2 = function() {
          return da(_2, this);
        }), r2)
          if (c2 = { values: u2(Ta), keys: o2 ? E2 : u2(Sa), entries: u2(ga) }, s2)
            for (d2 in c2)
              (ma || h2 || !(d2 in p2)) && pa(p2, d2, c2[d2]);
          else
            ca({ target: t2, proto: true, forced: ma || h2 }, c2);
        return s2 && p2[fa] !== E2 && pa(p2, fa, E2, { name: r2 }), _a[t2] = E2, c2;
      }, Ca = K, va = jr, ya = bs;
      Ht.f;
      var Aa = Ia, Oa = "Array Iterator", Na = ya.set, ba = ya.getterFor(Oa);
      Aa(Array, "Array", function(e2, t2) {
        Na(this, { type: Oa, target: Ca(e2), index: 0, kind: t2 });
      }, function() {
        var e2 = ba(this), t2 = e2.target, i2 = e2.kind, n2 = e2.index++;
        return !t2 || n2 >= t2.length ? (e2.target = void 0, { value: void 0, done: true }) : "keys" == i2 ? { value: n2, done: false } : "values" == i2 ? { value: t2[n2], done: false } : { value: [n2, t2[n2]], done: false };
      }, "values"), va.Arguments = va.Array;
      var wa = h.Promise, Da = xs, Pa = $, La = Ht, ka = g, Ma = rt("species"), Ua = u, xa = h.TypeError, Va = rt("iterator"), ja = false;
      try {
        var Fa = 0, Ba = { next: function() {
          return { done: !!Fa++ };
        }, return: function() {
          ja = true;
        } };
        Ba[Va] = function() {
          return this;
        }, Array.from(Ba, function() {
          throw 2;
        });
      } catch (e2) {
      }
      var Ga = d, Wa = i, Ha = S, Ka = Zr, Ya = os, qa = function() {
      }, Ja = [], Xa = $("Reflect", "construct"), za = /^\s*(?:class|function)\b/, Qa = Ga(za.exec), Za = !za.exec(qa), $a = function(e2) {
        if (!Ha(e2))
          return false;
        try {
          return Xa(qa, Ja, e2), true;
        } catch (e3) {
          return false;
        }
      }, ec = function(e2) {
        if (!Ha(e2))
          return false;
        switch (Ka(e2)) {
          case "AsyncFunction":
          case "GeneratorFunction":
          case "AsyncGeneratorFunction":
            return false;
        }
        try {
          return Za || !!Qa(za, Ya(e2));
        } catch (e3) {
          return true;
        }
      };
      ec.sham = true;
      var tc, ic, nc, rc, oc = !Xa || Wa(function() {
        var e2;
        return $a($a.call) || !$a(Object) || !$a(function() {
          e2 = true;
        }) || e2;
      }) ? ec : $a, sc = oc, ac = Te, cc = h.TypeError, dc = zt, uc = function(e2) {
        if (sc(e2))
          return e2;
        throw cc(ac(e2) + " is not a constructor");
      }, lc = rt("species"), hc = function(e2, t2) {
        var i2, n2 = dc(e2).constructor;
        return void 0 === n2 || null == (i2 = dc(n2)[lc]) ? t2 : uc(i2);
      }, pc = d([].slice), _c = /(?:ipad|iphone|ipod).*applewebkit/i.test(ee), Ec = h, mc = f, fc = Wt, Sc = S, Tc = Ge, gc = i, Rc = gr, Ic = pc, Cc = Tt, vc = _c, yc = ji, Ac = Ec.setImmediate, Oc = Ec.clearImmediate, Nc = Ec.process, bc = Ec.Dispatch, wc = Ec.Function, Dc = Ec.MessageChannel, Pc = Ec.String, Lc = 0, kc = {}, Mc = "onreadystatechange";
      try {
        tc = Ec.location;
      } catch (e2) {
      }
      var Uc = function(e2) {
        if (Tc(kc, e2)) {
          var t2 = kc[e2];
          delete kc[e2], t2();
        }
      }, xc = function(e2) {
        return function() {
          Uc(e2);
        };
      }, Vc = function(e2) {
        Uc(e2.data);
      }, jc = function(e2) {
        Ec.postMessage(Pc(e2), tc.protocol + "//" + tc.host);
      };
      Ac && Oc || (Ac = function(e2) {
        var t2 = Ic(arguments, 1);
        return kc[++Lc] = function() {
          mc(Sc(e2) ? e2 : wc(e2), void 0, t2);
        }, ic(Lc), Lc;
      }, Oc = function(e2) {
        delete kc[e2];
      }, yc ? ic = function(e2) {
        Nc.nextTick(xc(e2));
      } : bc && bc.now ? ic = function(e2) {
        bc.now(xc(e2));
      } : Dc && !vc ? (rc = (nc = new Dc()).port2, nc.port1.onmessage = Vc, ic = fc(rc.postMessage, rc)) : Ec.addEventListener && Sc(Ec.postMessage) && !Ec.importScripts && tc && "file:" !== tc.protocol && !gc(jc) ? (ic = jc, Ec.addEventListener("message", Vc, false)) : ic = Mc in Cc("script") ? function(e2) {
        Rc.appendChild(Cc("script")).onreadystatechange = function() {
          Rc.removeChild(this), Uc(e2);
        };
      } : function(e2) {
        setTimeout(xc(e2), 0);
      });
      var Fc, Bc, Gc, Wc, Hc, Kc, Yc, qc, Jc = { set: Ac, clear: Oc }, Xc = h, zc = /ipad|iphone|ipod/i.test(ee) && void 0 !== Xc.Pebble, Qc = /web0s(?!.*chrome)/i.test(ee), Zc = h, $c = Wt, ed = T.f, td = Jc.set, id = _c, nd = zc, rd = Qc, od = ji, sd = Zc.MutationObserver || Zc.WebKitMutationObserver, ad = Zc.document, cd = Zc.process, dd = Zc.Promise, ud = ed(Zc, "queueMicrotask"), ld = ud && ud.value;
      ld || (Fc = function() {
        var e2, t2;
        for (od && (e2 = cd.domain) && e2.exit(); Bc; ) {
          t2 = Bc.fn, Bc = Bc.next;
          try {
            t2();
          } catch (e3) {
            throw Bc ? Wc() : Gc = void 0, e3;
          }
        }
        Gc = void 0, e2 && e2.enter();
      }, id || od || rd || !sd || !ad ? !nd && dd && dd.resolve ? ((Yc = dd.resolve(void 0)).constructor = dd, qc = $c(Yc.then, Yc), Wc = function() {
        qc(Fc);
      }) : od ? Wc = function() {
        cd.nextTick(Fc);
      } : (td = $c(td, Zc), Wc = function() {
        td(Fc);
      }) : (Hc = true, Kc = ad.createTextNode(""), new sd(Fc).observe(Kc, { characterData: true }), Wc = function() {
        Kc.data = Hc = !Hc;
      }));
      var hd = ld || function(e2) {
        var t2 = { fn: e2, next: void 0 };
        Gc && (Gc.next = t2), Bc || (Bc = t2, Wc()), Gc = t2;
      }, pd = {}, _d = Ce, Ed = function(e2) {
        var t2, i2;
        this.promise = new e2(function(e3, n2) {
          if (void 0 !== t2 || void 0 !== i2)
            throw TypeError("Bad Promise constructor");
          t2 = e3, i2 = n2;
        }), this.resolve = _d(t2), this.reject = _d(i2);
      };
      pd.f = function(e2) {
        return new Ed(e2);
      };
      var md = zt, fd = q, Sd = pd, Td = function(e2, t2) {
        if (md(e2), fd(t2) && t2.constructor === e2)
          return t2;
        var i2 = Sd.f(e2);
        return (0, i2.resolve)(t2), i2.promise;
      }, gd = h, Rd = function(e2) {
        try {
          return { error: false, value: e2() };
        } catch (e3) {
          return { error: true, value: e3 };
        }
      }, Id = function() {
        this.head = null, this.tail = null;
      };
      Id.prototype = { add: function(e2) {
        var t2 = { item: e2, next: null };
        this.head ? this.tail.next = t2 : this.head = t2, this.tail = t2;
      }, get: function() {
        var e2 = this.head;
        if (e2)
          return this.head = e2.next, this.tail === e2 && (this.tail = null), e2.item;
      } };
      var Cd, vd, yd, Ad = "object" == typeof window, Od = Ii, Nd = h, bd = $, wd = C, Dd = wa, Pd = function(e2, t2, i2) {
        for (var n2 in t2)
          i2 && i2.unsafe && e2[n2] ? e2[n2] = t2[n2] : Da(e2, n2, t2[n2], i2);
        return e2;
      }, Ld = ta, kd = function(e2) {
        var t2 = Pa(e2), i2 = La.f;
        ka && t2 && !t2[Ma] && i2(t2, Ma, { configurable: true, get: function() {
          return this;
        } });
      }, Md = Ce, Ud = S, xd = q, Vd = function(e2, t2) {
        if (Ua(t2, e2))
          return e2;
        throw xa("Incorrect invocation");
      }, jd = os, Fd = Oo, Bd = function(e2, t2) {
        if (!t2 && !ja)
          return false;
        var i2 = false;
        try {
          var n2 = {};
          n2[Va] = function() {
            return { next: function() {
              return { done: i2 = true };
            } };
          }, e2(n2);
        } catch (e3) {
        }
        return i2;
      }, Gd = hc, Wd = Jc.set, Hd = hd, Kd = Td, Yd = function(e2, t2) {
        var i2 = gd.console;
        i2 && i2.error && (1 == arguments.length ? i2.error(e2) : i2.error(e2, t2));
      }, qd = pd, Jd = Rd, Xd = Id, zd = bs, Qd = jt, Zd = Ad, $d = ji, eu = ae, tu = rt("species"), iu = "Promise", nu = zd.getterFor(iu), ru = zd.set, ou = zd.getterFor(iu), su = Dd && Dd.prototype, au = Dd, cu = su, du = Nd.TypeError, uu = Nd.document, lu = Nd.process, hu = qd.f, pu = hu, _u = !!(uu && uu.createEvent && Nd.dispatchEvent), Eu = Ud(Nd.PromiseRejectionEvent), mu = "unhandledrejection", fu = Qd(iu, function() {
        var e2 = jd(au), t2 = e2 !== String(au);
        if (!t2 && 66 === eu)
          return true;
        if (!cu.finally)
          return true;
        if (eu >= 51 && /native code/.test(e2))
          return false;
        var i2 = new au(function(e3) {
          e3(1);
        }), n2 = function(e3) {
          e3(function() {
          }, function() {
          });
        };
        return (i2.constructor = {})[tu] = n2, !(i2.then(function() {
        }) instanceof n2) || !t2 && Zd && !Eu;
      }), Su = fu || !Bd(function(e2) {
        au.all(e2).catch(function() {
        });
      }), Tu = function(e2) {
        var t2;
        return !(!xd(e2) || !Ud(t2 = e2.then)) && t2;
      }, gu = function(e2, t2) {
        var i2, n2, r2, o2 = t2.value, s2 = 1 == t2.state, a2 = s2 ? e2.ok : e2.fail, c2 = e2.resolve, d2 = e2.reject, u2 = e2.domain;
        try {
          a2 ? (s2 || (2 === t2.rejection && yu(t2), t2.rejection = 1), true === a2 ? i2 = o2 : (u2 && u2.enter(), i2 = a2(o2), u2 && (u2.exit(), r2 = true)), i2 === e2.promise ? d2(du("Promise-chain cycle")) : (n2 = Tu(i2)) ? wd(n2, i2, c2, d2) : c2(i2)) : d2(o2);
        } catch (e3) {
          u2 && !r2 && u2.exit(), d2(e3);
        }
      }, Ru = function(e2, t2) {
        e2.notified || (e2.notified = true, Hd(function() {
          for (var i2, n2 = e2.reactions; i2 = n2.get(); )
            gu(i2, e2);
          e2.notified = false, t2 && !e2.rejection && Cu(e2);
        }));
      }, Iu = function(e2, t2, i2) {
        var n2, r2;
        _u ? ((n2 = uu.createEvent("Event")).promise = t2, n2.reason = i2, n2.initEvent(e2, false, true), Nd.dispatchEvent(n2)) : n2 = { promise: t2, reason: i2 }, !Eu && (r2 = Nd["on" + e2]) ? r2(n2) : e2 === mu && Yd("Unhandled promise rejection", i2);
      }, Cu = function(e2) {
        wd(Wd, Nd, function() {
          var t2, i2 = e2.facade, n2 = e2.value;
          if (vu(e2) && (t2 = Jd(function() {
            $d ? lu.emit("unhandledRejection", n2, i2) : Iu(mu, i2, n2);
          }), e2.rejection = $d || vu(e2) ? 2 : 1, t2.error))
            throw t2.value;
        });
      }, vu = function(e2) {
        return 1 !== e2.rejection && !e2.parent;
      }, yu = function(e2) {
        wd(Wd, Nd, function() {
          var t2 = e2.facade;
          $d ? lu.emit("rejectionHandled", t2) : Iu("rejectionhandled", t2, e2.value);
        });
      }, Au = function(e2, t2, i2) {
        return function(n2) {
          e2(t2, n2, i2);
        };
      }, Ou = function(e2, t2, i2) {
        e2.done || (e2.done = true, i2 && (e2 = i2), e2.value = t2, e2.state = 2, Ru(e2, true));
      }, Nu = function(e2, t2, i2) {
        if (!e2.done) {
          e2.done = true, i2 && (e2 = i2);
          try {
            if (e2.facade === t2)
              throw du("Promise can't be resolved itself");
            var n2 = Tu(t2);
            n2 ? Hd(function() {
              var i3 = { done: false };
              try {
                wd(n2, t2, Au(Nu, i3, e2), Au(Ou, i3, e2));
              } catch (t3) {
                Ou(i3, t3, e2);
              }
            }) : (e2.value = t2, e2.state = 1, Ru(e2, false));
          } catch (t3) {
            Ou({ done: false }, t3, e2);
          }
        }
      };
      fu && (cu = (au = function(e2) {
        Vd(this, cu), Md(e2), wd(Cd, this);
        var t2 = nu(this);
        try {
          e2(Au(Nu, t2), Au(Ou, t2));
        } catch (e3) {
          Ou(t2, e3);
        }
      }).prototype, (Cd = function(e2) {
        ru(this, { type: iu, done: false, notified: false, parent: false, reactions: new Xd(), rejection: false, state: 0, value: void 0 });
      }).prototype = Pd(cu, { then: function(e2, t2) {
        var i2 = ou(this), n2 = hu(Gd(this, au));
        return i2.parent = true, n2.ok = !Ud(e2) || e2, n2.fail = Ud(t2) && t2, n2.domain = $d ? lu.domain : void 0, 0 == i2.state ? i2.reactions.add(n2) : Hd(function() {
          gu(n2, i2);
        }), n2.promise;
      }, catch: function(e2) {
        return this.then(void 0, e2);
      } }), vd = function() {
        var e2 = new Cd(), t2 = nu(e2);
        this.promise = e2, this.resolve = Au(Nu, t2), this.reject = Au(Ou, t2);
      }, qd.f = hu = function(e2) {
        return e2 === au || e2 === yd ? new vd(e2) : pu(e2);
      }), Od({ global: true, wrap: true, forced: fu }, { Promise: au }), Ld(au, iu, false, true), kd(iu), yd = bd(iu), Od({ target: iu, stat: true, forced: fu }, { reject: function(e2) {
        var t2 = hu(this);
        return wd(t2.reject, void 0, e2), t2.promise;
      } }), Od({ target: iu, stat: true, forced: true }, { resolve: function(e2) {
        return Kd(this === yd ? au : this, e2);
      } }), Od({ target: iu, stat: true, forced: Su }, { all: function(e2) {
        var t2 = this, i2 = hu(t2), n2 = i2.resolve, r2 = i2.reject, o2 = Jd(function() {
          var i3 = Md(t2.resolve), o3 = [], s2 = 0, a2 = 1;
          Fd(e2, function(e3) {
            var c2 = s2++, d2 = false;
            a2++, wd(i3, t2, e3).then(function(e4) {
              d2 || (d2 = true, o3[c2] = e4, --a2 || n2(o3));
            }, r2);
          }), --a2 || n2(o3);
        });
        return o2.error && r2(o2.value), i2.promise;
      }, race: function(e2) {
        var t2 = this, i2 = hu(t2), n2 = i2.reject, r2 = Jd(function() {
          var r3 = Md(t2.resolve);
          Fd(e2, function(e3) {
            wd(r3, t2, e3).then(i2.resolve, n2);
          });
        });
        return r2.error && n2(r2.value), i2.promise;
      } });
      var bu = C, wu = Ce, Du = pd, Pu = Rd, Lu = Oo;
      Ii({ target: "Promise", stat: true }, { allSettled: function(e2) {
        var t2 = this, i2 = Du.f(t2), n2 = i2.resolve, r2 = i2.reject, o2 = Pu(function() {
          var i3 = wu(t2.resolve), r3 = [], o3 = 0, s2 = 1;
          Lu(e2, function(e3) {
            var a2 = o3++, c2 = false;
            s2++, bu(i3, t2, e3).then(function(e4) {
              c2 || (c2 = true, r3[a2] = { status: "fulfilled", value: e4 }, --s2 || n2(r3));
            }, function(e4) {
              c2 || (c2 = true, r3[a2] = { status: "rejected", reason: e4 }, --s2 || n2(r3));
            });
          }), --s2 || n2(r3);
        });
        return o2.error && r2(o2.value), i2.promise;
      } });
      var ku = Ce, Mu = $, Uu = C, xu = pd, Vu = Rd, ju = Oo, Fu = "No one promise resolved";
      Ii({ target: "Promise", stat: true }, { any: function(e2) {
        var t2 = this, i2 = Mu("AggregateError"), n2 = xu.f(t2), r2 = n2.resolve, o2 = n2.reject, s2 = Vu(function() {
          var n3 = ku(t2.resolve), s3 = [], a2 = 0, c2 = 1, d2 = false;
          ju(e2, function(e3) {
            var u2 = a2++, l2 = false;
            c2++, Uu(n3, t2, e3).then(function(e4) {
              l2 || d2 || (d2 = true, r2(e4));
            }, function(e4) {
              l2 || d2 || (l2 = true, s3[u2] = e4, --c2 || o2(new i2(s3, Fu)));
            });
          }), --c2 || o2(new i2(s3, Fu));
        });
        return s2.error && o2(s2.value), n2.promise;
      } });
      var Bu = wa, Gu = $, Wu = S, Hu = hc, Ku = Td;
      Ii({ target: "Promise", proto: true, real: true, forced: !!Bu && i(function() {
        Bu.prototype.finally.call({ then: function() {
        } }, function() {
        });
      }) }, { finally: function(e2) {
        var t2 = Hu(this, Gu("Promise")), i2 = Wu(e2);
        return this.then(i2 ? function(i3) {
          return Ku(t2, e2()).then(function() {
            return i3;
          });
        } : e2, i2 ? function(i3) {
          return Ku(t2, e2()).then(function() {
            throw i3;
          });
        } : e2);
      } });
      var Yu = d, qu = yi, Ju = wo, Xu = G, zu = Yu("".charAt), Qu = Yu("".charCodeAt), Zu = Yu("".slice), $u = function(e2) {
        return function(t2, i2) {
          var n2, r2, o2 = Ju(Xu(t2)), s2 = qu(i2), a2 = o2.length;
          return s2 < 0 || s2 >= a2 ? e2 ? "" : void 0 : (n2 = Qu(o2, s2)) < 55296 || n2 > 56319 || s2 + 1 === a2 || (r2 = Qu(o2, s2 + 1)) < 56320 || r2 > 57343 ? e2 ? zu(o2, s2) : n2 : e2 ? Zu(o2, s2, s2 + 2) : r2 - 56320 + (n2 - 55296 << 10) + 65536;
        };
      }, el = { codeAt: $u(false), charAt: $u(true) }.charAt, tl = wo, il = bs, nl = Ia, rl = "String Iterator", ol = il.set, sl = il.getterFor(rl);
      nl(String, "String", function(e2) {
        ol(this, { type: rl, string: tl(e2), index: 0 });
      }, function() {
        var e2, t2 = sl(this), i2 = t2.string, n2 = t2.index;
        return n2 >= i2.length ? { value: void 0, done: true } : (e2 = el(i2, n2), t2.index += e2.length, { value: e2, done: false });
      });
      var al = J.Promise, cl = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, dl = h, ul = Zr, ll = ui, hl = jr, pl = rt("toStringTag");
      for (var _l in cl) {
        var El = dl[_l], ml = El && El.prototype;
        ml && ul(ml) !== pl && ll(ml, pl, _l), hl[_l] = hl.Array;
      }
      var fl = al, Sl = fl;
      const Tl = rn;
      function gl(e2, t2) {
        const i2 = e2 && e2.navigator;
        if (!i2.mediaDevices)
          return;
        const n2 = function(e3) {
          if ("object" != typeof e3 || e3.mandatory || e3.optional)
            return e3;
          const t3 = {};
          return Object.keys(e3).forEach((i3) => {
            if ("require" === i3 || "advanced" === i3 || "mediaSource" === i3)
              return;
            const n3 = "object" == typeof e3[i3] ? e3[i3] : { ideal: e3[i3] };
            void 0 !== n3.exact && "number" == typeof n3.exact && (n3.min = n3.max = n3.exact);
            const r3 = function(e4, t4) {
              return e4 ? e4 + t4.charAt(0).toUpperCase() + t4.slice(1) : "deviceId" === t4 ? "sourceId" : t4;
            };
            if (void 0 !== n3.ideal) {
              t3.optional = t3.optional || [];
              let e4 = {};
              "number" == typeof n3.ideal ? (e4[r3("min", i3)] = n3.ideal, t3.optional.push(e4), e4 = {}, e4[r3("max", i3)] = n3.ideal, t3.optional.push(e4)) : (e4[r3("", i3)] = n3.ideal, t3.optional.push(e4));
            }
            void 0 !== n3.exact && "number" != typeof n3.exact ? (t3.mandatory = t3.mandatory || {}, t3.mandatory[r3("", i3)] = n3.exact) : ["min", "max"].forEach((e4) => {
              void 0 !== n3[e4] && (t3.mandatory = t3.mandatory || {}, t3.mandatory[r3(e4, i3)] = n3[e4]);
            });
          }), e3.advanced && (t3.optional = (t3.optional || []).concat(e3.advanced)), t3;
        }, r2 = function(e3, r3) {
          if (t2.version >= 61)
            return r3(e3);
          if ((e3 = JSON.parse(JSON.stringify(e3))) && "object" == typeof e3.audio) {
            const t3 = function(e4, t4, i3) {
              t4 in e4 && !(i3 in e4) && (e4[i3] = e4[t4], delete e4[t4]);
            };
            t3((e3 = JSON.parse(JSON.stringify(e3))).audio, "autoGainControl", "googAutoGainControl"), t3(e3.audio, "noiseSuppression", "googNoiseSuppression"), e3.audio = n2(e3.audio);
          }
          if (e3 && "object" == typeof e3.video) {
            let o3 = e3.video.facingMode;
            o3 = o3 && ("object" == typeof o3 ? o3 : { ideal: o3 });
            const s2 = t2.version < 66;
            if (o3 && ("user" === o3.exact || "environment" === o3.exact || "user" === o3.ideal || "environment" === o3.ideal) && (!i2.mediaDevices.getSupportedConstraints || !i2.mediaDevices.getSupportedConstraints().facingMode || s2)) {
              let t3;
              if (delete e3.video.facingMode, "environment" === o3.exact || "environment" === o3.ideal ? t3 = ["back", "rear"] : "user" !== o3.exact && "user" !== o3.ideal || (t3 = ["front"]), t3)
                return i2.mediaDevices.enumerateDevices().then((i3) => {
                  let s3 = (i3 = i3.filter((e4) => "videoinput" === e4.kind)).find((e4) => t3.some((t4) => e4.label.toLowerCase().includes(t4)));
                  return !s3 && i3.length && t3.includes("back") && (s3 = i3[i3.length - 1]), s3 && (e3.video.deviceId = o3.exact ? { exact: s3.deviceId } : { ideal: s3.deviceId }), e3.video = n2(e3.video), Tl("chrome: " + JSON.stringify(e3)), r3(e3);
                });
            }
            e3.video = n2(e3.video);
          }
          return Tl("chrome: " + JSON.stringify(e3)), r3(e3);
        }, o2 = function(e3) {
          return t2.version >= 64 ? e3 : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[e3.name] || e3.name, message: e3.message, constraint: e3.constraint || e3.constraintName, toString() {
            return this.name + (this.message && ": ") + this.message;
          } };
        };
        if (i2.getUserMedia = function(e3, t3, n3) {
          r2(e3, (e4) => {
            i2.webkitGetUserMedia(e4, t3, (e5) => {
              n3 && n3(o2(e5));
            });
          });
        }.bind(i2), i2.mediaDevices.getUserMedia) {
          const e3 = i2.mediaDevices.getUserMedia.bind(i2.mediaDevices);
          i2.mediaDevices.getUserMedia = function(t3) {
            return r2(t3, (t4) => e3(t4).then((e4) => {
              if (t4.audio && !e4.getAudioTracks().length || t4.video && !e4.getVideoTracks().length)
                throw e4.getTracks().forEach((e5) => {
                  e5.stop();
                }), new DOMException("", "NotFoundError");
              return e4;
            }, (e4) => Sl.reject(o2(e4))));
          };
        }
      }
      function Rl(e2) {
        e2.MediaStream = e2.MediaStream || e2.webkitMediaStream;
      }
      function Il(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection && !("ontrack" in e2.RTCPeerConnection.prototype)) {
          Object.defineProperty(e2.RTCPeerConnection.prototype, "ontrack", { get() {
            return this._ontrack;
          }, set(e3) {
            this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e3);
          }, enumerable: true, configurable: true });
          const t2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
          e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
            return this._ontrackpoly || (this._ontrackpoly = (t3) => {
              t3.stream.addEventListener("addtrack", (i2) => {
                let n2;
                n2 = e2.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e3) => e3.track && e3.track.id === i2.track.id) : { track: i2.track };
                const r2 = new Event("track");
                r2.track = i2.track, r2.receiver = n2, r2.transceiver = { receiver: n2 }, r2.streams = [t3.stream], this.dispatchEvent(r2);
              }), t3.stream.getTracks().forEach((i2) => {
                let n2;
                n2 = e2.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e3) => e3.track && e3.track.id === i2.id) : { track: i2 };
                const r2 = new Event("track");
                r2.track = i2, r2.receiver = n2, r2.transceiver = { receiver: n2 }, r2.streams = [t3.stream], this.dispatchEvent(r2);
              });
            }, this.addEventListener("addstream", this._ontrackpoly)), t2.apply(this, arguments);
          };
        } else
          en(e2, "track", (e3) => (e3.transceiver || Object.defineProperty(e3, "transceiver", { value: { receiver: e3.receiver } }), e3));
      }
      function Cl(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection && !("getSenders" in e2.RTCPeerConnection.prototype) && "createDTMFSender" in e2.RTCPeerConnection.prototype) {
          const t2 = function(e3, t3) {
            return { track: t3, get dtmf() {
              return void 0 === this._dtmf && ("audio" === t3.kind ? this._dtmf = e3.createDTMFSender(t3) : this._dtmf = null), this._dtmf;
            }, _pc: e3 };
          };
          if (!e2.RTCPeerConnection.prototype.getSenders) {
            e2.RTCPeerConnection.prototype.getSenders = function() {
              return this._senders = this._senders || [], this._senders.slice();
            };
            const i3 = e2.RTCPeerConnection.prototype.addTrack;
            e2.RTCPeerConnection.prototype.addTrack = function(e3, n4) {
              let r2 = i3.apply(this, arguments);
              return r2 || (r2 = t2(this, e3), this._senders.push(r2)), r2;
            };
            const n3 = e2.RTCPeerConnection.prototype.removeTrack;
            e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
              n3.apply(this, arguments);
              const t3 = this._senders.indexOf(e3);
              -1 !== t3 && this._senders.splice(t3, 1);
            };
          }
          const i2 = e2.RTCPeerConnection.prototype.addStream;
          e2.RTCPeerConnection.prototype.addStream = function(e3) {
            this._senders = this._senders || [], i2.apply(this, [e3]), e3.getTracks().forEach((e4) => {
              this._senders.push(t2(this, e4));
            });
          };
          const n2 = e2.RTCPeerConnection.prototype.removeStream;
          e2.RTCPeerConnection.prototype.removeStream = function(e3) {
            this._senders = this._senders || [], n2.apply(this, [e3]), e3.getTracks().forEach((e4) => {
              const t3 = this._senders.find((t4) => t4.track === e4);
              t3 && this._senders.splice(this._senders.indexOf(t3), 1);
            });
          };
        } else if ("object" == typeof e2 && e2.RTCPeerConnection && "getSenders" in e2.RTCPeerConnection.prototype && "createDTMFSender" in e2.RTCPeerConnection.prototype && e2.RTCRtpSender && !("dtmf" in e2.RTCRtpSender.prototype)) {
          const t2 = e2.RTCPeerConnection.prototype.getSenders;
          e2.RTCPeerConnection.prototype.getSenders = function() {
            const e3 = t2.apply(this, []);
            return e3.forEach((e4) => e4._pc = this), e3;
          }, Object.defineProperty(e2.RTCRtpSender.prototype, "dtmf", { get() {
            return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;
          } });
        }
      }
      function vl(e2) {
        if (!e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection.prototype.getStats;
        e2.RTCPeerConnection.prototype.getStats = function() {
          const [e3, i2, n2] = arguments;
          if (arguments.length > 0 && "function" == typeof e3)
            return t2.apply(this, arguments);
          if (0 === t2.length && (0 === arguments.length || "function" != typeof e3))
            return t2.apply(this, []);
          const r2 = function(e4) {
            const t3 = {};
            return e4.result().forEach((e5) => {
              const i3 = { id: e5.id, timestamp: e5.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e5.type] || e5.type };
              e5.names().forEach((t4) => {
                i3[t4] = e5.stat(t4);
              }), t3[i3.id] = i3;
            }), t3;
          }, o2 = function(e4) {
            return new Map(Object.keys(e4).map((t3) => [t3, e4[t3]]));
          };
          if (arguments.length >= 2) {
            const n3 = function(e4) {
              i2(o2(r2(e4)));
            };
            return t2.apply(this, [n3, e3]);
          }
          return new Sl((e4, i3) => {
            t2.apply(this, [function(t3) {
              e4(o2(r2(t3)));
            }, i3]);
          }).then(i2, n2);
        };
      }
      function yl(e2) {
        if (!("object" == typeof e2 && e2.RTCPeerConnection && e2.RTCRtpSender && e2.RTCRtpReceiver))
          return;
        if (!("getStats" in e2.RTCRtpSender.prototype)) {
          const t3 = e2.RTCPeerConnection.prototype.getSenders;
          t3 && (e2.RTCPeerConnection.prototype.getSenders = function() {
            const e3 = t3.apply(this, []);
            return e3.forEach((e4) => e4._pc = this), e3;
          });
          const i2 = e2.RTCPeerConnection.prototype.addTrack;
          i2 && (e2.RTCPeerConnection.prototype.addTrack = function() {
            const e3 = i2.apply(this, arguments);
            return e3._pc = this, e3;
          }), e2.RTCRtpSender.prototype.getStats = function() {
            const e3 = this;
            return this._pc.getStats().then((t4) => dn(t4, e3.track, true));
          };
        }
        if (!("getStats" in e2.RTCRtpReceiver.prototype)) {
          const t3 = e2.RTCPeerConnection.prototype.getReceivers;
          t3 && (e2.RTCPeerConnection.prototype.getReceivers = function() {
            const e3 = t3.apply(this, []);
            return e3.forEach((e4) => e4._pc = this), e3;
          }), en(e2, "track", (e3) => (e3.receiver._pc = e3.srcElement, e3)), e2.RTCRtpReceiver.prototype.getStats = function() {
            const e3 = this;
            return this._pc.getStats().then((t4) => dn(t4, e3.track, false));
          };
        }
        if (!("getStats" in e2.RTCRtpSender.prototype) || !("getStats" in e2.RTCRtpReceiver.prototype))
          return;
        const t2 = e2.RTCPeerConnection.prototype.getStats;
        e2.RTCPeerConnection.prototype.getStats = function() {
          if (arguments.length > 0 && arguments[0] instanceof e2.MediaStreamTrack) {
            const e3 = arguments[0];
            let t3, i2, n2;
            return this.getSenders().forEach((i3) => {
              i3.track === e3 && (t3 ? n2 = true : t3 = i3);
            }), this.getReceivers().forEach((t4) => (t4.track === e3 && (i2 ? n2 = true : i2 = t4), t4.track === e3)), n2 || t3 && i2 ? Sl.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : t3 ? t3.getStats() : i2 ? i2.getStats() : Sl.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
          }
          return t2.apply(this, arguments);
        };
      }
      function Al(e2) {
        e2.RTCPeerConnection.prototype.getLocalStreams = function() {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((e3) => this._shimmedLocalStreams[e3][0]);
        };
        const t2 = e2.RTCPeerConnection.prototype.addTrack;
        e2.RTCPeerConnection.prototype.addTrack = function(e3, i3) {
          if (!i3)
            return t2.apply(this, arguments);
          this._shimmedLocalStreams = this._shimmedLocalStreams || {};
          const n3 = t2.apply(this, arguments);
          return this._shimmedLocalStreams[i3.id] ? -1 === this._shimmedLocalStreams[i3.id].indexOf(n3) && this._shimmedLocalStreams[i3.id].push(n3) : this._shimmedLocalStreams[i3.id] = [i3, n3], n3;
        };
        const i2 = e2.RTCPeerConnection.prototype.addStream;
        e2.RTCPeerConnection.prototype.addStream = function(e3) {
          this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e3.getTracks().forEach((e4) => {
            if (this.getSenders().find((t4) => t4.track === e4))
              throw new DOMException("Track already exists.", "InvalidAccessError");
          });
          const t3 = this.getSenders();
          i2.apply(this, arguments);
          const n3 = this.getSenders().filter((e4) => -1 === t3.indexOf(e4));
          this._shimmedLocalStreams[e3.id] = [e3].concat(n3);
        };
        const n2 = e2.RTCPeerConnection.prototype.removeStream;
        e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e3.id], n2.apply(this, arguments);
        };
        const r2 = e2.RTCPeerConnection.prototype.removeTrack;
        e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e3 && Object.keys(this._shimmedLocalStreams).forEach((t3) => {
            const i3 = this._shimmedLocalStreams[t3].indexOf(e3);
            -1 !== i3 && this._shimmedLocalStreams[t3].splice(i3, 1), 1 === this._shimmedLocalStreams[t3].length && delete this._shimmedLocalStreams[t3];
          }), r2.apply(this, arguments);
        };
      }
      function Ol(e2, t2) {
        if (!e2.RTCPeerConnection)
          return;
        if (e2.RTCPeerConnection.prototype.addTrack && t2.version >= 65)
          return Al(e2);
        const i2 = e2.RTCPeerConnection.prototype.getLocalStreams;
        e2.RTCPeerConnection.prototype.getLocalStreams = function() {
          const e3 = i2.apply(this);
          return this._reverseStreams = this._reverseStreams || {}, e3.map((e4) => this._reverseStreams[e4.id]);
        };
        const n2 = e2.RTCPeerConnection.prototype.addStream;
        e2.RTCPeerConnection.prototype.addStream = function(t3) {
          if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t3.getTracks().forEach((e3) => {
            if (this.getSenders().find((t4) => t4.track === e3))
              throw new DOMException("Track already exists.", "InvalidAccessError");
          }), !this._reverseStreams[t3.id]) {
            const i3 = new e2.MediaStream(t3.getTracks());
            this._streams[t3.id] = i3, this._reverseStreams[i3.id] = t3, t3 = i3;
          }
          n2.apply(this, [t3]);
        };
        const r2 = e2.RTCPeerConnection.prototype.removeStream;
        function o2(e3, t3) {
          let i3 = t3.sdp;
          return Object.keys(e3._reverseStreams || []).forEach((t4) => {
            const n3 = e3._reverseStreams[t4], r3 = e3._streams[n3.id];
            i3 = i3.replace(new RegExp(r3.id, "g"), n3.id);
          }), new RTCSessionDescription({ type: t3.type, sdp: i3 });
        }
        function s2(e3, t3) {
          let i3 = t3.sdp;
          return Object.keys(e3._reverseStreams || []).forEach((t4) => {
            const n3 = e3._reverseStreams[t4], r3 = e3._streams[n3.id];
            i3 = i3.replace(new RegExp(n3.id, "g"), r3.id);
          }), new RTCSessionDescription({ type: t3.type, sdp: i3 });
        }
        e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, r2.apply(this, [this._streams[e3.id] || e3]), delete this._reverseStreams[this._streams[e3.id] ? this._streams[e3.id].id : e3.id], delete this._streams[e3.id];
        }, e2.RTCPeerConnection.prototype.addTrack = function(t3, i3) {
          if ("closed" === this.signalingState)
            throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
          const n3 = [].slice.call(arguments, 1);
          if (1 !== n3.length || !n3[0].getTracks().find((e3) => e3 === t3))
            throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
          const r3 = this.getSenders().find((e3) => e3.track === t3);
          if (r3)
            throw new DOMException("Track already exists.", "InvalidAccessError");
          this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
          const o3 = this._streams[i3.id];
          if (o3)
            o3.addTrack(t3), Sl.resolve().then(() => {
              this.dispatchEvent(new Event("negotiationneeded"));
            });
          else {
            const n4 = new e2.MediaStream([t3]);
            this._streams[i3.id] = n4, this._reverseStreams[n4.id] = i3, this.addStream(n4);
          }
          return this.getSenders().find((e3) => e3.track === t3);
        }, ["createOffer", "createAnswer"].forEach(function(t3) {
          const i3 = e2.RTCPeerConnection.prototype[t3], n3 = { [t3]() {
            const e3 = arguments;
            return arguments.length && "function" == typeof arguments[0] ? i3.apply(this, [(t4) => {
              const i4 = o2(this, t4);
              e3[0].apply(null, [i4]);
            }, (t4) => {
              e3[1] && e3[1].apply(null, t4);
            }, arguments[2]]) : i3.apply(this, arguments).then((e4) => o2(this, e4));
          } };
          e2.RTCPeerConnection.prototype[t3] = n3[t3];
        });
        const a2 = e2.RTCPeerConnection.prototype.setLocalDescription;
        e2.RTCPeerConnection.prototype.setLocalDescription = function() {
          return arguments.length && arguments[0].type ? (arguments[0] = s2(this, arguments[0]), a2.apply(this, arguments)) : a2.apply(this, arguments);
        };
        const c2 = Object.getOwnPropertyDescriptor(e2.RTCPeerConnection.prototype, "localDescription");
        Object.defineProperty(e2.RTCPeerConnection.prototype, "localDescription", { get() {
          const e3 = c2.get.apply(this);
          return "" === e3.type ? e3 : o2(this, e3);
        } }), e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
          if ("closed" === this.signalingState)
            throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
          if (!e3._pc)
            throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
          if (!(e3._pc === this))
            throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
          let t3;
          this._streams = this._streams || {}, Object.keys(this._streams).forEach((i3) => {
            this._streams[i3].getTracks().find((t4) => e3.track === t4) && (t3 = this._streams[i3]);
          }), t3 && (1 === t3.getTracks().length ? this.removeStream(this._reverseStreams[t3.id]) : t3.removeTrack(e3.track), this.dispatchEvent(new Event("negotiationneeded")));
        };
      }
      function Nl(e2, t2) {
        !e2.RTCPeerConnection && e2.webkitRTCPeerConnection && (e2.RTCPeerConnection = e2.webkitRTCPeerConnection), e2.RTCPeerConnection && t2.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t3) {
          const i2 = e2.RTCPeerConnection.prototype[t3], n2 = { [t3]() {
            return arguments[0] = new ("addIceCandidate" === t3 ? e2.RTCIceCandidate : e2.RTCSessionDescription)(arguments[0]), i2.apply(this, arguments);
          } };
          e2.RTCPeerConnection.prototype[t3] = n2[t3];
        });
      }
      function bl(e2, t2) {
        en(e2, "negotiationneeded", (e3) => {
          const i2 = e3.target;
          if (!(t2.version < 72 || i2.getConfiguration && "plan-b" === i2.getConfiguration().sdpSemantics) || "stable" === i2.signalingState)
            return e3;
        });
      }
      var wl = Object.freeze({ __proto__: null, shimMediaStream: Rl, shimOnTrack: Il, shimGetSendersWithDtmf: Cl, shimGetStats: vl, shimSenderReceiverGetStats: yl, shimAddTrackRemoveTrackWithNative: Al, shimAddTrackRemoveTrack: Ol, shimPeerConnection: Nl, fixNegotiationNeeded: bl, shimGetUserMedia: gl, shimGetDisplayMedia: function(e2, t2) {
        e2.navigator.mediaDevices && "getDisplayMedia" in e2.navigator.mediaDevices || e2.navigator.mediaDevices && ("function" == typeof t2 ? e2.navigator.mediaDevices.getDisplayMedia = function(i2) {
          return t2(i2).then((t3) => {
            const n2 = i2.video && i2.video.width, r2 = i2.video && i2.video.height, o2 = i2.video && i2.video.frameRate;
            return i2.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: t3, maxFrameRate: o2 || 3 } }, n2 && (i2.video.mandatory.maxWidth = n2), r2 && (i2.video.mandatory.maxHeight = r2), e2.navigator.mediaDevices.getUserMedia(i2);
          });
        } : console.error("shimGetDisplayMedia: getSourceId argument is not a function"));
      } });
      function Dl(e2, t2) {
        const i2 = e2 && e2.navigator, n2 = e2 && e2.MediaStreamTrack;
        if (i2.getUserMedia = function(e3, t3, n3) {
          on("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), i2.mediaDevices.getUserMedia(e3).then(t3, n3);
        }, !(t2.version > 55 && "autoGainControl" in i2.mediaDevices.getSupportedConstraints())) {
          const e3 = function(e4, t4, i3) {
            t4 in e4 && !(i3 in e4) && (e4[i3] = e4[t4], delete e4[t4]);
          }, t3 = i2.mediaDevices.getUserMedia.bind(i2.mediaDevices);
          if (i2.mediaDevices.getUserMedia = function(i3) {
            return "object" == typeof i3 && "object" == typeof i3.audio && (i3 = JSON.parse(JSON.stringify(i3)), e3(i3.audio, "autoGainControl", "mozAutoGainControl"), e3(i3.audio, "noiseSuppression", "mozNoiseSuppression")), t3(i3);
          }, n2 && n2.prototype.getSettings) {
            const t4 = n2.prototype.getSettings;
            n2.prototype.getSettings = function() {
              const i3 = t4.apply(this, arguments);
              return e3(i3, "mozAutoGainControl", "autoGainControl"), e3(i3, "mozNoiseSuppression", "noiseSuppression"), i3;
            };
          }
          if (n2 && n2.prototype.applyConstraints) {
            const t4 = n2.prototype.applyConstraints;
            n2.prototype.applyConstraints = function(i3) {
              return "audio" === this.kind && "object" == typeof i3 && (i3 = JSON.parse(JSON.stringify(i3)), e3(i3, "autoGainControl", "mozAutoGainControl"), e3(i3, "noiseSuppression", "mozNoiseSuppression")), t4.apply(this, [i3]);
            };
          }
        }
      }
      function Pl(e2) {
        "object" == typeof e2 && e2.RTCTrackEvent && "receiver" in e2.RTCTrackEvent.prototype && !("transceiver" in e2.RTCTrackEvent.prototype) && Object.defineProperty(e2.RTCTrackEvent.prototype, "transceiver", { get() {
          return { receiver: this.receiver };
        } });
      }
      function Ll(e2, t2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection && !e2.mozRTCPeerConnection)
          return;
        !e2.RTCPeerConnection && e2.mozRTCPeerConnection && (e2.RTCPeerConnection = e2.mozRTCPeerConnection), t2.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t3) {
          const i3 = e2.RTCPeerConnection.prototype[t3], n3 = { [t3]() {
            return arguments[0] = new ("addIceCandidate" === t3 ? e2.RTCIceCandidate : e2.RTCSessionDescription)(arguments[0]), i3.apply(this, arguments);
          } };
          e2.RTCPeerConnection.prototype[t3] = n3[t3];
        });
        const i2 = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, n2 = e2.RTCPeerConnection.prototype.getStats;
        e2.RTCPeerConnection.prototype.getStats = function() {
          const [e3, r2, o2] = arguments;
          return n2.apply(this, [e3 || null]).then((e4) => {
            if (t2.version < 53 && !r2)
              try {
                e4.forEach((e5) => {
                  e5.type = i2[e5.type] || e5.type;
                });
              } catch (t3) {
                if ("TypeError" !== t3.name)
                  throw t3;
                e4.forEach((t4, n3) => {
                  e4.set(n3, Object.assign({}, t4, { type: i2[t4.type] || t4.type }));
                });
              }
            return e4;
          }).then(r2, o2);
        };
      }
      function kl(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection || !e2.RTCRtpSender)
          return;
        if (e2.RTCRtpSender && "getStats" in e2.RTCRtpSender.prototype)
          return;
        const t2 = e2.RTCPeerConnection.prototype.getSenders;
        t2 && (e2.RTCPeerConnection.prototype.getSenders = function() {
          const e3 = t2.apply(this, []);
          return e3.forEach((e4) => e4._pc = this), e3;
        });
        const i2 = e2.RTCPeerConnection.prototype.addTrack;
        i2 && (e2.RTCPeerConnection.prototype.addTrack = function() {
          const e3 = i2.apply(this, arguments);
          return e3._pc = this, e3;
        }), e2.RTCRtpSender.prototype.getStats = function() {
          return this.track ? this._pc.getStats(this.track) : Sl.resolve(/* @__PURE__ */ new Map());
        };
      }
      function Ml(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection || !e2.RTCRtpSender)
          return;
        if (e2.RTCRtpSender && "getStats" in e2.RTCRtpReceiver.prototype)
          return;
        const t2 = e2.RTCPeerConnection.prototype.getReceivers;
        t2 && (e2.RTCPeerConnection.prototype.getReceivers = function() {
          const e3 = t2.apply(this, []);
          return e3.forEach((e4) => e4._pc = this), e3;
        }), en(e2, "track", (e3) => (e3.receiver._pc = e3.srcElement, e3)), e2.RTCRtpReceiver.prototype.getStats = function() {
          return this._pc.getStats(this.track);
        };
      }
      function Ul(e2) {
        e2.RTCPeerConnection && !("removeStream" in e2.RTCPeerConnection.prototype) && (e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          on("removeStream", "removeTrack"), this.getSenders().forEach((t2) => {
            t2.track && e3.getTracks().includes(t2.track) && this.removeTrack(t2);
          });
        });
      }
      function xl(e2) {
        e2.DataChannel && !e2.RTCDataChannel && (e2.RTCDataChannel = e2.DataChannel);
      }
      function Vl(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection.prototype.addTransceiver;
        t2 && (e2.RTCPeerConnection.prototype.addTransceiver = function() {
          this.setParametersPromises = [];
          let e3 = arguments[1] && arguments[1].sendEncodings;
          void 0 === e3 && (e3 = []), e3 = [...e3];
          const i2 = e3.length > 0;
          i2 && e3.forEach((e4) => {
            if ("rid" in e4) {
              if (!/^[a-z0-9]{0,16}$/i.test(e4.rid))
                throw new TypeError("Invalid RID value provided.");
            }
            if ("scaleResolutionDownBy" in e4 && !(parseFloat(e4.scaleResolutionDownBy) >= 1))
              throw new RangeError("scale_resolution_down_by must be >= 1.0");
            if ("maxFramerate" in e4 && !(parseFloat(e4.maxFramerate) >= 0))
              throw new RangeError("max_framerate must be >= 0.0");
          });
          const n2 = t2.apply(this, arguments);
          if (i2) {
            const { sender: t3 } = n2, i3 = t3.getParameters();
            (!("encodings" in i3) || 1 === i3.encodings.length && 0 === Object.keys(i3.encodings[0]).length) && (i3.encodings = e3, t3.sendEncodings = e3, this.setParametersPromises.push(t3.setParameters(i3).then(() => {
              delete t3.sendEncodings;
            }).catch(() => {
              delete t3.sendEncodings;
            })));
          }
          return n2;
        });
      }
      function jl(e2) {
        if ("object" != typeof e2 || !e2.RTCRtpSender)
          return;
        const t2 = e2.RTCRtpSender.prototype.getParameters;
        t2 && (e2.RTCRtpSender.prototype.getParameters = function() {
          const e3 = t2.apply(this, arguments);
          return "encodings" in e3 || (e3.encodings = [].concat(this.sendEncodings || [{}])), e3;
        });
      }
      function Fl(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection.prototype.createOffer;
        e2.RTCPeerConnection.prototype.createOffer = function() {
          return this.setParametersPromises && this.setParametersPromises.length ? Sl.all(this.setParametersPromises).then(() => t2.apply(this, arguments)).finally(() => {
            this.setParametersPromises = [];
          }) : t2.apply(this, arguments);
        };
      }
      function Bl(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection.prototype.createAnswer;
        e2.RTCPeerConnection.prototype.createAnswer = function() {
          return this.setParametersPromises && this.setParametersPromises.length ? Sl.all(this.setParametersPromises).then(() => t2.apply(this, arguments)).finally(() => {
            this.setParametersPromises = [];
          }) : t2.apply(this, arguments);
        };
      }
      var Gl = Object.freeze({ __proto__: null, shimOnTrack: Pl, shimPeerConnection: Ll, shimSenderGetStats: kl, shimReceiverGetStats: Ml, shimRemoveStream: Ul, shimRTCDataChannel: xl, shimAddTransceiver: Vl, shimGetParameters: jl, shimCreateOffer: Fl, shimCreateAnswer: Bl, shimGetUserMedia: Dl, shimGetDisplayMedia: function(e2, t2) {
        e2.navigator.mediaDevices && "getDisplayMedia" in e2.navigator.mediaDevices || e2.navigator.mediaDevices && (e2.navigator.mediaDevices.getDisplayMedia = function(i2) {
          if (!i2 || !i2.video) {
            const e3 = new DOMException("getDisplayMedia without video constraints is undefined");
            return e3.name = "NotFoundError", e3.code = 8, Sl.reject(e3);
          }
          return true === i2.video ? i2.video = { mediaSource: t2 } : i2.video.mediaSource = t2, e2.navigator.mediaDevices.getUserMedia(i2);
        });
      } });
      function Wl(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection) {
          if ("getLocalStreams" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.getLocalStreams = function() {
            return this._localStreams || (this._localStreams = []), this._localStreams;
          }), !("addStream" in e2.RTCPeerConnection.prototype)) {
            const t2 = e2.RTCPeerConnection.prototype.addTrack;
            e2.RTCPeerConnection.prototype.addStream = function(e3) {
              this._localStreams || (this._localStreams = []), this._localStreams.includes(e3) || this._localStreams.push(e3), e3.getAudioTracks().forEach((i2) => t2.call(this, i2, e3)), e3.getVideoTracks().forEach((i2) => t2.call(this, i2, e3));
            }, e2.RTCPeerConnection.prototype.addTrack = function(e3) {
              for (var i2 = arguments.length, n2 = new Array(i2 > 1 ? i2 - 1 : 0), r2 = 1; r2 < i2; r2++)
                n2[r2 - 1] = arguments[r2];
              return n2 && n2.forEach((e4) => {
                this._localStreams ? this._localStreams.includes(e4) || this._localStreams.push(e4) : this._localStreams = [e4];
              }), t2.apply(this, arguments);
            };
          }
          "removeStream" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.removeStream = function(e3) {
            this._localStreams || (this._localStreams = []);
            const t2 = this._localStreams.indexOf(e3);
            if (-1 === t2)
              return;
            this._localStreams.splice(t2, 1);
            const i2 = e3.getTracks();
            this.getSenders().forEach((e4) => {
              i2.includes(e4.track) && this.removeTrack(e4);
            });
          });
        }
      }
      function Hl(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection && ("getRemoteStreams" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.getRemoteStreams = function() {
          return this._remoteStreams ? this._remoteStreams : [];
        }), !("onaddstream" in e2.RTCPeerConnection.prototype))) {
          Object.defineProperty(e2.RTCPeerConnection.prototype, "onaddstream", { get() {
            return this._onaddstream;
          }, set(e3) {
            this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e3), this.addEventListener("track", this._onaddstreampoly = (e4) => {
              e4.streams.forEach((e5) => {
                if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(e5))
                  return;
                this._remoteStreams.push(e5);
                const t3 = new Event("addstream");
                t3.stream = e5, this.dispatchEvent(t3);
              });
            });
          } });
          const t2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
          e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
            const e3 = this;
            return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(t3) {
              t3.streams.forEach((t4) => {
                if (e3._remoteStreams || (e3._remoteStreams = []), e3._remoteStreams.indexOf(t4) >= 0)
                  return;
                e3._remoteStreams.push(t4);
                const i2 = new Event("addstream");
                i2.stream = t4, e3.dispatchEvent(i2);
              });
            }), t2.apply(e3, arguments);
          };
        }
      }
      function Kl(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection.prototype, i2 = t2.createOffer, n2 = t2.createAnswer, r2 = t2.setLocalDescription, o2 = t2.setRemoteDescription, s2 = t2.addIceCandidate;
        t2.createOffer = function(e3, t3) {
          const n3 = arguments.length >= 2 ? arguments[2] : arguments[0], r3 = i2.apply(this, [n3]);
          return t3 ? (r3.then(e3, t3), Sl.resolve()) : r3;
        }, t2.createAnswer = function(e3, t3) {
          const i3 = arguments.length >= 2 ? arguments[2] : arguments[0], r3 = n2.apply(this, [i3]);
          return t3 ? (r3.then(e3, t3), Sl.resolve()) : r3;
        };
        let a2 = function(e3, t3, i3) {
          const n3 = r2.apply(this, [e3]);
          return i3 ? (n3.then(t3, i3), Sl.resolve()) : n3;
        };
        t2.setLocalDescription = a2, a2 = function(e3, t3, i3) {
          const n3 = o2.apply(this, [e3]);
          return i3 ? (n3.then(t3, i3), Sl.resolve()) : n3;
        }, t2.setRemoteDescription = a2, a2 = function(e3, t3, i3) {
          const n3 = s2.apply(this, [e3]);
          return i3 ? (n3.then(t3, i3), Sl.resolve()) : n3;
        }, t2.addIceCandidate = a2;
      }
      function Yl(e2) {
        const t2 = e2 && e2.navigator;
        if (t2.mediaDevices && t2.mediaDevices.getUserMedia) {
          const e3 = t2.mediaDevices, i2 = e3.getUserMedia.bind(e3);
          t2.mediaDevices.getUserMedia = (e4) => i2(ql(e4));
        }
        !t2.getUserMedia && t2.mediaDevices && t2.mediaDevices.getUserMedia && (t2.getUserMedia = function(e3, i2, n2) {
          t2.mediaDevices.getUserMedia(e3).then(i2, n2);
        }.bind(t2));
      }
      function ql(e2) {
        return e2 && void 0 !== e2.video ? Object.assign({}, e2, { video: cn(e2.video) }) : e2;
      }
      function Jl(e2) {
        if (!e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection;
        e2.RTCPeerConnection = function(e3, i2) {
          if (e3 && e3.iceServers) {
            const t3 = [];
            for (let i3 = 0; i3 < e3.iceServers.length; i3++) {
              let n2 = e3.iceServers[i3];
              !n2.hasOwnProperty("urls") && n2.hasOwnProperty("url") ? (on("RTCIceServer.url", "RTCIceServer.urls"), n2 = JSON.parse(JSON.stringify(n2)), n2.urls = n2.url, delete n2.url, t3.push(n2)) : t3.push(e3.iceServers[i3]);
            }
            e3.iceServers = t3;
          }
          return new t2(e3, i2);
        }, e2.RTCPeerConnection.prototype = t2.prototype, "generateCertificate" in t2 && Object.defineProperty(e2.RTCPeerConnection, "generateCertificate", { get: () => t2.generateCertificate });
      }
      function Xl(e2) {
        "object" == typeof e2 && e2.RTCTrackEvent && "receiver" in e2.RTCTrackEvent.prototype && !("transceiver" in e2.RTCTrackEvent.prototype) && Object.defineProperty(e2.RTCTrackEvent.prototype, "transceiver", { get() {
          return { receiver: this.receiver };
        } });
      }
      function zl(e2) {
        const t2 = e2.RTCPeerConnection.prototype.createOffer;
        e2.RTCPeerConnection.prototype.createOffer = function(e3) {
          if (e3) {
            void 0 !== e3.offerToReceiveAudio && (e3.offerToReceiveAudio = !!e3.offerToReceiveAudio);
            const t3 = this.getTransceivers().find((e4) => "audio" === e4.receiver.track.kind);
            false === e3.offerToReceiveAudio && t3 ? "sendrecv" === t3.direction ? t3.setDirection ? t3.setDirection("sendonly") : t3.direction = "sendonly" : "recvonly" === t3.direction && (t3.setDirection ? t3.setDirection("inactive") : t3.direction = "inactive") : true !== e3.offerToReceiveAudio || t3 || this.addTransceiver("audio", { direction: "recvonly" }), void 0 !== e3.offerToReceiveVideo && (e3.offerToReceiveVideo = !!e3.offerToReceiveVideo);
            const i2 = this.getTransceivers().find((e4) => "video" === e4.receiver.track.kind);
            false === e3.offerToReceiveVideo && i2 ? "sendrecv" === i2.direction ? i2.setDirection ? i2.setDirection("sendonly") : i2.direction = "sendonly" : "recvonly" === i2.direction && (i2.setDirection ? i2.setDirection("inactive") : i2.direction = "inactive") : true !== e3.offerToReceiveVideo || i2 || this.addTransceiver("video", { direction: "recvonly" });
          }
          return t2.apply(this, arguments);
        };
      }
      function Ql(e2) {
        "object" != typeof e2 || e2.AudioContext || (e2.AudioContext = e2.webkitAudioContext);
      }
      var Zl = Object.freeze({ __proto__: null, shimLocalStreamsAPI: Wl, shimRemoteStreamsAPI: Hl, shimCallbacksAPI: Kl, shimGetUserMedia: Yl, shimConstraints: ql, shimRTCIceServerUrls: Jl, shimTrackEventTransceiver: Xl, shimCreateOfferLegacy: zl, shimAudioContext: Ql }), $l = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF", eh = G, th = wo, ih = d("".replace), nh = "[	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]", rh = RegExp("^" + nh + nh + "*"), oh = RegExp(nh + nh + "*$"), sh = function(e2) {
        return function(t2) {
          var i2 = th(eh(t2));
          return 1 & e2 && (i2 = ih(i2, rh, "")), 2 & e2 && (i2 = ih(i2, oh, "")), i2;
        };
      }, ah = { start: sh(1), end: sh(2), trim: sh(3) }, ch = Ms.PROPER, dh = i, uh = $l, lh = ah.trim;
      Ii({ target: "String", proto: true, forced: function(e2) {
        return dh(function() {
          return !!uh[e2]() || "\u200B\x85\u180E" !== "\u200B\x85\u180E"[e2]() || ch && uh[e2].name !== e2;
        });
      }("trim") }, { trim: function() {
        return lh(this);
      } });
      var hh = Hi("String").trim, ph = u, _h = hh, Eh = String.prototype, mh = function(e2) {
        var t2 = e2.trim;
        return "string" == typeof e2 || e2 === Eh || ph(Eh, e2) && t2 === Eh.trim ? _h : t2;
      }, fh = { exports: {} };
      !function(e2) {
        const t2 = { generateIdentifier: function() {
          return Math.random().toString(36).substr(2, 10);
        } };
        t2.localCName = t2.generateIdentifier(), t2.splitLines = function(e3) {
          return mh(e3).call(e3).split("\n").map((e4) => mh(e4).call(e4));
        }, t2.splitSections = function(e3) {
          return e3.split("\nm=").map((e4, t3) => {
            var i2;
            return mh(i2 = t3 > 0 ? "m=" + e4 : e4).call(i2) + "\r\n";
          });
        }, t2.getDescription = function(e3) {
          const i2 = t2.splitSections(e3);
          return i2 && i2[0];
        }, t2.getMediaSections = function(e3) {
          const i2 = t2.splitSections(e3);
          return i2.shift(), i2;
        }, t2.matchPrefix = function(e3, i2) {
          return t2.splitLines(e3).filter((e4) => 0 === e4.indexOf(i2));
        }, t2.parseCandidate = function(e3) {
          let t3;
          t3 = 0 === e3.indexOf("a=candidate:") ? e3.substring(12).split(" ") : e3.substring(10).split(" ");
          const i2 = { foundation: t3[0], component: { 1: "rtp", 2: "rtcp" }[t3[1]] || t3[1], protocol: t3[2].toLowerCase(), priority: parseInt(t3[3], 10), ip: t3[4], address: t3[4], port: parseInt(t3[5], 10), type: t3[7] };
          for (let e4 = 8; e4 < t3.length; e4 += 2)
            switch (t3[e4]) {
              case "raddr":
                i2.relatedAddress = t3[e4 + 1];
                break;
              case "rport":
                i2.relatedPort = parseInt(t3[e4 + 1], 10);
                break;
              case "tcptype":
                i2.tcpType = t3[e4 + 1];
                break;
              case "ufrag":
                i2.ufrag = t3[e4 + 1], i2.usernameFragment = t3[e4 + 1];
                break;
              default:
                void 0 === i2[t3[e4]] && (i2[t3[e4]] = t3[e4 + 1]);
            }
          return i2;
        }, t2.writeCandidate = function(e3) {
          const t3 = [];
          t3.push(e3.foundation);
          const i2 = e3.component;
          "rtp" === i2 ? t3.push(1) : "rtcp" === i2 ? t3.push(2) : t3.push(i2), t3.push(e3.protocol.toUpperCase()), t3.push(e3.priority), t3.push(e3.address || e3.ip), t3.push(e3.port);
          const n2 = e3.type;
          return t3.push("typ"), t3.push(n2), "host" !== n2 && e3.relatedAddress && e3.relatedPort && (t3.push("raddr"), t3.push(e3.relatedAddress), t3.push("rport"), t3.push(e3.relatedPort)), e3.tcpType && "tcp" === e3.protocol.toLowerCase() && (t3.push("tcptype"), t3.push(e3.tcpType)), (e3.usernameFragment || e3.ufrag) && (t3.push("ufrag"), t3.push(e3.usernameFragment || e3.ufrag)), "candidate:" + t3.join(" ");
        }, t2.parseIceOptions = function(e3) {
          return e3.substr(14).split(" ");
        }, t2.parseRtpMap = function(e3) {
          let t3 = e3.substr(9).split(" ");
          const i2 = { payloadType: parseInt(t3.shift(), 10) };
          return t3 = t3[0].split("/"), i2.name = t3[0], i2.clockRate = parseInt(t3[1], 10), i2.channels = 3 === t3.length ? parseInt(t3[2], 10) : 1, i2.numChannels = i2.channels, i2;
        }, t2.writeRtpMap = function(e3) {
          let t3 = e3.payloadType;
          void 0 !== e3.preferredPayloadType && (t3 = e3.preferredPayloadType);
          const i2 = e3.channels || e3.numChannels || 1;
          return "a=rtpmap:" + t3 + " " + e3.name + "/" + e3.clockRate + (1 !== i2 ? "/" + i2 : "") + "\r\n";
        }, t2.parseExtmap = function(e3) {
          const t3 = e3.substr(9).split(" ");
          return { id: parseInt(t3[0], 10), direction: t3[0].indexOf("/") > 0 ? t3[0].split("/")[1] : "sendrecv", uri: t3[1] };
        }, t2.writeExtmap = function(e3) {
          return "a=extmap:" + (e3.id || e3.preferredId) + (e3.direction && "sendrecv" !== e3.direction ? "/" + e3.direction : "") + " " + e3.uri + "\r\n";
        }, t2.parseFmtp = function(e3) {
          const t3 = {};
          let i2;
          const n2 = e3.substr(e3.indexOf(" ") + 1).split(";");
          for (let e4 = 0; e4 < n2.length; e4++) {
            var r2, o2;
            i2 = mh(r2 = n2[e4]).call(r2).split("="), t3[mh(o2 = i2[0]).call(o2)] = i2[1];
          }
          return t3;
        }, t2.writeFmtp = function(e3) {
          let t3 = "", i2 = e3.payloadType;
          if (void 0 !== e3.preferredPayloadType && (i2 = e3.preferredPayloadType), e3.parameters && Object.keys(e3.parameters).length) {
            const n2 = [];
            Object.keys(e3.parameters).forEach((t4) => {
              void 0 !== e3.parameters[t4] ? n2.push(t4 + "=" + e3.parameters[t4]) : n2.push(t4);
            }), t3 += "a=fmtp:" + i2 + " " + n2.join(";") + "\r\n";
          }
          return t3;
        }, t2.parseRtcpFb = function(e3) {
          const t3 = e3.substr(e3.indexOf(" ") + 1).split(" ");
          return { type: t3.shift(), parameter: t3.join(" ") };
        }, t2.writeRtcpFb = function(e3) {
          let t3 = "", i2 = e3.payloadType;
          return void 0 !== e3.preferredPayloadType && (i2 = e3.preferredPayloadType), e3.rtcpFeedback && e3.rtcpFeedback.length && e3.rtcpFeedback.forEach((e4) => {
            t3 += "a=rtcp-fb:" + i2 + " " + e4.type + (e4.parameter && e4.parameter.length ? " " + e4.parameter : "") + "\r\n";
          }), t3;
        }, t2.parseSsrcMedia = function(e3) {
          const t3 = e3.indexOf(" "), i2 = { ssrc: parseInt(e3.substr(7, t3 - 7), 10) }, n2 = e3.indexOf(":", t3);
          return n2 > -1 ? (i2.attribute = e3.substr(t3 + 1, n2 - t3 - 1), i2.value = e3.substr(n2 + 1)) : i2.attribute = e3.substr(t3 + 1), i2;
        }, t2.parseSsrcGroup = function(e3) {
          const t3 = e3.substr(13).split(" ");
          return { semantics: t3.shift(), ssrcs: t3.map((e4) => parseInt(e4, 10)) };
        }, t2.getMid = function(e3) {
          const i2 = t2.matchPrefix(e3, "a=mid:")[0];
          if (i2)
            return i2.substr(6);
        }, t2.parseFingerprint = function(e3) {
          const t3 = e3.substr(14).split(" ");
          return { algorithm: t3[0].toLowerCase(), value: t3[1].toUpperCase() };
        }, t2.getDtlsParameters = function(e3, i2) {
          return { role: "auto", fingerprints: t2.matchPrefix(e3 + i2, "a=fingerprint:").map(t2.parseFingerprint) };
        }, t2.writeDtlsParameters = function(e3, t3) {
          let i2 = "a=setup:" + t3 + "\r\n";
          return e3.fingerprints.forEach((e4) => {
            i2 += "a=fingerprint:" + e4.algorithm + " " + e4.value + "\r\n";
          }), i2;
        }, t2.parseCryptoLine = function(e3) {
          const t3 = e3.substr(9).split(" ");
          return { tag: parseInt(t3[0], 10), cryptoSuite: t3[1], keyParams: t3[2], sessionParams: t3.slice(3) };
        }, t2.writeCryptoLine = function(e3) {
          return "a=crypto:" + e3.tag + " " + e3.cryptoSuite + " " + ("object" == typeof e3.keyParams ? t2.writeCryptoKeyParams(e3.keyParams) : e3.keyParams) + (e3.sessionParams ? " " + e3.sessionParams.join(" ") : "") + "\r\n";
        }, t2.parseCryptoKeyParams = function(e3) {
          if (0 !== e3.indexOf("inline:"))
            return null;
          const t3 = e3.substr(7).split("|");
          return { keyMethod: "inline", keySalt: t3[0], lifeTime: t3[1], mkiValue: t3[2] ? t3[2].split(":")[0] : void 0, mkiLength: t3[2] ? t3[2].split(":")[1] : void 0 };
        }, t2.writeCryptoKeyParams = function(e3) {
          return e3.keyMethod + ":" + e3.keySalt + (e3.lifeTime ? "|" + e3.lifeTime : "") + (e3.mkiValue && e3.mkiLength ? "|" + e3.mkiValue + ":" + e3.mkiLength : "");
        }, t2.getCryptoParameters = function(e3, i2) {
          return t2.matchPrefix(e3 + i2, "a=crypto:").map(t2.parseCryptoLine);
        }, t2.getIceParameters = function(e3, i2) {
          const n2 = t2.matchPrefix(e3 + i2, "a=ice-ufrag:")[0], r2 = t2.matchPrefix(e3 + i2, "a=ice-pwd:")[0];
          return n2 && r2 ? { usernameFragment: n2.substr(12), password: r2.substr(10) } : null;
        }, t2.writeIceParameters = function(e3) {
          let t3 = "a=ice-ufrag:" + e3.usernameFragment + "\r\na=ice-pwd:" + e3.password + "\r\n";
          return e3.iceLite && (t3 += "a=ice-lite\r\n"), t3;
        }, t2.parseRtpParameters = function(e3) {
          const i2 = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, n2 = t2.splitLines(e3)[0].split(" ");
          for (let r2 = 3; r2 < n2.length; r2++) {
            const o2 = n2[r2], s2 = t2.matchPrefix(e3, "a=rtpmap:" + o2 + " ")[0];
            if (s2) {
              const n3 = t2.parseRtpMap(s2), r3 = t2.matchPrefix(e3, "a=fmtp:" + o2 + " ");
              switch (n3.parameters = r3.length ? t2.parseFmtp(r3[0]) : {}, n3.rtcpFeedback = t2.matchPrefix(e3, "a=rtcp-fb:" + o2 + " ").map(t2.parseRtcpFb), i2.codecs.push(n3), n3.name.toUpperCase()) {
                case "RED":
                case "ULPFEC":
                  i2.fecMechanisms.push(n3.name.toUpperCase());
              }
            }
          }
          return t2.matchPrefix(e3, "a=extmap:").forEach((e4) => {
            i2.headerExtensions.push(t2.parseExtmap(e4));
          }), i2;
        }, t2.writeRtpDescription = function(e3, i2) {
          let n2 = "";
          n2 += "m=" + e3 + " ", n2 += i2.codecs.length > 0 ? "9" : "0", n2 += " UDP/TLS/RTP/SAVPF ", n2 += i2.codecs.map((e4) => void 0 !== e4.preferredPayloadType ? e4.preferredPayloadType : e4.payloadType).join(" ") + "\r\n", n2 += "c=IN IP4 0.0.0.0\r\n", n2 += "a=rtcp:9 IN IP4 0.0.0.0\r\n", i2.codecs.forEach((e4) => {
            n2 += t2.writeRtpMap(e4), n2 += t2.writeFmtp(e4), n2 += t2.writeRtcpFb(e4);
          });
          let r2 = 0;
          return i2.codecs.forEach((e4) => {
            e4.maxptime > r2 && (r2 = e4.maxptime);
          }), r2 > 0 && (n2 += "a=maxptime:" + r2 + "\r\n"), i2.headerExtensions && i2.headerExtensions.forEach((e4) => {
            n2 += t2.writeExtmap(e4);
          }), n2;
        }, t2.parseRtpEncodingParameters = function(e3) {
          const i2 = [], n2 = t2.parseRtpParameters(e3), r2 = -1 !== n2.fecMechanisms.indexOf("RED"), o2 = -1 !== n2.fecMechanisms.indexOf("ULPFEC"), s2 = t2.matchPrefix(e3, "a=ssrc:").map((e4) => t2.parseSsrcMedia(e4)).filter((e4) => "cname" === e4.attribute), a2 = s2.length > 0 && s2[0].ssrc;
          let c2;
          const d2 = t2.matchPrefix(e3, "a=ssrc-group:FID").map((e4) => e4.substr(17).split(" ").map((e5) => parseInt(e5, 10)));
          d2.length > 0 && d2[0].length > 1 && d2[0][0] === a2 && (c2 = d2[0][1]), n2.codecs.forEach((e4) => {
            if ("RTX" === e4.name.toUpperCase() && e4.parameters.apt) {
              let t3 = { ssrc: a2, codecPayloadType: parseInt(e4.parameters.apt, 10) };
              a2 && c2 && (t3.rtx = { ssrc: c2 }), i2.push(t3), r2 && (t3 = JSON.parse(JSON.stringify(t3)), t3.fec = { ssrc: a2, mechanism: o2 ? "red+ulpfec" : "red" }, i2.push(t3));
            }
          }), 0 === i2.length && a2 && i2.push({ ssrc: a2 });
          let u2 = t2.matchPrefix(e3, "b=");
          return u2.length && (u2 = 0 === u2[0].indexOf("b=TIAS:") ? parseInt(u2[0].substr(7), 10) : 0 === u2[0].indexOf("b=AS:") ? 1e3 * parseInt(u2[0].substr(5), 10) * 0.95 - 16e3 : void 0, i2.forEach((e4) => {
            e4.maxBitrate = u2;
          })), i2;
        }, t2.parseRtcpParameters = function(e3) {
          const i2 = {}, n2 = t2.matchPrefix(e3, "a=ssrc:").map((e4) => t2.parseSsrcMedia(e4)).filter((e4) => "cname" === e4.attribute)[0];
          n2 && (i2.cname = n2.value, i2.ssrc = n2.ssrc);
          const r2 = t2.matchPrefix(e3, "a=rtcp-rsize");
          i2.reducedSize = r2.length > 0, i2.compound = 0 === r2.length;
          const o2 = t2.matchPrefix(e3, "a=rtcp-mux");
          return i2.mux = o2.length > 0, i2;
        }, t2.writeRtcpParameters = function(e3) {
          let t3 = "";
          return e3.reducedSize && (t3 += "a=rtcp-rsize\r\n"), e3.mux && (t3 += "a=rtcp-mux\r\n"), void 0 !== e3.ssrc && e3.cname && (t3 += "a=ssrc:" + e3.ssrc + " cname:" + e3.cname + "\r\n"), t3;
        }, t2.parseMsid = function(e3) {
          let i2;
          const n2 = t2.matchPrefix(e3, "a=msid:");
          if (1 === n2.length)
            return i2 = n2[0].substr(7).split(" "), { stream: i2[0], track: i2[1] };
          const r2 = t2.matchPrefix(e3, "a=ssrc:").map((e4) => t2.parseSsrcMedia(e4)).filter((e4) => "msid" === e4.attribute);
          return r2.length > 0 ? (i2 = r2[0].value.split(" "), { stream: i2[0], track: i2[1] }) : void 0;
        }, t2.parseSctpDescription = function(e3) {
          const i2 = t2.parseMLine(e3), n2 = t2.matchPrefix(e3, "a=max-message-size:");
          let r2;
          n2.length > 0 && (r2 = parseInt(n2[0].substr(19), 10)), isNaN(r2) && (r2 = 65536);
          const o2 = t2.matchPrefix(e3, "a=sctp-port:");
          if (o2.length > 0)
            return { port: parseInt(o2[0].substr(12), 10), protocol: i2.fmt, maxMessageSize: r2 };
          const s2 = t2.matchPrefix(e3, "a=sctpmap:");
          if (s2.length > 0) {
            const e4 = s2[0].substr(10).split(" ");
            return { port: parseInt(e4[0], 10), protocol: e4[1], maxMessageSize: r2 };
          }
        }, t2.writeSctpDescription = function(e3, t3) {
          let i2 = [];
          return i2 = "DTLS/SCTP" !== e3.protocol ? ["m=" + e3.kind + " 9 " + e3.protocol + " " + t3.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t3.port + "\r\n"] : ["m=" + e3.kind + " 9 " + e3.protocol + " " + t3.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t3.port + " " + t3.protocol + " 65535\r\n"], void 0 !== t3.maxMessageSize && i2.push("a=max-message-size:" + t3.maxMessageSize + "\r\n"), i2.join("");
        }, t2.generateSessionId = function() {
          return Math.random().toString().substr(2, 21);
        }, t2.writeSessionBoilerplate = function(e3, i2, n2) {
          let r2;
          const o2 = void 0 !== i2 ? i2 : 2;
          r2 = e3 || t2.generateSessionId();
          return "v=0\r\no=" + (n2 || "thisisadapterortc") + " " + r2 + " " + o2 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
        }, t2.getDirection = function(e3, i2) {
          const n2 = t2.splitLines(e3);
          for (let e4 = 0; e4 < n2.length; e4++)
            switch (n2[e4]) {
              case "a=sendrecv":
              case "a=sendonly":
              case "a=recvonly":
              case "a=inactive":
                return n2[e4].substr(2);
            }
          return i2 ? t2.getDirection(i2) : "sendrecv";
        }, t2.getKind = function(e3) {
          return t2.splitLines(e3)[0].split(" ")[0].substr(2);
        }, t2.isRejected = function(e3) {
          return "0" === e3.split(" ", 2)[1];
        }, t2.parseMLine = function(e3) {
          const i2 = t2.splitLines(e3)[0].substr(2).split(" ");
          return { kind: i2[0], port: parseInt(i2[1], 10), protocol: i2[2], fmt: i2.slice(3).join(" ") };
        }, t2.parseOLine = function(e3) {
          const i2 = t2.matchPrefix(e3, "o=")[0].substr(2).split(" ");
          return { username: i2[0], sessionId: i2[1], sessionVersion: parseInt(i2[2], 10), netType: i2[3], addressType: i2[4], address: i2[5] };
        }, t2.isValidSDP = function(e3) {
          if ("string" != typeof e3 || 0 === e3.length)
            return false;
          const i2 = t2.splitLines(e3);
          for (let e4 = 0; e4 < i2.length; e4++)
            if (i2[e4].length < 2 || "=" !== i2[e4].charAt(1))
              return false;
          return true;
        }, e2.exports = t2;
      }(fh);
      var Sh = fh.exports, Th = Object.freeze(e({ __proto__: null, default: Sh }, [fh.exports]));
      function gh(e2) {
        if (!e2.RTCIceCandidate || e2.RTCIceCandidate && "foundation" in e2.RTCIceCandidate.prototype)
          return;
        const t2 = e2.RTCIceCandidate;
        e2.RTCIceCandidate = function(e3) {
          if ("object" == typeof e3 && e3.candidate && 0 === e3.candidate.indexOf("a=") && ((e3 = JSON.parse(JSON.stringify(e3))).candidate = e3.candidate.substr(2)), e3.candidate && e3.candidate.length) {
            const i2 = new t2(e3), n2 = Sh.parseCandidate(e3.candidate), r2 = Object.assign(i2, n2);
            return r2.toJSON = function() {
              return { candidate: r2.candidate, sdpMid: r2.sdpMid, sdpMLineIndex: r2.sdpMLineIndex, usernameFragment: r2.usernameFragment };
            }, r2;
          }
          return new t2(e3);
        }, e2.RTCIceCandidate.prototype = t2.prototype, en(e2, "icecandidate", (t3) => (t3.candidate && Object.defineProperty(t3, "candidate", { value: new e2.RTCIceCandidate(t3.candidate), writable: "false" }), t3));
      }
      function Rh(e2) {
        !e2.RTCIceCandidate || e2.RTCIceCandidate && "relayProtocol" in e2.RTCIceCandidate.prototype || en(e2, "icecandidate", (e3) => {
          if (e3.candidate) {
            const t2 = Sh.parseCandidate(e3.candidate.candidate);
            "relay" === t2.type && (e3.candidate.relayProtocol = { 0: "tls", 1: "tcp", 2: "udp" }[t2.priority >> 24]);
          }
          return e3;
        });
      }
      function Ih(e2, t2) {
        if (!e2.RTCPeerConnection)
          return;
        "sctp" in e2.RTCPeerConnection.prototype || Object.defineProperty(e2.RTCPeerConnection.prototype, "sctp", { get() {
          return void 0 === this._sctp ? null : this._sctp;
        } });
        const i2 = function(e3) {
          if (!e3 || !e3.sdp)
            return false;
          const t3 = Sh.splitSections(e3.sdp);
          return t3.shift(), t3.some((e4) => {
            const t4 = Sh.parseMLine(e4);
            return t4 && "application" === t4.kind && -1 !== t4.protocol.indexOf("SCTP");
          });
        }, n2 = function(e3) {
          const t3 = e3.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
          if (null === t3 || t3.length < 2)
            return -1;
          const i3 = parseInt(t3[1], 10);
          return i3 != i3 ? -1 : i3;
        }, r2 = function(e3) {
          let i3 = 65536;
          return "firefox" === t2.browser && (i3 = t2.version < 57 ? -1 === e3 ? 16384 : 2147483637 : t2.version < 60 ? 57 === t2.version ? 65535 : 65536 : 2147483637), i3;
        }, o2 = function(e3, i3) {
          let n3 = 65536;
          "firefox" === t2.browser && 57 === t2.version && (n3 = 65535);
          const r3 = Sh.matchPrefix(e3.sdp, "a=max-message-size:");
          return r3.length > 0 ? n3 = parseInt(r3[0].substr(19), 10) : "firefox" === t2.browser && -1 !== i3 && (n3 = 2147483637), n3;
        }, s2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
        e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
          if (this._sctp = null, "chrome" === t2.browser && t2.version >= 76) {
            const { sdpSemantics: e3 } = this.getConfiguration();
            "plan-b" === e3 && Object.defineProperty(this, "sctp", { get() {
              return void 0 === this._sctp ? null : this._sctp;
            }, enumerable: true, configurable: true });
          }
          if (i2(arguments[0])) {
            const e3 = n2(arguments[0]), t3 = r2(e3), i3 = o2(arguments[0], e3);
            let s3;
            s3 = 0 === t3 && 0 === i3 ? Number.POSITIVE_INFINITY : 0 === t3 || 0 === i3 ? Math.max(t3, i3) : Math.min(t3, i3);
            const a2 = {};
            Object.defineProperty(a2, "maxMessageSize", { get: () => s3 }), this._sctp = a2;
          }
          return s2.apply(this, arguments);
        };
      }
      function Ch(e2) {
        if (!e2.RTCPeerConnection || !("createDataChannel" in e2.RTCPeerConnection.prototype))
          return;
        function t2(e3, t3) {
          const i3 = e3.send;
          e3.send = function() {
            const n2 = arguments[0], r2 = n2.length || n2.size || n2.byteLength;
            if ("open" === e3.readyState && t3.sctp && r2 > t3.sctp.maxMessageSize)
              throw new TypeError("Message too large (can send a maximum of " + t3.sctp.maxMessageSize + " bytes)");
            return i3.apply(e3, arguments);
          };
        }
        const i2 = e2.RTCPeerConnection.prototype.createDataChannel;
        e2.RTCPeerConnection.prototype.createDataChannel = function() {
          const e3 = i2.apply(this, arguments);
          return t2(e3, this), e3;
        }, en(e2, "datachannel", (e3) => (t2(e3.channel, e3.target), e3));
      }
      function vh(e2) {
        if (!e2.RTCPeerConnection || "connectionState" in e2.RTCPeerConnection.prototype)
          return;
        const t2 = e2.RTCPeerConnection.prototype;
        Object.defineProperty(t2, "connectionState", { get() {
          return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState;
        }, enumerable: true, configurable: true }), Object.defineProperty(t2, "onconnectionstatechange", { get() {
          return this._onconnectionstatechange || null;
        }, set(e3) {
          this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e3 && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e3);
        }, enumerable: true, configurable: true }), ["setLocalDescription", "setRemoteDescription"].forEach((e3) => {
          const i2 = t2[e3];
          t2[e3] = function() {
            return this._connectionstatechangepoly || (this._connectionstatechangepoly = (e4) => {
              const t3 = e4.target;
              if (t3._lastConnectionState !== t3.connectionState) {
                t3._lastConnectionState = t3.connectionState;
                const i3 = new Event("connectionstatechange", e4);
                t3.dispatchEvent(i3);
              }
              return e4;
            }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), i2.apply(this, arguments);
          };
        });
      }
      function yh(e2, t2) {
        if (!e2.RTCPeerConnection)
          return;
        if ("chrome" === t2.browser && t2.version >= 71)
          return;
        if ("safari" === t2.browser && t2.version >= 605)
          return;
        const i2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
        e2.RTCPeerConnection.prototype.setRemoteDescription = function(t3) {
          if (t3 && t3.sdp && -1 !== t3.sdp.indexOf("\na=extmap-allow-mixed")) {
            const i3 = t3.sdp.split("\n").filter((e3) => "a=extmap-allow-mixed" !== mh(e3).call(e3)).join("\n");
            e2.RTCSessionDescription && t3 instanceof e2.RTCSessionDescription ? arguments[0] = new e2.RTCSessionDescription({ type: t3.type, sdp: i3 }) : t3.sdp = i3;
          }
          return i2.apply(this, arguments);
        };
      }
      function Ah(e2, t2) {
        if (!e2.RTCPeerConnection || !e2.RTCPeerConnection.prototype)
          return;
        const i2 = e2.RTCPeerConnection.prototype.addIceCandidate;
        i2 && 0 !== i2.length && (e2.RTCPeerConnection.prototype.addIceCandidate = function() {
          return arguments[0] ? ("chrome" === t2.browser && t2.version < 78 || "firefox" === t2.browser && t2.version < 68 || "safari" === t2.browser) && arguments[0] && "" === arguments[0].candidate ? Sl.resolve() : i2.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Sl.resolve());
        });
      }
      function Oh(e2, t2) {
        if (!e2.RTCPeerConnection || !e2.RTCPeerConnection.prototype)
          return;
        const i2 = e2.RTCPeerConnection.prototype.setLocalDescription;
        i2 && 0 !== i2.length && (e2.RTCPeerConnection.prototype.setLocalDescription = function() {
          let e3 = arguments[0] || {};
          if ("object" != typeof e3 || e3.type && e3.sdp)
            return i2.apply(this, arguments);
          if (e3 = { type: e3.type, sdp: e3.sdp }, !e3.type)
            switch (this.signalingState) {
              case "stable":
              case "have-local-offer":
              case "have-remote-pranswer":
                e3.type = "offer";
                break;
              default:
                e3.type = "answer";
            }
          if (e3.sdp || "offer" !== e3.type && "answer" !== e3.type)
            return i2.apply(this, [e3]);
          const t3 = "offer" === e3.type ? this.createOffer : this.createAnswer;
          return t3.apply(this).then((e4) => i2.apply(this, [e4]));
        });
      }
      var Nh = Object.freeze({ __proto__: null, shimRTCIceCandidate: gh, shimRTCIceCandidateRelayProtocol: Rh, shimMaxMessageSize: Ih, shimSendThrowTypeError: Ch, shimConnectionState: vh, removeExtmapAllowMixed: yh, shimAddIceCandidateNullOrEmpty: Ah, shimParameterlessSetLocalDescription: Oh });
      let bh, wh;
      !function() {
        let { window: e2 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { shimChrome: true, shimFirefox: true, shimSafari: true };
        const i2 = rn, n2 = sn(e2), r2 = { browserDetails: n2, commonShim: Nh, extractVersion: $i, disableLog: tn, disableWarnings: nn, sdp: Th };
        switch (n2.browser) {
          case "chrome":
            if (!wl || !Nl || !t2.shimChrome)
              return i2("Chrome shim is not included in this adapter release."), r2;
            if (null === n2.version)
              return i2("Chrome shim can not determine version, not shimming."), r2;
            i2("adapter.js shimming chrome."), r2.browserShim = wl, Ah(e2, n2), Oh(e2), gl(e2, n2), Rl(e2), Nl(e2, n2), Il(e2), Ol(e2, n2), Cl(e2), vl(e2), yl(e2), bl(e2, n2), gh(e2), Rh(e2), vh(e2), Ih(e2, n2), Ch(e2), yh(e2, n2);
            break;
          case "firefox":
            if (!Gl || !Ll || !t2.shimFirefox)
              return i2("Firefox shim is not included in this adapter release."), r2;
            i2("adapter.js shimming firefox."), r2.browserShim = Gl, Ah(e2, n2), Oh(e2), Dl(e2, n2), Ll(e2, n2), Pl(e2), Ul(e2), kl(e2), Ml(e2), xl(e2), Vl(e2), jl(e2), Fl(e2), Bl(e2), gh(e2), vh(e2), Ih(e2, n2), Ch(e2);
            break;
          case "safari":
            if (!Zl || !t2.shimSafari)
              return i2("Safari shim is not included in this adapter release."), r2;
            i2("adapter.js shimming safari."), r2.browserShim = Zl, Ah(e2, n2), Oh(e2), Jl(e2), zl(e2), Kl(e2), Wl(e2), Hl(e2), Xl(e2), Yl(e2), Ql(e2), gh(e2), Rh(e2), Ih(e2, n2), Ch(e2), yh(e2, n2);
            break;
          default:
            i2("Unsupported browser!");
        }
      }({ window: "undefined" == typeof window ? void 0 : window }), function(e2) {
        e2.WIN_10 = "Windows 10", e2.WIN_81 = "Windows 8.1", e2.WIN_8 = "Windows 8", e2.WIN_7 = "Windows 7", e2.WIN_VISTA = "Windows Vista", e2.WIN_SERVER_2003 = "Windows Server 2003", e2.WIN_XP = "Windows XP", e2.WIN_2000 = "Windows 2000", e2.ANDROID = "Android", e2.HARMONY_OS = "HarmonyOS", e2.OPEN_BSD = "Open BSD", e2.SUN_OS = "Sun OS", e2.LINUX = "Linux", e2.IOS = "iOS", e2.MAC_OS = "Mac OS", e2.QNX = "QNX", e2.UNIX = "UNIX", e2.BEOS = "BeOS", e2.OS_2 = "OS/2", e2.SEARCH_BOT = "Search Bot";
      }(bh || (bh = {})), function(e2) {
        e2.CHROME = "Chrome", e2.SAFARI = "Safari", e2.EDGE = "Edge", e2.FIREFOX = "Firefox", e2.OPERA = "OPR", e2.QQ = "QQBrowser", e2.WECHAT = "MicroMessenger";
      }(wh || (wh = {}));
      var Dh = { exports: {} };
      !function(e2, i2) {
        !function(t2, n2) {
          var r2 = "function", o2 = "undefined", s2 = "object", a2 = "string", c2 = "major", d2 = "model", u2 = "name", l2 = "type", h2 = "vendor", p2 = "version", _2 = "architecture", E2 = "console", m2 = "mobile", f2 = "tablet", S2 = "smarttv", T2 = "wearable", g2 = "embedded", R2 = "Amazon", I2 = "Apple", C2 = "ASUS", v2 = "BlackBerry", y2 = "Firefox", A2 = "Google", O2 = "Huawei", N2 = "LG", b2 = "Microsoft", w2 = "Motorola", D2 = "Opera", P2 = "Samsung", L2 = "Sharp", k2 = "Sony", M2 = "Xiaomi", U2 = "Zebra", x2 = "Facebook", V2 = "Chromium OS", j2 = "Mac OS", F2 = function(e3) {
            for (var t3 = {}, i3 = 0; i3 < e3.length; i3++)
              t3[e3[i3].toUpperCase()] = e3[i3];
            return t3;
          }, B2 = function(e3, t3) {
            return typeof e3 === a2 && -1 !== G2(t3).indexOf(G2(e3));
          }, G2 = function(e3) {
            return e3.toLowerCase();
          }, W2 = function(e3, t3) {
            if (typeof e3 === a2)
              return e3 = e3.replace(/^\s\s*/, ""), typeof t3 === o2 ? e3 : e3.substring(0, 350);
          }, H2 = function(e3, t3) {
            for (var i3, o3, a3, c3, d3, u3, l3 = 0; l3 < t3.length && !d3; ) {
              var h3 = t3[l3], p3 = t3[l3 + 1];
              for (i3 = o3 = 0; i3 < h3.length && !d3 && h3[i3]; )
                if (d3 = h3[i3++].exec(e3))
                  for (a3 = 0; a3 < p3.length; a3++)
                    u3 = d3[++o3], typeof (c3 = p3[a3]) === s2 && c3.length > 0 ? 2 === c3.length ? typeof c3[1] == r2 ? this[c3[0]] = c3[1].call(this, u3) : this[c3[0]] = c3[1] : 3 === c3.length ? typeof c3[1] !== r2 || c3[1].exec && c3[1].test ? this[c3[0]] = u3 ? u3.replace(c3[1], c3[2]) : n2 : this[c3[0]] = u3 ? c3[1].call(this, u3, c3[2]) : n2 : 4 === c3.length && (this[c3[0]] = u3 ? c3[3].call(this, u3.replace(c3[1], c3[2])) : n2) : this[c3] = u3 || n2;
              l3 += 2;
            }
          }, K2 = function(e3, t3) {
            for (var i3 in t3)
              if (typeof t3[i3] === s2 && t3[i3].length > 0) {
                for (var r3 = 0; r3 < t3[i3].length; r3++)
                  if (B2(t3[i3][r3], e3))
                    return "?" === i3 ? n2 : i3;
              } else if (B2(t3[i3], e3))
                return "?" === i3 ? n2 : i3;
            return e3;
          }, Y2 = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }, q2 = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [p2, [u2, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [p2, [u2, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [u2, p2], [/opios[\/ ]+([\w\.]+)/i], [p2, [u2, "Opera Mini"]], [/\bopr\/([\w\.]+)/i], [p2, [u2, D2]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(weibo)__([\d\.]+)/i], [u2, p2], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [p2, [u2, "UCBrowser"]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i], [p2, [u2, "WeChat(Win) Desktop"]], [/micromessenger\/([\w\.]+)/i], [p2, [u2, "WeChat"]], [/konqueror\/([\w\.]+)/i], [p2, [u2, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [p2, [u2, "IE"]], [/yabrowser\/([\w\.]+)/i], [p2, [u2, "Yandex"]], [/(avast|avg)\/([\w\.]+)/i], [[u2, /(.+)/, "$1 Secure Browser"], p2], [/\bfocus\/([\w\.]+)/i], [p2, [u2, "Firefox Focus"]], [/\bopt\/([\w\.]+)/i], [p2, [u2, "Opera Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [p2, [u2, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [p2, [u2, "Dolphin"]], [/coast\/([\w\.]+)/i], [p2, [u2, "Opera Coast"]], [/miuibrowser\/([\w\.]+)/i], [p2, [u2, "MIUI Browser"]], [/fxios\/([-\w\.]+)/i], [p2, [u2, y2]], [/\bqihu|(qi?ho?o?|360)browser/i], [[u2, "360 Browser"]], [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i], [[u2, /(.+)/, "$1 Browser"], p2], [/(comodo_dragon)\/([\w\.]+)/i], [[u2, /_/g, " "], p2], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i], [u2, p2], [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i, /\[(linkedin)app\]/i], [u2], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[u2, x2], p2], [/(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram)[\/ ]([-\w\.]+)/i], [u2, p2], [/\bgsa\/([\w\.]+) .*safari\//i], [p2, [u2, "GSA"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [p2, [u2, "Chrome Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[u2, "Chrome WebView"], p2], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [p2, [u2, "Android Browser"]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [u2, p2], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [p2, [u2, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [p2, u2], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [u2, [p2, K2, { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }]], [/(webkit|khtml)\/([\w\.]+)/i], [u2, p2], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[u2, "Netscape"], p2], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [p2, [u2, "Firefox Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i], [u2, p2], [/(cobalt)\/([\w\.]+)/i], [u2, [p2, /master.|lts./, ""]]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[_2, "amd64"]], [/(ia32(?=;))/i], [[_2, G2]], [/((?:i[346]|x)86)[;\)]/i], [[_2, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[_2, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[_2, "armhf"]], [/windows (ce|mobile); ppc;/i], [[_2, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[_2, /ower/, "", G2]], [/(sun4\w)[;\)]/i], [[_2, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[_2, G2]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [d2, [h2, P2], [l2, f2]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [d2, [h2, P2], [l2, m2]], [/\((ip(?:hone|od)[\w ]*);/i], [d2, [h2, I2], [l2, m2]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [d2, [h2, I2], [l2, f2]], [/(macintosh);/i], [d2, [h2, I2]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [d2, [h2, L2], [l2, m2]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [d2, [h2, O2], [l2, f2]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [d2, [h2, O2], [l2, m2]], [/\b(poco[\w ]+)(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[d2, /_/g, " "], [h2, M2], [l2, m2]], [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[d2, /_/g, " "], [h2, M2], [l2, f2]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [d2, [h2, "OPPO"], [l2, m2]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [d2, [h2, "Vivo"], [l2, m2]], [/\b(rmx[12]\d{3})(?: bui|;|\))/i], [d2, [h2, "Realme"], [l2, m2]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [d2, [h2, w2], [l2, m2]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [d2, [h2, w2], [l2, f2]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [d2, [h2, N2], [l2, f2]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [d2, [h2, N2], [l2, m2]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [d2, [h2, "Lenovo"], [l2, f2]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[d2, /_/g, " "], [h2, "Nokia"], [l2, m2]], [/(pixel c)\b/i], [d2, [h2, A2], [l2, f2]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [d2, [h2, A2], [l2, m2]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [d2, [h2, k2], [l2, m2]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[d2, "Xperia Tablet"], [h2, k2], [l2, f2]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [d2, [h2, "OnePlus"], [l2, m2]], [/(alexa)webm/i, /(kf[a-z]{2}wi)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [d2, [h2, R2], [l2, f2]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[d2, /(.+)/g, "Fire Phone $1"], [h2, R2], [l2, m2]], [/(playbook);[-\w\),; ]+(rim)/i], [d2, h2, [l2, f2]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [d2, [h2, v2], [l2, m2]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [d2, [h2, C2], [l2, f2]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [d2, [h2, C2], [l2, m2]], [/(nexus 9)/i], [d2, [h2, "HTC"], [l2, f2]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [h2, [d2, /_/g, " "], [l2, m2]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [d2, [h2, "Acer"], [l2, f2]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [d2, [h2, "Meizu"], [l2, m2]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [h2, d2, [l2, m2]], [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [h2, d2, [l2, f2]], [/(surface duo)/i], [d2, [h2, b2], [l2, f2]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [d2, [h2, "Fairphone"], [l2, m2]], [/(u304aa)/i], [d2, [h2, "AT&T"], [l2, m2]], [/\bsie-(\w*)/i], [d2, [h2, "Siemens"], [l2, m2]], [/\b(rct\w+) b/i], [d2, [h2, "RCA"], [l2, f2]], [/\b(venue[\d ]{2,7}) b/i], [d2, [h2, "Dell"], [l2, f2]], [/\b(q(?:mv|ta)\w+) b/i], [d2, [h2, "Verizon"], [l2, f2]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [d2, [h2, "Barnes & Noble"], [l2, f2]], [/\b(tm\d{3}\w+) b/i], [d2, [h2, "NuVision"], [l2, f2]], [/\b(k88) b/i], [d2, [h2, "ZTE"], [l2, f2]], [/\b(nx\d{3}j) b/i], [d2, [h2, "ZTE"], [l2, m2]], [/\b(gen\d{3}) b.+49h/i], [d2, [h2, "Swiss"], [l2, m2]], [/\b(zur\d{3}) b/i], [d2, [h2, "Swiss"], [l2, f2]], [/\b((zeki)?tb.*\b) b/i], [d2, [h2, "Zeki"], [l2, f2]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[h2, "Dragon Touch"], d2, [l2, f2]], [/\b(ns-?\w{0,9}) b/i], [d2, [h2, "Insignia"], [l2, f2]], [/\b((nxa|next)-?\w{0,9}) b/i], [d2, [h2, "NextBook"], [l2, f2]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[h2, "Voice"], d2, [l2, m2]], [/\b(lvtel\-)?(v1[12]) b/i], [[h2, "LvTel"], d2, [l2, m2]], [/\b(ph-1) /i], [d2, [h2, "Essential"], [l2, m2]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [d2, [h2, "Envizen"], [l2, f2]], [/\b(trio[-\w\. ]+) b/i], [d2, [h2, "MachSpeed"], [l2, f2]], [/\btu_(1491) b/i], [d2, [h2, "Rotor"], [l2, f2]], [/(shield[\w ]+) b/i], [d2, [h2, "Nvidia"], [l2, f2]], [/(sprint) (\w+)/i], [h2, d2, [l2, m2]], [/(kin\.[onetw]{3})/i], [[d2, /\./g, " "], [h2, b2], [l2, m2]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [d2, [h2, U2], [l2, f2]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [d2, [h2, U2], [l2, m2]], [/smart-tv.+(samsung)/i], [h2, [l2, S2]], [/hbbtv.+maple;(\d+)/i], [[d2, /^/, "SmartTV"], [h2, P2], [l2, S2]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[h2, N2], [l2, S2]], [/(apple) ?tv/i], [h2, [d2, "Apple TV"], [l2, S2]], [/crkey/i], [[d2, "Chromecast"], [h2, A2], [l2, S2]], [/droid.+aft(\w)( bui|\))/i], [d2, [h2, R2], [l2, S2]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [d2, [h2, L2], [l2, S2]], [/(bravia[\w ]+)( bui|\))/i], [d2, [h2, k2], [l2, S2]], [/(mitv-\w{5}) bui/i], [d2, [h2, M2], [l2, S2]], [/Hbbtv.*(technisat) (.*);/i], [h2, d2, [l2, S2]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[h2, W2], [d2, W2], [l2, S2]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[l2, S2]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [h2, d2, [l2, E2]], [/droid.+; (shield) bui/i], [d2, [h2, "Nvidia"], [l2, E2]], [/(playstation [345portablevi]+)/i], [d2, [h2, k2], [l2, E2]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [d2, [h2, b2], [l2, E2]], [/((pebble))app/i], [h2, d2, [l2, T2]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [d2, [h2, I2], [l2, T2]], [/droid.+; (glass) \d/i], [d2, [h2, A2], [l2, T2]], [/droid.+; (wt63?0{2,3})\)/i], [d2, [h2, U2], [l2, T2]], [/(quest( 2| pro)?)/i], [d2, [h2, x2], [l2, T2]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [h2, [l2, g2]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i], [d2, [l2, m2]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [d2, [l2, f2]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[l2, f2]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[l2, m2]], [/(android[-\w\. ]{0,9});.+buil/i], [d2, [h2, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [p2, [u2, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [p2, [u2, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i], [u2, p2], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [p2, u2]], os: [[/microsoft (windows) (vista|xp)/i], [u2, p2], [/(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i], [u2, [p2, K2, Y2]], [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[u2, "Windows"], [p2, K2, Y2]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /cfnetwork\/.+darwin/i], [[p2, /_/g, "."], [u2, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[u2, j2], [p2, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [p2, u2], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [u2, p2], [/\(bb(10);/i], [p2, [u2, v2]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [p2, [u2, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [p2, [u2, "Firefox OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [p2, [u2, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [p2, [u2, "watchOS"]], [/crkey\/([\d\.]+)/i], [p2, [u2, "Chromecast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[u2, V2], p2], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [u2, p2], [/(sunos) ?([\w\.\d]*)/i], [[u2, "Solaris"], p2], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i, /(unix) ?([\w\.]*)/i], [u2, p2]] }, J2 = function(e3, i3) {
            if (typeof e3 === s2 && (i3 = e3, e3 = n2), !(this instanceof J2))
              return new J2(e3, i3).getResult();
            var c3 = typeof t2 !== o2 && t2.navigator ? t2.navigator : n2, d3 = e3 || (c3 && c3.userAgent ? c3.userAgent : ""), u3 = c3 && c3.userAgentData ? c3.userAgentData : n2, l3 = i3 ? function(e4, t3) {
              var i4 = {};
              for (var n3 in e4)
                t3[n3] && t3[n3].length % 2 == 0 ? i4[n3] = t3[n3].concat(e4[n3]) : i4[n3] = e4[n3];
              return i4;
            }(q2, i3) : q2;
            return this.getBrowser = function() {
              var e4 = {};
              return e4.name = n2, e4.version = n2, H2.call(e4, d3, l3.browser), e4.major = function(e5) {
                return typeof e5 === a2 ? e5.replace(/[^\d\.]/g, "").split(".")[0] : n2;
              }(e4.version), c3 && c3.brave && typeof c3.brave.isBrave == r2 && (e4.name = "Brave"), e4;
            }, this.getCPU = function() {
              var e4 = {};
              return e4.architecture = n2, H2.call(e4, d3, l3.cpu), e4;
            }, this.getDevice = function() {
              var e4 = {};
              return e4.vendor = n2, e4.model = n2, e4.type = n2, H2.call(e4, d3, l3.device), !e4.type && u3 && u3.mobile && (e4.type = m2), "Macintosh" == e4.model && c3 && typeof c3.standalone !== o2 && c3.maxTouchPoints && c3.maxTouchPoints > 2 && (e4.model = "iPad", e4.type = f2), e4;
            }, this.getEngine = function() {
              var e4 = {};
              return e4.name = n2, e4.version = n2, H2.call(e4, d3, l3.engine), e4;
            }, this.getOS = function() {
              var e4 = {};
              return e4.name = n2, e4.version = n2, H2.call(e4, d3, l3.os), !e4.name && u3 && "Unknown" != u3.platform && (e4.name = u3.platform.replace(/chrome os/i, V2).replace(/macos/i, j2)), e4;
            }, this.getResult = function() {
              return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
            }, this.getUA = function() {
              return d3;
            }, this.setUA = function(e4) {
              return d3 = typeof e4 === a2 && e4.length > 350 ? W2(e4, 350) : e4, this;
            }, this.setUA(d3), this;
          };
          J2.VERSION = "0.7.34", J2.BROWSER = F2([u2, p2, c2]), J2.CPU = F2([_2]), J2.DEVICE = F2([d2, h2, l2, E2, m2, S2, f2, T2, g2]), J2.ENGINE = J2.OS = F2([u2, p2]), e2.exports && (i2 = e2.exports = J2), i2.UAParser = J2;
          var X2 = typeof t2 !== o2 && (t2.jQuery || t2.Zepto);
          if (X2 && !X2.ua) {
            var z2 = new J2();
            X2.ua = z2.getResult(), X2.ua.get = function() {
              return z2.getUA();
            }, X2.ua.set = function(e3) {
              z2.setUA(e3);
              var t3 = z2.getResult();
              for (var i3 in t3)
                X2.ua[i3] = t3[i3];
            };
          }
        }("object" == typeof window ? window : t);
      }(Dh, Dh.exports);
      const Ph = new (0, Dh.exports)();
      let Lh, kh, Mh = Ph.getResult(), Uh = null;
      function xh(e2) {
        if (!Uh) {
          e2 && Ph.setUA(e2), Mh = Ph.getResult();
          const t2 = function(e3) {
            if ("Blink" === e3.engine.name && "WeChat" !== e3.browser.name)
              return wh.CHROME;
            switch (e3.browser.name) {
              case "Chrome Headless":
              case "Chrome":
              case "Chromium":
                return wh.CHROME;
              case "Safari":
              case "Mobile Safari":
                return wh.SAFARI;
              case "Edge":
                return wh.EDGE;
              case "Firefox":
                return wh.FIREFOX;
              case "QQBrowser":
                return wh.QQ;
              case "Opera":
                return wh.OPERA;
              case "WeChat":
                return wh.WECHAT;
              default:
                return e3.browser.name || "";
            }
          }(Mh), i2 = function(e3) {
            let t3;
            t3 = "Blink" === e3.engine.name ? e3.engine.version || "" : e3.browser.version || "";
            return t3.split(".")[0];
          }(Mh), n2 = function(e3) {
            switch (e3.os.name) {
              case "Windows":
                return e3.os.version ? e3.os.name + " " + e3.os.version : e3.os.name;
              default:
                return e3.os.name || "";
            }
          }(Mh), r2 = Mh.os.version;
          if (!(t2 && i2 && n2 && r2))
            return { name: t2, version: i2, os: n2, osVersion: r2 };
          Uh = { name: t2, version: i2, os: n2, osVersion: r2 };
        }
        return Uh;
      }
      function Vh() {
        return xh().os;
      }
      function jh() {
        const e2 = xh();
        return "".concat(e2.os, " ").concat(e2.osVersion);
      }
      function Fh() {
        const e2 = xh();
        return !!("WebKit" === Mh.engine.name && e2.os === bh.MAC_OS && navigator.maxTouchPoints && navigator.maxTouchPoints > 0 && e2.name !== wh.SAFARI || Yh() && e2.name !== wh.SAFARI);
      }
      function Bh() {
        const e2 = xh();
        if (Fh()) {
          if (e2.os === bh.MAC_OS)
            return true;
          if (e2.os === bh.IOS) {
            const e3 = Mh.os.version && Mh.os.version.split(".");
            if (e3 && 14 === Number(e3[0]) && e3[1] && Number(e3[1]) >= 3)
              return true;
            if (e3 && Number(e3[0]) > 14)
              return true;
          }
        }
        return false;
      }
      function Gh() {
        return "WebKit" === Mh.engine.name;
      }
      function Wh() {
        return xh().name === wh.CHROME;
      }
      function Hh() {
        return xh().name === wh.SAFARI;
      }
      function Kh() {
        return xh().name === wh.FIREFOX;
      }
      function Yh() {
        return xh().os === bh.IOS;
      }
      function qh(e2) {
        const t2 = xh();
        return !(t2.name !== wh.CHROME || !t2.osVersion) && Number(t2.version) >= e2;
      }
      function Jh(e2) {
        const t2 = xh();
        return !(t2.name !== wh.EDGE || !t2.osVersion) && Number(t2.version) >= e2;
      }
      function Xh(e2) {
        const t2 = xh();
        return !(t2.name !== wh.OPERA || !t2.osVersion) && Number(t2.version) >= e2;
      }
      function zh() {
        const e2 = xh();
        return !(e2.name !== wh.CHROME || !e2.osVersion) && Number(e2.version) <= 90;
      }
      function Qh() {
        const e2 = xh();
        if (e2.os !== bh.IOS || !e2.osVersion)
          return false;
        const t2 = e2.osVersion.split(".");
        return Number(t2[0]) < 14 || 14 === Number(t2[0]) && Number(t2[1]) <= 6;
      }
      function Zh() {
        const e2 = xh();
        if (e2.os !== bh.IOS || !e2.osVersion)
          return false;
        const t2 = e2.osVersion.split(".");
        return 15 === Number(t2[0]);
      }
      function $h() {
        const e2 = xh();
        if (e2.os !== bh.IOS || !e2.osVersion)
          return false;
        const t2 = e2.osVersion.split(".");
        return 16 === Number(t2[0]);
      }
      function ep() {
        const e2 = xh();
        if (e2.os !== bh.IOS || !e2.osVersion)
          return false;
        const t2 = e2.osVersion.split(".");
        return 15 === Number(t2[0]) && Number(t2[1]) >= 1;
      }
      function tp() {
        return Hh() && navigator.maxTouchPoints > 0;
      }
      function ip() {
        return xh().name === wh.WECHAT;
      }
      function np() {
        return window.navigator.appVersion && null !== window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./) && window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1] <= 35;
      }
      function rp() {
        const e2 = xh();
        if (e2.name === wh.EDGE || e2.name === wh.SAFARI)
          return false;
        return !!navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]./i);
      }
      function op() {
        return Vh() === bh.ANDROID;
      }
      function sp() {
        const e2 = xh();
        return op() && (e2.name === wh.CHROME || e2.name === wh.WECHAT || /chrome|chromium/i.test(navigator.userAgent));
      }
      !function(e2) {
        e2.L1T1 = "L1T1", e2.L1T2 = "L1T2", e2.L1T3 = "L1T3", e2.L2T1_KEY = "L2T1_KEY", e2.L2T2_KEY = "L2T2_KEY", e2.L2T3_KEY = "L2T3_KEY", e2.L3T1_KEY = "L3T1_KEY", e2.L3T2_KEY = "L3T2_KEY", e2.L3T3_KEY = "L3T3_KEY";
      }(Lh || (Lh = {})), function(e2) {
        e2.CERTIFICATE = "certificate", e2.CODEC = "codec", e2.CANDIDATE_PAIR = "candidate-pair", e2.LOCAL_CANDIDATE = "local-candidate", e2.REMOTE_CANDIDATE = "remote-candidate", e2.INBOUND = "inbound-rtp", e2.TRACK = "track", e2.OUTBOUND = "outbound-rtp", e2.PC = "peer-connection", e2.REMOTE_INBOUND = "remote-inbound-rtp", e2.REMOTE_OUTBOUND = "remote-outbound-rtp", e2.TRANSPORT = "transport", e2.CSRC = "csrc", e2.DATA_CHANNEL = "data-channel", e2.STREAM = "stream", e2.SENDER = "sender", e2.RECEIVER = "receiver";
      }(kh || (kh = {}));
      var ap = { exports: {} }, cp = Ii, dp = g, up = Ht.f;
      cp({ target: "Object", stat: true, forced: Object.defineProperty !== up, sham: !dp }, { defineProperty: up });
      var lp = J.Object, hp = ap.exports = function(e2, t2, i2) {
        return lp.defineProperty(e2, t2, i2);
      };
      lp.defineProperty.sham && (hp.sham = true);
      var pp = ap.exports;
      function _p(e2, t2, i2) {
        return t2 in e2 ? pp(e2, t2, { value: i2, enumerable: true, configurable: true, writable: true }) : e2[t2] = i2, e2;
      }
      var Ep, mp = { exports: {} }, fp = function(e2, t2) {
        return function() {
          for (var i2 = new Array(arguments.length), n2 = 0; n2 < i2.length; n2++)
            i2[n2] = arguments[n2];
          return e2.apply(t2, i2);
        };
      }, Sp = fp, Tp = Object.prototype.toString, gp = (Ep = /* @__PURE__ */ Object.create(null), function(e2) {
        var t2 = Tp.call(e2);
        return Ep[t2] || (Ep[t2] = t2.slice(8, -1).toLowerCase());
      });
      function Rp(e2) {
        return e2 = e2.toLowerCase(), function(t2) {
          return gp(t2) === e2;
        };
      }
      function Ip(e2) {
        return Array.isArray(e2);
      }
      function Cp(e2) {
        return void 0 === e2;
      }
      var vp = Rp("ArrayBuffer");
      function yp(e2) {
        return null !== e2 && "object" == typeof e2;
      }
      function Ap(e2) {
        if ("object" !== gp(e2))
          return false;
        var t2 = Object.getPrototypeOf(e2);
        return null === t2 || t2 === Object.prototype;
      }
      var Op = Rp("Date"), Np = Rp("File"), bp = Rp("Blob"), wp = Rp("FileList");
      function Dp(e2) {
        return "[object Function]" === Tp.call(e2);
      }
      var Pp = Rp("URLSearchParams");
      function Lp(e2, t2) {
        if (null != e2)
          if ("object" != typeof e2 && (e2 = [e2]), Ip(e2))
            for (var i2 = 0, n2 = e2.length; i2 < n2; i2++)
              t2.call(null, e2[i2], i2, e2);
          else
            for (var r2 in e2)
              Object.prototype.hasOwnProperty.call(e2, r2) && t2.call(null, e2[r2], r2, e2);
      }
      var kp, Mp = (kp = "undefined" != typeof Uint8Array && Object.getPrototypeOf(Uint8Array), function(e2) {
        return kp && e2 instanceof kp;
      }), Up = { isArray: Ip, isArrayBuffer: vp, isBuffer: function(e2) {
        return null !== e2 && !Cp(e2) && null !== e2.constructor && !Cp(e2.constructor) && "function" == typeof e2.constructor.isBuffer && e2.constructor.isBuffer(e2);
      }, isFormData: function(e2) {
        var t2 = "[object FormData]";
        return e2 && ("function" == typeof FormData && e2 instanceof FormData || Tp.call(e2) === t2 || Dp(e2.toString) && e2.toString() === t2);
      }, isArrayBufferView: function(e2) {
        return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e2) : e2 && e2.buffer && vp(e2.buffer);
      }, isString: function(e2) {
        return "string" == typeof e2;
      }, isNumber: function(e2) {
        return "number" == typeof e2;
      }, isObject: yp, isPlainObject: Ap, isUndefined: Cp, isDate: Op, isFile: Np, isBlob: bp, isFunction: Dp, isStream: function(e2) {
        return yp(e2) && Dp(e2.pipe);
      }, isURLSearchParams: Pp, isStandardBrowserEnv: function() {
        return ("undefined" == typeof navigator || "ReactNative" !== navigator.product && "NativeScript" !== navigator.product && "NS" !== navigator.product) && ("undefined" != typeof window && "undefined" != typeof document);
      }, forEach: Lp, merge: function e2() {
        var t2 = {};
        function i2(i3, n3) {
          Ap(t2[n3]) && Ap(i3) ? t2[n3] = e2(t2[n3], i3) : Ap(i3) ? t2[n3] = e2({}, i3) : Ip(i3) ? t2[n3] = i3.slice() : t2[n3] = i3;
        }
        for (var n2 = 0, r2 = arguments.length; n2 < r2; n2++)
          Lp(arguments[n2], i2);
        return t2;
      }, extend: function(e2, t2, i2) {
        return Lp(t2, function(t3, n2) {
          e2[n2] = i2 && "function" == typeof t3 ? Sp(t3, i2) : t3;
        }), e2;
      }, trim: function(e2) {
        return e2.trim ? e2.trim() : e2.replace(/^\s+|\s+$/g, "");
      }, stripBOM: function(e2) {
        return 65279 === e2.charCodeAt(0) && (e2 = e2.slice(1)), e2;
      }, inherits: function(e2, t2, i2, n2) {
        e2.prototype = Object.create(t2.prototype, n2), e2.prototype.constructor = e2, i2 && Object.assign(e2.prototype, i2);
      }, toFlatObject: function(e2, t2, i2) {
        var n2, r2, o2, s2 = {};
        t2 = t2 || {};
        do {
          for (r2 = (n2 = Object.getOwnPropertyNames(e2)).length; r2-- > 0; )
            s2[o2 = n2[r2]] || (t2[o2] = e2[o2], s2[o2] = true);
          e2 = Object.getPrototypeOf(e2);
        } while (e2 && (!i2 || i2(e2, t2)) && e2 !== Object.prototype);
        return t2;
      }, kindOf: gp, kindOfTest: Rp, endsWith: function(e2, t2, i2) {
        e2 = String(e2), (void 0 === i2 || i2 > e2.length) && (i2 = e2.length), i2 -= t2.length;
        var n2 = e2.indexOf(t2, i2);
        return -1 !== n2 && n2 === i2;
      }, toArray: function(e2) {
        if (!e2)
          return null;
        var t2 = e2.length;
        if (Cp(t2))
          return null;
        for (var i2 = new Array(t2); t2-- > 0; )
          i2[t2] = e2[t2];
        return i2;
      }, isTypedArray: Mp, isFileList: wp }, xp = Up;
      function Vp(e2) {
        return encodeURIComponent(e2).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      var jp = function(e2, t2, i2) {
        if (!t2)
          return e2;
        var n2;
        if (i2)
          n2 = i2(t2);
        else if (xp.isURLSearchParams(t2))
          n2 = t2.toString();
        else {
          var r2 = [];
          xp.forEach(t2, function(e3, t3) {
            null != e3 && (xp.isArray(e3) ? t3 += "[]" : e3 = [e3], xp.forEach(e3, function(e4) {
              xp.isDate(e4) ? e4 = e4.toISOString() : xp.isObject(e4) && (e4 = JSON.stringify(e4)), r2.push(Vp(t3) + "=" + Vp(e4));
            }));
          }), n2 = r2.join("&");
        }
        if (n2) {
          var o2 = e2.indexOf("#");
          -1 !== o2 && (e2 = e2.slice(0, o2)), e2 += (-1 === e2.indexOf("?") ? "?" : "&") + n2;
        }
        return e2;
      }, Fp = Up;
      function Bp() {
        this.handlers = [];
      }
      Bp.prototype.use = function(e2, t2, i2) {
        return this.handlers.push({ fulfilled: e2, rejected: t2, synchronous: !!i2 && i2.synchronous, runWhen: i2 ? i2.runWhen : null }), this.handlers.length - 1;
      }, Bp.prototype.eject = function(e2) {
        this.handlers[e2] && (this.handlers[e2] = null);
      }, Bp.prototype.forEach = function(e2) {
        Fp.forEach(this.handlers, function(t2) {
          null !== t2 && e2(t2);
        });
      };
      var Gp = Bp, Wp = Up, Hp = Up;
      function Kp(e2, t2, i2, n2, r2) {
        Error.call(this), this.message = e2, this.name = "AxiosError", t2 && (this.code = t2), i2 && (this.config = i2), n2 && (this.request = n2), r2 && (this.response = r2);
      }
      Hp.inherits(Kp, Error, { toJSON: function() {
        return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: this.config, code: this.code, status: this.response && this.response.status ? this.response.status : null };
      } });
      var Yp = Kp.prototype, qp = {};
      ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED"].forEach(function(e2) {
        qp[e2] = { value: e2 };
      }), Object.defineProperties(Kp, qp), Object.defineProperty(Yp, "isAxiosError", { value: true }), Kp.from = function(e2, t2, i2, n2, r2, o2) {
        var s2 = Object.create(Yp);
        return Hp.toFlatObject(e2, s2, function(e3) {
          return e3 !== Error.prototype;
        }), Kp.call(s2, e2.message, t2, i2, n2, r2), s2.name = e2.name, o2 && Object.assign(s2, o2), s2;
      };
      var Jp = Kp, Xp = { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false }, zp = Up;
      var Qp = function(e2, t2) {
        t2 = t2 || new FormData();
        var i2 = [];
        function n2(e3) {
          return null === e3 ? "" : zp.isDate(e3) ? e3.toISOString() : zp.isArrayBuffer(e3) || zp.isTypedArray(e3) ? "function" == typeof Blob ? new Blob([e3]) : Buffer.from(e3) : e3;
        }
        return function e3(r2, o2) {
          if (zp.isPlainObject(r2) || zp.isArray(r2)) {
            if (-1 !== i2.indexOf(r2))
              throw Error("Circular reference detected in " + o2);
            i2.push(r2), zp.forEach(r2, function(i3, r3) {
              if (!zp.isUndefined(i3)) {
                var s2, a2 = o2 ? o2 + "." + r3 : r3;
                if (i3 && !o2 && "object" == typeof i3) {
                  if (zp.endsWith(r3, "{}"))
                    i3 = JSON.stringify(i3);
                  else if (zp.endsWith(r3, "[]") && (s2 = zp.toArray(i3)))
                    return void s2.forEach(function(e4) {
                      !zp.isUndefined(e4) && t2.append(a2, n2(e4));
                    });
                }
                e3(i3, a2);
              }
            }), i2.pop();
          } else
            t2.append(o2, n2(r2));
        }(e2), t2;
      }, Zp = Jp, $p = Up, e_ = $p.isStandardBrowserEnv() ? { write: function(e2, t2, i2, n2, r2, o2) {
        var s2 = [];
        s2.push(e2 + "=" + encodeURIComponent(t2)), $p.isNumber(i2) && s2.push("expires=" + new Date(i2).toGMTString()), $p.isString(n2) && s2.push("path=" + n2), $p.isString(r2) && s2.push("domain=" + r2), true === o2 && s2.push("secure"), document.cookie = s2.join("; ");
      }, read: function(e2) {
        var t2 = document.cookie.match(new RegExp("(^|;\\s*)(" + e2 + ")=([^;]*)"));
        return t2 ? decodeURIComponent(t2[3]) : null;
      }, remove: function(e2) {
        this.write(e2, "", Date.now() - 864e5);
      } } : { write: function() {
      }, read: function() {
        return null;
      }, remove: function() {
      } }, t_ = function(e2) {
        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e2);
      }, i_ = function(e2, t2) {
        return t2 ? e2.replace(/\/+$/, "") + "/" + t2.replace(/^\/+/, "") : e2;
      }, n_ = function(e2, t2) {
        return e2 && !t_(t2) ? i_(e2, t2) : t2;
      }, r_ = Up, o_ = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"], s_ = Up, a_ = s_.isStandardBrowserEnv() ? function() {
        var e2, t2 = /(msie|trident)/i.test(navigator.userAgent), i2 = document.createElement("a");
        function n2(e3) {
          var n3 = e3;
          return t2 && (i2.setAttribute("href", n3), n3 = i2.href), i2.setAttribute("href", n3), { href: i2.href, protocol: i2.protocol ? i2.protocol.replace(/:$/, "") : "", host: i2.host, search: i2.search ? i2.search.replace(/^\?/, "") : "", hash: i2.hash ? i2.hash.replace(/^#/, "") : "", hostname: i2.hostname, port: i2.port, pathname: "/" === i2.pathname.charAt(0) ? i2.pathname : "/" + i2.pathname };
        }
        return e2 = n2(window.location.href), function(t3) {
          var i3 = s_.isString(t3) ? n2(t3) : t3;
          return i3.protocol === e2.protocol && i3.host === e2.host;
        };
      }() : function() {
        return true;
      }, c_ = Jp;
      function d_(e2) {
        c_.call(this, null == e2 ? "canceled" : e2, c_.ERR_CANCELED), this.name = "CanceledError";
      }
      Up.inherits(d_, c_, { __CANCEL__: true });
      var u_ = d_, l_ = Up, h_ = function(e2, t2, i2) {
        var n2 = i2.config.validateStatus;
        i2.status && n2 && !n2(i2.status) ? t2(new Zp("Request failed with status code " + i2.status, [Zp.ERR_BAD_REQUEST, Zp.ERR_BAD_RESPONSE][Math.floor(i2.status / 100) - 4], i2.config, i2.request, i2)) : e2(i2);
      }, p_ = e_, __ = jp, E_ = n_, m_ = function(e2) {
        var t2, i2, n2, r2 = {};
        return e2 ? (r_.forEach(e2.split("\n"), function(e3) {
          if (n2 = e3.indexOf(":"), t2 = r_.trim(e3.substr(0, n2)).toLowerCase(), i2 = r_.trim(e3.substr(n2 + 1)), t2) {
            if (r2[t2] && o_.indexOf(t2) >= 0)
              return;
            r2[t2] = "set-cookie" === t2 ? (r2[t2] ? r2[t2] : []).concat([i2]) : r2[t2] ? r2[t2] + ", " + i2 : i2;
          }
        }), r2) : r2;
      }, f_ = a_, S_ = Xp, T_ = Jp, g_ = u_, R_ = function(e2) {
        var t2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e2);
        return t2 && t2[1] || "";
      }, I_ = function(e2) {
        return new Promise(function(t2, i2) {
          var n2, r2 = e2.data, o2 = e2.headers, s2 = e2.responseType;
          function a2() {
            e2.cancelToken && e2.cancelToken.unsubscribe(n2), e2.signal && e2.signal.removeEventListener("abort", n2);
          }
          l_.isFormData(r2) && l_.isStandardBrowserEnv() && delete o2["Content-Type"];
          var c2 = new XMLHttpRequest();
          if (e2.auth) {
            var d2 = e2.auth.username || "", u2 = e2.auth.password ? unescape(encodeURIComponent(e2.auth.password)) : "";
            o2.Authorization = "Basic " + btoa(d2 + ":" + u2);
          }
          var l2 = E_(e2.baseURL, e2.url);
          function h2() {
            if (c2) {
              var n3 = "getAllResponseHeaders" in c2 ? m_(c2.getAllResponseHeaders()) : null, r3 = { data: s2 && "text" !== s2 && "json" !== s2 ? c2.response : c2.responseText, status: c2.status, statusText: c2.statusText, headers: n3, config: e2, request: c2 };
              h_(function(e3) {
                t2(e3), a2();
              }, function(e3) {
                i2(e3), a2();
              }, r3), c2 = null;
            }
          }
          if (c2.open(e2.method.toUpperCase(), __(l2, e2.params, e2.paramsSerializer), true), c2.timeout = e2.timeout, "onloadend" in c2 ? c2.onloadend = h2 : c2.onreadystatechange = function() {
            c2 && 4 === c2.readyState && (0 !== c2.status || c2.responseURL && 0 === c2.responseURL.indexOf("file:")) && setTimeout(h2);
          }, c2.onabort = function() {
            c2 && (i2(new T_("Request aborted", T_.ECONNABORTED, e2, c2)), c2 = null);
          }, c2.onerror = function() {
            i2(new T_("Network Error", T_.ERR_NETWORK, e2, c2, c2)), c2 = null;
          }, c2.ontimeout = function() {
            var t3 = e2.timeout ? "timeout of " + e2.timeout + "ms exceeded" : "timeout exceeded", n3 = e2.transitional || S_;
            e2.timeoutErrorMessage && (t3 = e2.timeoutErrorMessage), i2(new T_(t3, n3.clarifyTimeoutError ? T_.ETIMEDOUT : T_.ECONNABORTED, e2, c2)), c2 = null;
          }, l_.isStandardBrowserEnv()) {
            var p2 = (e2.withCredentials || f_(l2)) && e2.xsrfCookieName ? p_.read(e2.xsrfCookieName) : void 0;
            p2 && (o2[e2.xsrfHeaderName] = p2);
          }
          "setRequestHeader" in c2 && l_.forEach(o2, function(e3, t3) {
            void 0 === r2 && "content-type" === t3.toLowerCase() ? delete o2[t3] : c2.setRequestHeader(t3, e3);
          }), l_.isUndefined(e2.withCredentials) || (c2.withCredentials = !!e2.withCredentials), s2 && "json" !== s2 && (c2.responseType = e2.responseType), "function" == typeof e2.onDownloadProgress && c2.addEventListener("progress", e2.onDownloadProgress), "function" == typeof e2.onUploadProgress && c2.upload && c2.upload.addEventListener("progress", e2.onUploadProgress), (e2.cancelToken || e2.signal) && (n2 = function(e3) {
            c2 && (i2(!e3 || e3 && e3.type ? new g_() : e3), c2.abort(), c2 = null);
          }, e2.cancelToken && e2.cancelToken.subscribe(n2), e2.signal && (e2.signal.aborted ? n2() : e2.signal.addEventListener("abort", n2))), r2 || (r2 = null);
          var _2 = R_(l2);
          _2 && -1 === ["http", "https", "file"].indexOf(_2) ? i2(new T_("Unsupported protocol " + _2 + ":", T_.ERR_BAD_REQUEST, e2)) : c2.send(r2);
        });
      }, C_ = Up, v_ = function(e2, t2) {
        Wp.forEach(e2, function(i2, n2) {
          n2 !== t2 && n2.toUpperCase() === t2.toUpperCase() && (e2[t2] = i2, delete e2[n2]);
        });
      }, y_ = Jp, A_ = Qp, O_ = { "Content-Type": "application/x-www-form-urlencoded" };
      function N_(e2, t2) {
        !C_.isUndefined(e2) && C_.isUndefined(e2["Content-Type"]) && (e2["Content-Type"] = t2);
      }
      var b_, w_ = { transitional: Xp, adapter: (("undefined" != typeof XMLHttpRequest || "undefined" != typeof process && "[object process]" === Object.prototype.toString.call(process)) && (b_ = I_), b_), transformRequest: [function(e2, t2) {
        if (v_(t2, "Accept"), v_(t2, "Content-Type"), C_.isFormData(e2) || C_.isArrayBuffer(e2) || C_.isBuffer(e2) || C_.isStream(e2) || C_.isFile(e2) || C_.isBlob(e2))
          return e2;
        if (C_.isArrayBufferView(e2))
          return e2.buffer;
        if (C_.isURLSearchParams(e2))
          return N_(t2, "application/x-www-form-urlencoded;charset=utf-8"), e2.toString();
        var i2, n2 = C_.isObject(e2), r2 = t2 && t2["Content-Type"];
        if ((i2 = C_.isFileList(e2)) || n2 && "multipart/form-data" === r2) {
          var o2 = this.env && this.env.FormData;
          return A_(i2 ? { "files[]": e2 } : e2, o2 && new o2());
        }
        return n2 || "application/json" === r2 ? (N_(t2, "application/json"), function(e3, t3, i3) {
          if (C_.isString(e3))
            try {
              return (t3 || JSON.parse)(e3), C_.trim(e3);
            } catch (e4) {
              if ("SyntaxError" !== e4.name)
                throw e4;
            }
          return (i3 || JSON.stringify)(e3);
        }(e2)) : e2;
      }], transformResponse: [function(e2) {
        var t2 = this.transitional || w_.transitional, i2 = t2 && t2.silentJSONParsing, n2 = t2 && t2.forcedJSONParsing, r2 = !i2 && "json" === this.responseType;
        if (r2 || n2 && C_.isString(e2) && e2.length)
          try {
            return JSON.parse(e2);
          } catch (e3) {
            if (r2) {
              if ("SyntaxError" === e3.name)
                throw y_.from(e3, y_.ERR_BAD_RESPONSE, this, null, this.response);
              throw e3;
            }
          }
        return e2;
      }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: null }, validateStatus: function(e2) {
        return e2 >= 200 && e2 < 300;
      }, headers: { common: { Accept: "application/json, text/plain, */*" } } };
      C_.forEach(["delete", "get", "head"], function(e2) {
        w_.headers[e2] = {};
      }), C_.forEach(["post", "put", "patch"], function(e2) {
        w_.headers[e2] = C_.merge(O_);
      });
      var D_ = w_, P_ = Up, L_ = D_, k_ = function(e2) {
        return !(!e2 || !e2.__CANCEL__);
      }, M_ = Up, U_ = function(e2, t2, i2) {
        var n2 = this || L_;
        return P_.forEach(i2, function(i3) {
          e2 = i3.call(n2, e2, t2);
        }), e2;
      }, x_ = k_, V_ = D_, j_ = u_;
      function F_(e2) {
        if (e2.cancelToken && e2.cancelToken.throwIfRequested(), e2.signal && e2.signal.aborted)
          throw new j_();
      }
      var B_ = Up, G_ = function(e2, t2) {
        t2 = t2 || {};
        var i2 = {};
        function n2(e3, t3) {
          return B_.isPlainObject(e3) && B_.isPlainObject(t3) ? B_.merge(e3, t3) : B_.isPlainObject(t3) ? B_.merge({}, t3) : B_.isArray(t3) ? t3.slice() : t3;
        }
        function r2(i3) {
          return B_.isUndefined(t2[i3]) ? B_.isUndefined(e2[i3]) ? void 0 : n2(void 0, e2[i3]) : n2(e2[i3], t2[i3]);
        }
        function o2(e3) {
          if (!B_.isUndefined(t2[e3]))
            return n2(void 0, t2[e3]);
        }
        function s2(i3) {
          return B_.isUndefined(t2[i3]) ? B_.isUndefined(e2[i3]) ? void 0 : n2(void 0, e2[i3]) : n2(void 0, t2[i3]);
        }
        function a2(i3) {
          return i3 in t2 ? n2(e2[i3], t2[i3]) : i3 in e2 ? n2(void 0, e2[i3]) : void 0;
        }
        var c2 = { url: o2, method: o2, data: o2, baseURL: s2, transformRequest: s2, transformResponse: s2, paramsSerializer: s2, timeout: s2, timeoutMessage: s2, withCredentials: s2, adapter: s2, responseType: s2, xsrfCookieName: s2, xsrfHeaderName: s2, onUploadProgress: s2, onDownloadProgress: s2, decompress: s2, maxContentLength: s2, maxBodyLength: s2, beforeRedirect: s2, transport: s2, httpAgent: s2, httpsAgent: s2, cancelToken: s2, socketPath: s2, responseEncoding: s2, validateStatus: a2 };
        return B_.forEach(Object.keys(e2).concat(Object.keys(t2)), function(e3) {
          var t3 = c2[e3] || r2, n3 = t3(e3);
          B_.isUndefined(n3) && t3 !== a2 || (i2[e3] = n3);
        }), i2;
      }, W_ = "0.27.2", H_ = W_, K_ = Jp, Y_ = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(e2, t2) {
        Y_[e2] = function(i2) {
          return typeof i2 === e2 || "a" + (t2 < 1 ? "n " : " ") + e2;
        };
      });
      var q_ = {};
      Y_.transitional = function(e2, t2, i2) {
        function n2(e3, t3) {
          return "[Axios v" + H_ + "] Transitional option '" + e3 + "'" + t3 + (i2 ? ". " + i2 : "");
        }
        return function(i3, r2, o2) {
          if (false === e2)
            throw new K_(n2(r2, " has been removed" + (t2 ? " in " + t2 : "")), K_.ERR_DEPRECATED);
          return t2 && !q_[r2] && (q_[r2] = true, console.warn(n2(r2, " has been deprecated since v" + t2 + " and will be removed in the near future"))), !e2 || e2(i3, r2, o2);
        };
      };
      var J_ = Up, X_ = jp, z_ = Gp, Q_ = function(e2) {
        return F_(e2), e2.headers = e2.headers || {}, e2.data = U_.call(e2, e2.data, e2.headers, e2.transformRequest), e2.headers = M_.merge(e2.headers.common || {}, e2.headers[e2.method] || {}, e2.headers), M_.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function(t2) {
          delete e2.headers[t2];
        }), (e2.adapter || V_.adapter)(e2).then(function(t2) {
          return F_(e2), t2.data = U_.call(e2, t2.data, t2.headers, e2.transformResponse), t2;
        }, function(t2) {
          return x_(t2) || (F_(e2), t2 && t2.response && (t2.response.data = U_.call(e2, t2.response.data, t2.response.headers, e2.transformResponse))), Promise.reject(t2);
        });
      }, Z_ = G_, $_ = n_, eE = { assertOptions: function(e2, t2, i2) {
        if ("object" != typeof e2)
          throw new K_("options must be an object", K_.ERR_BAD_OPTION_VALUE);
        for (var n2 = Object.keys(e2), r2 = n2.length; r2-- > 0; ) {
          var o2 = n2[r2], s2 = t2[o2];
          if (s2) {
            var a2 = e2[o2], c2 = void 0 === a2 || s2(a2, o2, e2);
            if (true !== c2)
              throw new K_("option " + o2 + " must be " + c2, K_.ERR_BAD_OPTION_VALUE);
          } else if (true !== i2)
            throw new K_("Unknown option " + o2, K_.ERR_BAD_OPTION);
        }
      }, validators: Y_ }, tE = eE.validators;
      function iE(e2) {
        this.defaults = e2, this.interceptors = { request: new z_(), response: new z_() };
      }
      iE.prototype.request = function(e2, t2) {
        "string" == typeof e2 ? (t2 = t2 || {}).url = e2 : t2 = e2 || {}, (t2 = Z_(this.defaults, t2)).method ? t2.method = t2.method.toLowerCase() : this.defaults.method ? t2.method = this.defaults.method.toLowerCase() : t2.method = "get";
        var i2 = t2.transitional;
        void 0 !== i2 && eE.assertOptions(i2, { silentJSONParsing: tE.transitional(tE.boolean), forcedJSONParsing: tE.transitional(tE.boolean), clarifyTimeoutError: tE.transitional(tE.boolean) }, false);
        var n2 = [], r2 = true;
        this.interceptors.request.forEach(function(e3) {
          "function" == typeof e3.runWhen && false === e3.runWhen(t2) || (r2 = r2 && e3.synchronous, n2.unshift(e3.fulfilled, e3.rejected));
        });
        var o2, s2 = [];
        if (this.interceptors.response.forEach(function(e3) {
          s2.push(e3.fulfilled, e3.rejected);
        }), !r2) {
          var a2 = [Q_, void 0];
          for (Array.prototype.unshift.apply(a2, n2), a2 = a2.concat(s2), o2 = Promise.resolve(t2); a2.length; )
            o2 = o2.then(a2.shift(), a2.shift());
          return o2;
        }
        for (var c2 = t2; n2.length; ) {
          var d2 = n2.shift(), u2 = n2.shift();
          try {
            c2 = d2(c2);
          } catch (e3) {
            u2(e3);
            break;
          }
        }
        try {
          o2 = Q_(c2);
        } catch (e3) {
          return Promise.reject(e3);
        }
        for (; s2.length; )
          o2 = o2.then(s2.shift(), s2.shift());
        return o2;
      }, iE.prototype.getUri = function(e2) {
        e2 = Z_(this.defaults, e2);
        var t2 = $_(e2.baseURL, e2.url);
        return X_(t2, e2.params, e2.paramsSerializer);
      }, J_.forEach(["delete", "get", "head", "options"], function(e2) {
        iE.prototype[e2] = function(t2, i2) {
          return this.request(Z_(i2 || {}, { method: e2, url: t2, data: (i2 || {}).data }));
        };
      }), J_.forEach(["post", "put", "patch"], function(e2) {
        function t2(t3) {
          return function(i2, n2, r2) {
            return this.request(Z_(r2 || {}, { method: e2, headers: t3 ? { "Content-Type": "multipart/form-data" } : {}, url: i2, data: n2 }));
          };
        }
        iE.prototype[e2] = t2(), iE.prototype[e2 + "Form"] = t2(true);
      });
      var nE = iE, rE = u_;
      function oE(e2) {
        if ("function" != typeof e2)
          throw new TypeError("executor must be a function.");
        var t2;
        this.promise = new Promise(function(e3) {
          t2 = e3;
        });
        var i2 = this;
        this.promise.then(function(e3) {
          if (i2._listeners) {
            var t3, n2 = i2._listeners.length;
            for (t3 = 0; t3 < n2; t3++)
              i2._listeners[t3](e3);
            i2._listeners = null;
          }
        }), this.promise.then = function(e3) {
          var t3, n2 = new Promise(function(e4) {
            i2.subscribe(e4), t3 = e4;
          }).then(e3);
          return n2.cancel = function() {
            i2.unsubscribe(t3);
          }, n2;
        }, e2(function(e3) {
          i2.reason || (i2.reason = new rE(e3), t2(i2.reason));
        });
      }
      oE.prototype.throwIfRequested = function() {
        if (this.reason)
          throw this.reason;
      }, oE.prototype.subscribe = function(e2) {
        this.reason ? e2(this.reason) : this._listeners ? this._listeners.push(e2) : this._listeners = [e2];
      }, oE.prototype.unsubscribe = function(e2) {
        if (this._listeners) {
          var t2 = this._listeners.indexOf(e2);
          -1 !== t2 && this._listeners.splice(t2, 1);
        }
      }, oE.source = function() {
        var e2;
        return { token: new oE(function(t2) {
          e2 = t2;
        }), cancel: e2 };
      };
      var sE = oE, aE = Up, cE = Up, dE = fp, uE = nE, lE = G_;
      var hE = function e2(t2) {
        var i2 = new uE(t2), n2 = dE(uE.prototype.request, i2);
        return cE.extend(n2, uE.prototype, i2), cE.extend(n2, i2), n2.create = function(i3) {
          return e2(lE(t2, i3));
        }, n2;
      }(D_);
      hE.Axios = uE, hE.CanceledError = u_, hE.CancelToken = sE, hE.isCancel = k_, hE.VERSION = W_, hE.toFormData = Qp, hE.AxiosError = Jp, hE.Cancel = hE.CanceledError, hE.all = function(e2) {
        return Promise.all(e2);
      }, hE.spread = function(e2) {
        return function(t2) {
          return e2.apply(null, t2);
        };
      }, hE.isAxiosError = function(e2) {
        return aE.isObject(e2) && true === e2.isAxiosError;
      }, mp.exports = hE, mp.exports.default = hE;
      var pE = mp.exports;
      class _E {
        constructor(e2) {
          _p(this, "logger", void 0), _p(this, "prefixLists", []), this.logger = e2;
        }
        debug() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          this.logger.debug(...this.prefixLists, ...t2);
        }
        info() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          this.logger.info(...this.prefixLists, ...t2);
        }
        warning() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          this.logger.warning(...this.prefixLists, ...t2);
        }
        error() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          this.logger.error(...this.prefixLists, ...t2);
        }
        prefix(e2) {
          return this.prefixLists.push(e2), this;
        }
        popPrefix() {
          return this.prefixLists.pop(), this;
        }
      }
      class EE {
        constructor() {
          _p(this, "_events", {}), _p(this, "addListener", this.on);
        }
        getListeners(e2) {
          return this._events[e2] ? this._events[e2].map((e3) => e3.listener) : [];
        }
        on(e2, t2) {
          this._events[e2] || (this._events[e2] = []);
          const i2 = this._events[e2];
          -1 === this._indexOfListener(i2, t2) && i2.push({ listener: t2, once: false });
        }
        once(e2, t2) {
          this._events[e2] || (this._events[e2] = []);
          const i2 = this._events[e2];
          -1 === this._indexOfListener(i2, t2) && i2.push({ listener: t2, once: true });
        }
        off(e2, t2) {
          if (!this._events[e2])
            return;
          const i2 = this._events[e2], n2 = this._indexOfListener(i2, t2);
          -1 !== n2 && i2.splice(n2, 1), 0 === this._events[e2].length && delete this._events[e2];
        }
        removeAllListeners(e2) {
          e2 ? delete this._events[e2] : this._events = {};
        }
        emit(e2) {
          this._events[e2] || (this._events[e2] = []);
          const t2 = this._events[e2].map((e3) => e3);
          for (var i2 = arguments.length, n2 = new Array(i2 > 1 ? i2 - 1 : 0), r2 = 1; r2 < i2; r2++)
            n2[r2 - 1] = arguments[r2];
          for (let i3 = 0; i3 < t2.length; i3 += 1) {
            const r3 = t2[i3];
            r3.once && this.off(e2, r3.listener), r3.listener.apply(this, n2 || []);
          }
        }
        safeEmit(e2) {
          for (var t2 = arguments.length, i2 = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++)
            i2[n2 - 1] = arguments[n2];
          [...this._events[e2] || []].forEach((t3) => {
            t3.once && this.off(e2, t3.listener);
            try {
              t3.listener.apply(this, i2);
            } catch (t4) {
              OE.error("safeEmit event:".concat(e2, " error ").concat(null == t4 ? void 0 : t4.toString()));
            }
          });
        }
        _indexOfListener(e2, t2) {
          let i2 = e2.length;
          for (; i2--; )
            if (e2[i2].listener === t2)
              return i2;
          return -1;
        }
      }
      const mE = new class extends EE {
        reportLogUploadError(e2) {
          this.emit("REPORT_LOG_UPLOAD", e2);
        }
      }();
      let fE;
      !function(e2) {
        e2.UNEXPECTED_ERROR = "UNEXPECTED_ERROR", e2.UNEXPECTED_RESPONSE = "UNEXPECTED_RESPONSE", e2.TIMEOUT = "TIMEOUT", e2.INVALID_PARAMS = "INVALID_PARAMS", e2.NOT_READABLE = "NOT_READABLE", e2.NOT_SUPPORTED = "NOT_SUPPORTED", e2.INVALID_OPERATION = "INVALID_OPERATION", e2.OPERATION_ABORTED = "OPERATION_ABORTED", e2.WEB_SECURITY_RESTRICT = "WEB_SECURITY_RESTRICT", e2.EXCHANGE_SDP_FAILED = "EXCHANGE_SDP_FAILED", e2.NETWORK_ERROR = "NETWORK_ERROR", e2.NETWORK_TIMEOUT = "NETWORK_TIMEOUT", e2.NETWORK_RESPONSE_ERROR = "NETWORK_RESPONSE_ERROR", e2.API_INVOKE_TIMEOUT = "API_INVOKE_TIMEOUT", e2.ENUMERATE_DEVICES_FAILED = "ENUMERATE_DEVICES_FAILED", e2.DEVICE_NOT_FOUND = "DEVICE_NOT_FOUND", e2.ELECTRON_IS_NULL = "ELECTRON_IS_NULL", e2.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR = "ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR", e2.CHROME_PLUGIN_NO_RESPONSE = "CHROME_PLUGIN_NO_RESPONSE", e2.CHROME_PLUGIN_NOT_INSTALL = "CHROME_PLUGIN_NOT_INSTALL", e2.MEDIA_OPTION_INVALID = "MEDIA_OPTION_INVALID", e2.PERMISSION_DENIED = "PERMISSION_DENIED", e2.CONSTRAINT_NOT_SATISFIED = "CONSTRAINT_NOT_SATISFIED", e2.TRACK_IS_DISABLED = "TRACK_IS_DISABLED", e2.GET_VIDEO_ELEMENT_VISIBLE_ERROR = "GET_VIDEO_ELEMENT_VISIBLE_ERROR", e2.SHARE_AUDIO_NOT_ALLOWED = "SHARE_AUDIO_NOT_ALLOWED", e2.LOW_STREAM_ENCODING_ERROR = "LOW_STREAM_ENCODING_ERROR", e2.SET_ENCODING_PARAMETER_ERROR = "SET_ENCODING_PARAMETER_ERROR", e2.TRACK_STATE_UNREACHABLE = "TRACK_STATE_UNREACHABLE", e2.INVALID_UINT_UID_FROM_STRING_UID = "INVALID_UINT_UID_FROM_STRING_UID", e2.CAN_NOT_GET_PROXY_SERVER = "CAN_NOT_GET_PROXY_SERVER", e2.CAN_NOT_GET_GATEWAY_SERVER = "CAN_NOT_GET_GATEWAY_SERVER", e2.VOID_GATEWAY_ADDRESS = "VOID_GATEWAY_ADDRESS", e2.UID_CONFLICT = "UID_CONFLICT", e2.MULTI_UNILBS_RESPONSE_ERROR = "MULTI_UNILBS_RESPONSE_ERROR", e2.UPDATE_TICKET_FAILED = "UPDATE_TICKET_FAILED", e2.INVALID_LOCAL_TRACK = "INVALID_LOCAL_TRACK", e2.INVALID_TRACK = "INVALID_TRACK", e2.SENDER_NOT_FOUND = "SENDER_NOT_FOUND", e2.CREATE_OFFER_FAILED = "CREATE_OFFER_FAILED", e2.SET_ANSWER_FAILED = "SET_ANSWER_FAILED", e2.ICE_FAILED = "ICE_FAILED", e2.PC_CLOSED = "PC_CLOSED", e2.SENDER_REPLACE_FAILED = "SENDER_REPLACE_FAILED", e2.GET_LOCAL_CAPABILITIES_FAILED = "GET_LOCAL_CAPABILITIES_FAILED", e2.GET_LOCAL_CONNECTION_PARAMS_FAILED = "GET_LOCAL_CONNECTION_PARAMS_FAILED", e2.SUBSCRIBE_FAILED = "SUBSCRIBE_FAILED", e2.UNSUBSCRIBE_FAILED = "UNSUBSCRIBE_FAILED", e2.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST", e2.NO_ICE_CANDIDATE = "NO_ICE_CANDIDATE", e2.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS = "CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS", e2.EXIST_DISABLED_VIDEO_TRACK = "EXIST_DISABLED_VIDEO_TRACK", e2.INVALID_REMOTE_USER = "INVALID_REMOTE_USER", e2.REMOTE_USER_IS_NOT_PUBLISHED = "REMOTE_USER_IS_NOT_PUBLISHED", e2.CUSTOM_REPORT_SEND_FAILED = "CUSTOM_REPORT_SEND_FAILED", e2.CUSTOM_REPORT_FREQUENCY_TOO_HIGH = "CUSTOM_REPORT_FREQUENCY_TOO_HIGH", e2.FETCH_AUDIO_FILE_FAILED = "FETCH_AUDIO_FILE_FAILED", e2.READ_LOCAL_AUDIO_FILE_ERROR = "READ_LOCAL_AUDIO_FILE_ERROR", e2.DECODE_AUDIO_FILE_FAILED = "DECODE_AUDIO_FILE_FAILED", e2.WS_ABORT = "WS_ABORT", e2.WS_DISCONNECT = "WS_DISCONNECT", e2.WS_ERR = "WS_ERR", e2.LIVE_STREAMING_TASK_CONFLICT = "LIVE_STREAMING_TASK_CONFLICT", e2.LIVE_STREAMING_INVALID_ARGUMENT = "LIVE_STREAMING_INVALID_ARGUMENT", e2.LIVE_STREAMING_INTERNAL_SERVER_ERROR = "LIVE_STREAMING_INTERNAL_SERVER_ERROR", e2.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED = "LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED", e2.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED = "LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED", e2.LIVE_STREAMING_CDN_ERROR = "LIVE_STREAMING_CDN_ERROR", e2.LIVE_STREAMING_INVALID_RAW_STREAM = "LIVE_STREAMING_INVALID_RAW_STREAM", e2.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT = "LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT", e2.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE = "LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE", e2.LIVE_STREAMING_WARN_FREQUENT_REQUEST = "LIVE_STREAMING_WARN_FREQUENT_REQUEST", e2.WEBGL_INTERNAL_ERROR = "WEBGL_INTERNAL_ERROR", e2.BEAUTY_PROCESSOR_INTERNAL_ERROR = "BEAUTY_PROCESSOR_INTERNAL_ERROR", e2.CROSS_CHANNEL_WAIT_STATUS_ERROR = "CROSS_CHANNEL_WAIT_STATUS_ERROR", e2.CROSS_CHANNEL_FAILED_JOIN_SRC = "CROSS_CHANNEL_FAILED_JOIN_SEC", e2.CROSS_CHANNEL_FAILED_JOIN_DEST = "CROSS_CHANNEL_FAILED_JOIN_DEST", e2.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST = "CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST", e2.CROSS_CHANNEL_SERVER_ERROR_RESPONSE = "CROSS_CHANNEL_SERVER_ERROR_RESPONSE", e2.METADATA_OUT_OF_RANGE = "METADATA_OUT_OF_RANGE", e2.LOCAL_AEC_ERROR = "LOCAL_AEC_ERROR", e2.INVALID_PLUGIN = "INVALID_PLUGIN", e2.DISCONNECT_P2P = "DISCONNECT_P2P", e2.INIT_WEBSOCKET_TIMEOUT = "INIT_WEBSOCKET_TIMEOUT", e2.CONVERTING_IMAGEDATA_TO_BLOB_FAILED = "CONVERTING_IMAGEDATA_TO_BLOB_FAILED", e2.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED = "CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED", e2.INIT_DATACHANNEL_TIMEOUT = "INIT_DATACHANNEL_TIMEOUT", e2.DATACHANNEL_CONNECTION_TIMEOUT = "DATACHANNEL_CONNECTION_TIMEOUT", e2.PROHIBITED_OPERATION = "PROHIBITED_OPERATION", e2.IMAGE_MODERATION_UPLOAD_FAILED = "IMAGE_MODERATION_UPLOAD_FAILED";
      }(fE || (fE = {}));
      class SE extends Error {
        constructor(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", i2 = arguments.length > 2 ? arguments[2] : void 0;
          super(t2), _p(this, "code", void 0), _p(this, "message", void 0), _p(this, "data", void 0), _p(this, "name", "AgoraRTCException"), this.code = e2, this.message = "AgoraRTCError ".concat(this.code, ": ").concat(t2), this.data = i2;
        }
        toString() {
          return this.data ? "data: ".concat(JSON.stringify(this.data), "\n").concat(this.stack) : "".concat(this.stack);
        }
        print() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "error";
          return "error" === e2 && OE.error(this.toString()), "warning" === e2 && OE.warning(this.toString()), this;
        }
        throw() {
          throw this.print(), this;
        }
      }
      const TE = { timeout: 500, timeoutFactor: 1.5, maxRetryCount: 1 / 0, maxRetryTimeout: 1e4 };
      function gE(e2, t2) {
        const i2 = Math.floor(t2.timeout * Math.pow(t2.timeoutFactor, e2));
        return Math.min(t2.maxRetryTimeout, i2);
      }
      function RE(e2, t2, i2, n2) {
        const r2 = Object.assign({}, TE, n2);
        let o2 = r2.timeout;
        const s2 = async () => {
          await function(e3) {
            return new Sl((t3) => {
              window.setTimeout(t3, e3);
            });
          }(o2), o2 *= r2.timeoutFactor, o2 = Math.min(r2.maxRetryTimeout, o2);
        };
        let a2 = false;
        const c2 = new Sl(async (n3, o3) => {
          t2 = t2 || (() => false), i2 = i2 || (() => true);
          for (let c3 = 0; c3 < r2.maxRetryCount; c3 += 1) {
            if (a2)
              return o3(new SE(fE.OPERATION_ABORTED));
            try {
              const i3 = await e2();
              if (!t2(i3, c3))
                return n3(i3);
              if (c3 + 1 === r2.maxRetryCount)
                return n3(i3);
              await s2();
            } catch (e3) {
              if (!i2(e3, c3))
                return o3(e3);
              if (c3 + 1 === r2.maxRetryCount)
                return o3(e3);
              await s2();
            }
          }
        });
        return c2.cancel = () => a2 = true, c2;
      }
      function IE() {
        const e2 = new Date();
        return e2.toTimeString().split(" ")[0] + ":" + e2.getMilliseconds();
      }
      function CE() {
        const e2 = new Date(), t2 = /((\d+:){2}\d+)/.exec(new Date().toUTCString());
        return t2 ? (null == t2 ? void 0 : t2[0]) + ":" + e2.getUTCMilliseconds() : e2.toTimeString().split(" ")[0] + ":" + e2.getMilliseconds();
      }
      const vE = { DEBUG: 0, INFO: 1, WARNING: 2, ERROR: 3, NONE: 4 }, yE = Date.now(), AE = (e2) => {
        for (const t2 in vE)
          if (Object.prototype.hasOwnProperty.call(vE, t2) && vE[t2] === e2)
            return t2;
        return "DEFAULT";
      };
      const OE = new class {
        constructor() {
          _p(this, "proxyServerURL", void 0), _p(this, "logLevel", vE.DEBUG), _p(this, "uploadState", "collecting"), _p(this, "uploadLogWaitingList", []), _p(this, "uploadLogUploadingList", []), _p(this, "uploadErrorCount", 0), _p(this, "currentLogID", 0), _p(this, "url", void 0), _p(this, "extLog", (e2, t2) => {
            this.appendLogToWaitingList(e2, ...t2);
          });
        }
        debug() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          const n2 = [vE.DEBUG].concat(t2);
          this.log.apply(this, n2);
        }
        info() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          const n2 = [vE.INFO].concat(t2);
          this.log.apply(this, n2);
        }
        warning() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          const n2 = [vE.WARNING].concat(t2);
          this.log.apply(this, n2);
        }
        error() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          const n2 = [vE.ERROR].concat(t2);
          this.log.apply(this, n2);
        }
        upload() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          const n2 = [vE.DEBUG].concat(t2);
          this.uploadLog.apply(this, n2);
        }
        setLogLevel(e2) {
          e2 = Math.min(Math.max(0, e2), 4), this.logLevel = e2;
        }
        enableLogUpload() {
          BE("UPLOAD_LOG", true);
        }
        disableLogUpload() {
          BE("UPLOAD_LOG", false), this.uploadLogUploadingList = [], this.uploadLogWaitingList = [];
        }
        setProxyServer(e2) {
          this.proxyServerURL = e2;
        }
        prefix(e2) {
          return new _E(this).prefix(e2);
        }
        log() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          if (Date.now() - yE < 100)
            return void setTimeout(() => {
              this.log(...t2);
            }, Date.now() - yE);
          const n2 = Math.max(0, Math.min(4, t2[0]));
          if (t2[0] = IE() + " Agora-SDK [".concat(AE(n2), "]:"), this.appendLogToWaitingList(n2, ...t2), n2 < this.logLevel)
            return;
          const r2 = IE() + " %cAgora-SDK [".concat(AE(n2), "]:");
          let o2 = [];
          if (!GE("USE_NEW_LOG"))
            switch (n2) {
              case vE.DEBUG:
                o2 = [r2, "color: #64B5F6;"].concat(t2.slice(1)), console.log.apply(console, o2);
                break;
              case vE.INFO:
                o2 = [r2, "color: #1E88E5; font-weight: bold;"].concat(t2.slice(1)), console.log.apply(console, o2);
                break;
              case vE.WARNING:
                o2 = [r2, "color: #FB8C00; font-weight: bold;"].concat(t2.slice(1)), console.warn.apply(console, o2);
                break;
              case vE.ERROR:
                o2 = [r2, "color: #B00020; font-weight: bold;"].concat(t2.slice(1)), console.error.apply(console, o2);
            }
        }
        uploadLog() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          if (Date.now() - yE < 100)
            return void setTimeout(() => {
              this.uploadLog(...t2);
            }, Date.now() - yE);
          const n2 = Math.max(0, Math.min(4, t2[0]));
          t2[0] = IE() + " Agora-SDK [".concat(AE(n2), "]:"), this.appendLogToWaitingList(n2, ...t2);
        }
        appendLogToWaitingList(e2) {
          if (!GE("UPLOAD_LOG"))
            return;
          for (var t2 = arguments.length, i2 = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++)
            i2[n2 - 1] = arguments[n2];
          Array.isArray(i2[0]) ? i2[0][0] = CE() + " Agora-SDK [".concat(AE(e2), "]:") : i2[0] = CE() + " Agora-SDK [".concat(AE(e2), "]:");
          let r2 = "";
          i2.forEach((e3) => {
            "object" == typeof e3 && (e3 = JSON.stringify(e3)), r2 += "".concat(e3, " ");
          }), this.uploadLogWaitingList.push({ payload_str: r2, log_level: e2, log_item_id: this.currentLogID++ }), "uploading" === this.uploadState && 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();
        }
        startUpload() {
          this.uploadState = "uploading", 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();
        }
        async uploadLogs() {
          const e2 = this.uploadLogUploadingList, t2 = { sdk_version: bE, process_id: GE("PROCESS_ID"), payload: JSON.stringify(e2) };
          return RE(async () => {
            const e3 = await pE.post(this.url || (this.proxyServerURL ? "https://".concat(this.proxyServerURL, "/ls/?h=").concat(GE("LOG_UPLOAD_SERVER"), "&p=443&d=upload/v1") : "https://".concat(GE("LOG_UPLOAD_SERVER"), "/upload/v1")), t2, { responseType: "text" });
            if ("OK" !== e3.data) {
              const t3 = new Error("unexpected upload log response");
              throw t3.response = e3, t3;
            }
          }, () => (this.uploadLogUploadingList = [], false), (e3) => (e3.response ? mE.reportLogUploadError({ status: e3.response.status, data: e3.response.data, headers: e3.response.headers, message: e3.message }) : e3.request ? mE.reportLogUploadError({ status: e3.request.status, message: e3.message }) : mE.reportLogUploadError({ status: -1, message: e3.message }), true), { timeout: GE("UPLOAD_LOG_REQUEST_RETRY_INTERVAL"), maxRetryTimeout: GE("UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL") });
        }
        uploadLogInterval() {
          0 === this.uploadLogUploadingList.length && 0 === this.uploadLogWaitingList.length || (0 === this.uploadLogUploadingList.length && (this.uploadLogUploadingList = this.uploadLogWaitingList.splice(0, GE("UPLOAD_LOG_LENGTH_EACH_TIME"))), this.uploadLogs().then(() => {
            this.uploadErrorCount = 0, this.uploadLogWaitingList.length > 0 && window.setTimeout(() => this.uploadLogInterval(), GE("UPLOAD_LOG_INTERVAL"));
          }).catch((e2) => {
            this.uploadErrorCount += 1, this.uploadErrorCount < 2 ? window.setTimeout(() => this.uploadLogInterval(), GE("UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1")) : window.setTimeout(() => this.uploadLogInterval(), GE("UPLOAD_LOG_RETRY_INTERVAL_V1"));
          }));
        }
      }(), NE = "v4.18.2-0-g8d83af1d-dirty(7/11/2023, 7:07:15 PM)", bE = function(e2) {
        if (e2.match(/[0-9]+\.[0-9]+\.[0-9]+$/))
          return e2;
        const t2 = e2.match(/([0-9]+\.[0-9]+\.[0-9]+)\-alpha\.([0-9]+)/);
        if (t2 && t2[1] && t2[2]) {
          const e3 = t2[1], i3 = t2[2];
          return "".concat(e3, ".").concat(i3);
        }
        const i2 = e2.match(/([0-9]+\.[0-9]+\.[0-9]+)\-special\.([0-9]+)/);
        if (i2 && i2[1] && i2[2]) {
          const e3 = i2[1], t3 = i2[2];
          return "".concat(e3, ".").concat(100 * (Number(t3) + 1));
        }
        return "4.0.0.999";
      }("4.18.2"), wE = function() {
        try {
          return true === JSON.parse("true");
        } catch (e2) {
          return true;
        }
      }(), DE = ["CHINA", "GLOBAL"], PE = function() {
        const e2 = "us".concat("erna", "me"), t2 = "pa".concat("sswo", "rd"), i2 = ["t", "s", "t"];
        i2.splice(1, 0, "e");
        const n2 = i2.join(""), r2 = [];
        for (let e3 = 0; e3 < 6; e3++)
          r2.push("1");
        const o2 = r2.join(""), s2 = {};
        return s2[e2] = n2, s2[t2] = o2, Object.assign(s2, { turnServerURL: "", tcpport: 3433, udpport: 3478, forceturn: false });
      }();
      window.DEFAULT_TURN_CONFIG = PE;
      const LE = { "90p": YE(160, 90), "90p_1": YE(160, 90), "120p": YE(160, 120, 15, 30, 65), "120p_1": YE(160, 120, 15, 30, 65), "120p_3": YE(120, 120, 15, 30, 50), "120p_4": YE(212, 120), "180p": YE(320, 180, 15, 30, 140), "180p_1": YE(320, 180, 15, 30, 140), "180p_3": YE(180, 180, 15, 30, 100), "180p_4": YE(240, 180, 15, 30, 120), "240p": YE(320, 240, 15, 40, 200), "240p_1": YE(320, 240, 15, 40, 200), "240p_3": YE(240, 240, 15, 40, 140), "240p_4": YE(424, 240, 15, 40, 220), "360p": YE(640, 360, 15, 80, 400), "360p_1": YE(640, 360, 15, 80, 400), "360p_3": YE(360, 360, 15, 80, 260), "360p_4": YE(640, 360, 30, 80, 600), "360p_6": YE(360, 360, 30, 80, 400), "360p_7": YE(480, 360, 15, 80, 320), "360p_8": YE(480, 360, 30, 80, 490), "360p_9": YE(640, 360, 15, 80, 800), "360p_10": YE(640, 360, 24, 80, 800), "360p_11": YE(640, 360, 24, 80, 1e3), "480p": YE(640, 480, 15, 100, 500), "480p_1": YE(640, 480, 15, 100, 500), "480p_2": YE(640, 480, 30, 100, 1e3), "480p_3": YE(480, 480, 15, 100, 400), "480p_4": YE(640, 480, 30, 100, 750), "480p_6": YE(480, 480, 30, 100, 600), "480p_8": YE(848, 480, 15, 100, 610), "480p_9": YE(848, 480, 30, 100, 930), "480p_10": YE(640, 480, 10, 100, 400), "720p": YE(1280, 720, 15, 120, 1130), "720p_1": YE(1280, 720, 15, 120, 1130), "720p_2": YE(1280, 720, 30, 120, 2e3), "720p_3": YE(1280, 720, 30, 120, 1710), "720p_5": YE(960, 720, 15, 120, 910), "720p_6": YE(960, 720, 30, 120, 1380), "1080p": YE(1920, 1080, 15, 120, 2080), "1080p_1": YE(1920, 1080, 15, 120, 2080), "1080p_2": YE(1920, 1080, 30, 120, 3e3), "1080p_3": YE(1920, 1080, 30, 120, 3150), "1080p_5": YE(1920, 1080, 60, 120, 4780), "1440p": YE(2560, 1440, 30, 120, 4850), "1440p_1": YE(2560, 1440, 30, 120, 4850), "1440p_2": YE(2560, 1440, 60, 120, 7350), "4k": YE(3840, 2160, 30, 120, 8910), "4k_1": YE(3840, 2160, 30, 120, 8910), "4k_3": YE(3840, 2160, 60, 120, 13500) }, kE = { "480p": qE(640, 480, 5), "480p_1": qE(640, 480, 5), "480p_2": qE(640, 480, 30), "480p_3": qE(640, 480, 15), "720p": qE(1280, 720, 5), "720p_1": qE(1280, 720, 5), "720p_2": qE(1280, 720, 30), "720p_3": qE(1280, 720, 15), "1080p": qE(1920, 1080, 5), "1080p_1": qE(1920, 1080, 5), "1080p_2": qE(1920, 1080, 30), "1080p_3": qE(1920, 1080, 15) }, ME = { "1SL1TL": JE(1, 1), "3SL3TL": JE(3, 3), "2SL3TL": JE(2, 3) };
      function UE(e2) {
        return e2 || (e2 = "480p_1"), "string" == typeof e2 ? Object.assign({}, LE[e2]) : e2;
      }
      function xE(e2) {
        return "string" == typeof e2 ? Object.assign({}, kE[e2]) : e2;
      }
      function VE(e2) {
        return "string" == typeof e2 ? Object.assign({}, ME[e2]) : e2;
      }
      const jE = { speech_low_quality: KE(16e3, false), speech_standard: KE(32e3, false, 18), music_standard: KE(48e3, false), standard_stereo: KE(48e3, true, 56), high_quality: KE(48e3, false, 128), high_quality_stereo: KE(48e3, true, 192) };
      function FE(e2) {
        return "string" == typeof e2 ? Object.assign({}, jE[e2]) : e2;
      }
      function BE(e2, t2, i2) {
        Object.keys(WE).includes(e2) && (!i2 && Object.keys(HE).includes(e2) || (WE[e2] = t2));
      }
      function GE(e2) {
        return WE[e2];
      }
      const WE = { PROCESS_ID: "", ENCRYPT_AES: true, AREAS: DE, WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io", "webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io", "webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-web-2.ap.sd-rtn.com", "cds-ap-web-3.agora.io", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-web-2.ap.sd-rtn.com", "sua-ap-web-3.agora.io", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-web-2.ap.sd-rtn.com", "uap-ap-web-3.agora.io", "uap-web-4.ap.sd-rtn.com"], LOG_UPLOAD_SERVER: "logservice.agora.io", EVENT_REPORT_DOMAIN: "statscollector-1.agora.io", EVENT_REPORT_BACKUP_DOMAIN: "web-2.statscollector.sd-rtn.com", ENABLE_EVENT_REPORT: true, GATEWAY_ADDRESS: [], GATEWAY_WSS_ADDRESS: "", LIVE_STREAMING_ADDRESS: "", HTTP_CONNECT_TIMEOUT: 5e3, SIGNAL_REQUEST_TIMEOUT: 1e4, REPORT_STATS: true, UPLOAD_LOG: false, NOT_REPORT_EVENT: [], SUBSCRIBE_TWCC: false, PUBLISH_TWCC: false, PING_PONG_TIME_OUT: 10, WEBSOCKET_TIMEOUT_MIN: 1e4, EVENT_REPORT_SEND_INTERVAL: 3e3, CONFIG_DISTRIBUTE_INTERVAL: 3e5, ENABLE_CONFIG_DISTRIBUTE: true, CANDIDATE_TIMEOUT: 5e3, SHOW_REPORT_INVOKER_LOG: false, JOIN_EXTEND: "", PUB_EXTEND: "", SUB_EXTEND: "", FORCE_TURN: false, TURN_ENABLE_TCP: true, TURN_ENABLE_UDP: true, MAX_UPLOAD_CACHE: 50, UPLOAD_CACHE_INTERVAL: 2e3, AJAX_REQUEST_CONCURRENT: 3, REPORT_APP_SCENARIO: void 0, GATEWAY_DOMAINS: ["edge.agora.io", "edge.sd-rtn.com"], WORKER_DOMAIN: "edge.agora.io", TURN_DOMAIN: "edge.agora.io", EVENT_REPORT_RETRY: true, CHROME_FORCE_PLAN_B: false, AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL: 400, AUDIO_SOURCE_AVG_VOLUME_DURATION: 3e3, AUDIO_VOLUME_INDICATION_INTERVAL: 2e3, VOLUME_VOICE_WEIGHT: 10, GET_VOLUME_OF_MUTED_AUDIO_TRACK: false, STATS_UPDATE_INTERVAL: 250, NORMAL_EVENT_QUEUE_CAPACITY: 100, CUSTOM_REPORT: true, CUSTOM_REPORT_LIMIT: 20, PROXY_SERVER_TYPE2: "webnginx-proxy.agora.io", PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com", "webrtc-cloud-proxy.agora.io"], CUSTOM_PUB_ANSWER_MODIFIER: null, CUSTOM_SUB_ANSWER_MODIFIER: null, CUSTOM_PUB_OFFER_MODIFIER: null, CUSTOM_SUB_OFFER_MODIFIER: null, DSCP_TYPE: "high", REMOVE_NEW_CODECS: true, FRAGEMENT_LENGTH: 3, WEBSOCKET_COMPRESS: false, SIMULCAST: false, PRELOAD_MEDIA_COUNT: 0, USE_PUB_RTX: false, USE_SUB_RTX: false, CHECK_VIDEO_VISIBLE_INTERVAL: 3e4, ENUMERATE_DEVICES_INTERVAL: false, ENUMERATE_DEVICES_INTERVAL_TIME: 1e4, USE_NEW_TOKEN: false, CLOSE_AFB_FOR_LOCAL_AP: true, JOIN_WITH_FALLBACK_SIGNAL_PROXY: true, JOIN_WITH_FALLBACK_MEDIA_PROXY: true, JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE: false, JOIN_WITH_FALLBACK_PROXY_PENDING_DURATION: 2e3, USE_TURN_SERVER_OF_GATEWAY: false, H264_PROFILE_LEVEL_ID: "", USE_NEW_LOG: false, LOG_VERSION: 3, MEDIA_DEVICE_CONSTRAINTS: null, ENCRYPT_PROXY_USERNAME_AND_PSW: true, SDP_LOGGING: false, CSP_DETECTED_HOSTNAME_LIST: ["agora.io", "sd-rtn.com"], REMOTE_AUDIO_TRACK_USES_WEB_AUDIO: false, LOCAL_AUDIO_TRACK_USES_WEB_AUDIO: true, BITRATE_ADAPTER_TYPE: "STANDARD_BITRATE", AI_DENOISER_PARAMETERS: {}, ADJUST_3A_FROM_PLUGINS: true, RAISE_H264_BASELINE_PRIORITY: true, FILTER_SEND_H264_BASELINE: false, ENABLE_PUBLISHED_USER_LIST: true, MAX_SUBSCRIPTION: 50, X_GOOGLE_START_BITRATE: void 0, NEW_REPORT_SERVER: false, NEW_REPORT_SERVER_DOMAINS: ["data-reporting.agora.io", "data-reporting.agora.io"], VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT: 3e5, VIDEO_INSPECT_INTERVAL_MINIMUM: 1e3, VIDEO_INSPECT_QUALITY_RATIO: 0.9, VIDEO_INSPECT_WORKER_MANAGER_HOST: "edge.agora.io", VIDEO_INSPECT_WORKER_MANAGER_PORT: "", VIDEO_INSPECT_WORKER_PORT: "", SHOW_VIDEO_INSPECT_WORKER_MESSAGE: false, STATS_COLLECTOR_PORT: 443, FORCE_TURN_TCP: false, SUBSCRIBE_AUDIO_FILTER_TOPN: void 0, ENABLE_PUBLISH_AUDIO_FILTER: void 0, WEBAUDIO_INIT_OPTIONS: void 0, FILTER_VIDEO_FEC: true, FILTER_AUDIO_FEC: false, CHROME_DUAL_STREAM_USE_ENCODING: true, EXTENSION_USAGE_UPLOAD_INTERVAL: 1e4, ICE_RESTART: true, ICE_RESTART_INTERVAL: 1e4, NEW_ICE_RESTART: false, ENABLE_USER_LICENSE_CHECK: true, SIGNAL_CHANNEL: 0, TRANSMITTER_INITIAL_RTT: 30, TRANSMITTER_INITIAL_RTO: 30, TRANSMITTER_MAX_BATCH_ACK_COUNT: 2, TRANSMITTER_MAX_RTO: 500, DATACHANNEL_COMPRESS: false, FINGERPRINT: null, DC_JOIN_WITH_FAILBACK: 5e3, ENABLE_VIDEO_FRAME_CALLBACK: true, VIDEO_FREEZE_DURATION: 500, SPATIALIZER_PARAMETERS: {}, UPLOAD_LOG_INTERVAL: 3e3, UPLOAD_LOG_REQUEST_RETRY_INTERVAL: 2e3, UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL: 2e4, UPLOAD_LOG_TRY_INTERVAL_WHILE_OFF: 5e3, UPLOAD_LOG_RETRY_INTERVAL_V1: 1e4, UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1: 200, UPLOAD_LOG_LENGTH_EACH_TIME: 10, APP_TYPE: 0, DISABLE_WEBAUDIO: false, CHANNEL_MEDIA_RELAY_SERVERS: void 0, KEEP_LAST_FRAME: true, FORWARD_P2P_CREATION: true, SYNC_GROUP: true, BLOCK_LOCAL_CLIENT: false, AP_AREA: true, SVC: [], ENABLE_ENCODED_TRANSFORM: false, IMAGE_MODERATION_WORKER_HOST: "edge.agora.io", IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT: 3e5, IMAGE_MODERATION_INTERVAL_MINIMUM: 1e3, SHOW_IMAGE_MODERATION_WORKER_MESSAGE: false, IMAGE_MODERATION_QUALITY_RATIO: 0.9, IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL: 5e3, ACCOUNT_REGISTER_RETRY_TIMEOUT: 1, ACCOUNT_REGISTER_RETRY_RATIO: 2, ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX: 6e4, ACCOUNT_REGISTER_RETRY_COUNT_MAX: 1e5, AUDIO_CONTEXT: null, WEBCS_BACKUP_CONNECT_TIMEOUT: 6e3, PLAYER_STATE_DEFER: 2e3, SIGNAL_REQUEST_WATCH_INTERVAL: 1e3, FILEPATH_LENMAX: 255, DUALSTREAM_OPERATION_CHECK: true, MEDIA_ELEMENT_EXISTS_DEPTH: 3, SHIM_CANDIDATE: false, LEAVE_MSG_TIMEOUT: 2e3, STATS_FILTER: { transportId: true, googTrackId: true } }, HE = {};
      function KE(e2, t2, i2) {
        return { sampleRate: e2, stereo: t2, bitrate: i2 };
      }
      function YE(e2, t2, i2, n2, r2) {
        return { width: e2, height: t2, frameRate: i2, bitrateMin: n2, bitrateMax: r2 };
      }
      function qE(e2, t2, i2, n2, r2) {
        return { width: { max: e2 }, height: { max: t2 }, frameRate: i2, bitrateMin: n2, bitrateMax: r2 };
      }
      function JE(e2, t2) {
        return { numSpatialLayers: e2, numTemporalLayers: t2 };
      }
      wE || (WE.WEBCS_DOMAIN = ["ap-web-1-oversea.agora.io", "ap-web-1-north-america.agora.io"], WE.WEBCS_DOMAIN_BACKUP_LIST = ["ap-web-2-oversea.agora.io", "ap-web-2-north-america.agora.io"], WE.PROXY_CS = ["proxy-ap-web-oversea.agora.io", "proxy-ap-web-america.agora.io"], WE.CDS_AP = ["cds-ap-web-oversea.agora.io", "cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], WE.ACCOUNT_REGISTER = ["sua-ap-web-oversea.agora.io", "sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], WE.UAP_AP = ["uap-ap-web-oversea.agora.io", "uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], WE.LOG_UPLOAD_SERVER = "logservice-oversea.agora.io", WE.EVENT_REPORT_DOMAIN = "statscollector-1-oversea.agora.io", WE.EVENT_REPORT_BACKUP_DOMAIN = "statscollector-2-oversea.agora.io", WE.PROXY_SERVER_TYPE3 = "webrtc-cloud-proxy.agora.io", WE.AREAS = ["NORTH_AMERICA", "OVERSEA"]);
      const XE = [[0, 1, 2, 3, 4, 5, 5], [0, 2, 2, 3, 4, 5, 5], [0, 3, 3, 3, 4, 5, 5], [0, 4, 4, 4, 4, 5, 5], [0, 5, 5, 5, 5, 5, 5]], zE = [], QE = [];
      function ZE(e2, t2) {
        return !!t2 && zE.some((i2) => i2.uid === e2 && i2.channelName === t2);
      }
      var $E = Et, em = Ht, tm = w, im = function(e2, t2, i2) {
        var n2 = $E(t2);
        n2 in e2 ? em.f(e2, n2, tm(0, i2)) : e2[n2] = i2;
      }, nm = Un, rm = bi, om = im, sm = h.Array, am = Math.max, cm = function(e2, t2, i2) {
        for (var n2 = rm(e2), r2 = nm(t2, n2), o2 = nm(void 0 === i2 ? n2 : i2, n2), s2 = sm(am(o2 - r2, 0)), a2 = 0; r2 < o2; r2++, a2++)
          om(s2, a2, e2[r2]);
        return s2.length = a2, s2;
      }, dm = cm, um = Math.floor, lm = function(e2, t2) {
        var i2 = e2.length, n2 = um(i2 / 2);
        return i2 < 8 ? hm(e2, t2) : pm(e2, lm(dm(e2, 0, n2), t2), lm(dm(e2, n2), t2), t2);
      }, hm = function(e2, t2) {
        for (var i2, n2, r2 = e2.length, o2 = 1; o2 < r2; ) {
          for (n2 = o2, i2 = e2[o2]; n2 && t2(e2[n2 - 1], i2) > 0; )
            e2[n2] = e2[--n2];
          n2 !== o2++ && (e2[n2] = i2);
        }
        return e2;
      }, pm = function(e2, t2, i2, n2) {
        for (var r2 = t2.length, o2 = i2.length, s2 = 0, a2 = 0; s2 < r2 || a2 < o2; )
          e2[s2 + a2] = s2 < r2 && a2 < o2 ? n2(t2[s2], i2[a2]) <= 0 ? t2[s2++] : i2[a2++] : s2 < r2 ? t2[s2++] : i2[a2++];
        return e2;
      }, _m = lm, Em = ee.match(/firefox\/(\d+)/i), mm = !!Em && +Em[1], fm = /MSIE|Trident/.test(ee), Sm = ee.match(/AppleWebKit\/(\d+)\./), Tm = !!Sm && +Sm[1], gm = Ii, Rm = d, Im = Ce, Cm = je, vm = bi, ym = wo, Am = i, Om = _m, Nm = Vi, bm = mm, wm = fm, Dm = ae, Pm = Tm, Lm = [], km = Rm(Lm.sort), Mm = Rm(Lm.push), Um = Am(function() {
        Lm.sort(void 0);
      }), xm = Am(function() {
        Lm.sort(null);
      }), Vm = Nm("sort"), jm = !Am(function() {
        if (Dm)
          return Dm < 70;
        if (!(bm && bm > 3)) {
          if (wm)
            return true;
          if (Pm)
            return Pm < 603;
          var e2, t2, i2, n2, r2 = "";
          for (e2 = 65; e2 < 76; e2++) {
            switch (t2 = String.fromCharCode(e2), e2) {
              case 66:
              case 69:
              case 70:
              case 72:
                i2 = 3;
                break;
              case 68:
              case 71:
                i2 = 4;
                break;
              default:
                i2 = 2;
            }
            for (n2 = 0; n2 < 47; n2++)
              Lm.push({ k: t2 + n2, v: i2 });
          }
          for (Lm.sort(function(e3, t3) {
            return t3.v - e3.v;
          }), n2 = 0; n2 < Lm.length; n2++)
            t2 = Lm[n2].k.charAt(0), r2.charAt(r2.length - 1) !== t2 && (r2 += t2);
          return "DGBEFHACIJK" !== r2;
        }
      });
      gm({ target: "Array", proto: true, forced: Um || !xm || !Vm || !jm }, { sort: function(e2) {
        void 0 !== e2 && Im(e2);
        var t2 = Cm(this);
        if (jm)
          return void 0 === e2 ? km(t2) : km(t2, e2);
        var i2, n2, r2 = [], o2 = vm(t2);
        for (n2 = 0; n2 < o2; n2++)
          n2 in t2 && Mm(r2, t2[n2]);
        for (Om(r2, function(e3) {
          return function(t3, i3) {
            return void 0 === i3 ? -1 : void 0 === t3 ? 1 : void 0 !== e3 ? +e3(t3, i3) || 0 : ym(t3) > ym(i3) ? 1 : -1;
          };
        }(e2)), i2 = r2.length, n2 = 0; n2 < i2; )
          t2[n2] = r2[n2++];
        for (; n2 < o2; )
          delete t2[n2++];
        return t2;
      } });
      var Fm = Hi("Array").sort, Bm = u, Gm = Fm, Wm = Array.prototype, Hm = function(e2) {
        var t2 = e2.sort;
        return e2 === Wm || Bm(Wm, e2) && t2 === Wm.sort ? Gm : t2;
      };
      function Km(e2, t2) {
        if ("boolean" != typeof e2)
          throw new SE(fE.INVALID_PARAMS, "Invalid ".concat(t2, ": The value is of the boolean type."));
      }
      function Ym(e2, t2, i2) {
        if (i2.includes(e2))
          return;
        throw new SE(fE.INVALID_PARAMS, "".concat(t2, " can only be set as ").concat(JSON.stringify(i2)));
      }
      function qm(e2, t2) {
        let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e4, r2 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
        if (e2 < i2 || e2 > n2 || r2 && !tf(e2)) {
          throw new SE(fE.INVALID_PARAMS, "invalid ".concat(t2, ": the value range is [").concat(i2, ", ").concat(n2, "]. integer only"));
        }
      }
      function Jm(e2, t2) {
        if ("number" != typeof e2) {
          if (!(e2.min || e2.max || e2.ideal || e2.exact)) {
            throw new SE(fE.INVALID_PARAMS, "".concat(t2, " is not a valid ConstrainLong"));
          }
          void 0 !== e2.min && qm(e2.min, "".concat(t2, ".min"), 0, 1 / 0), void 0 !== e2.max && qm(e2.max, "".concat(t2, ".max"), 1, 1 / 0), void 0 !== e2.exact && qm(e2.exact, "".concat(t2, ".exact"), 1, 1 / 0), void 0 !== e2.ideal && qm(e2.ideal, "".concat(t2, ".ideal"), 1, 1 / 0);
        } else
          qm(e2, t2, 1, 1 / 0);
      }
      function Xm(e2, t2) {
        let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 255, r2 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
        if (null == e2)
          throw new SE(fE.INVALID_PARAMS, "".concat(t2 || "param", " cannot be empty"));
        if (!ef(e2, i2, n2, r2))
          throw new SE(fE.INVALID_PARAMS, "Invalid ".concat(t2 || "string param", ": Length of the string: [").concat(i2, ",").concat(n2, "].").concat(r2 ? " ASCII characters only." : ""));
      }
      function zm(e2, t2) {
        if (!Array.isArray(e2))
          throw new SE(fE.INVALID_PARAMS, "".concat(t2, " should be an array"));
      }
      function Qm(e2) {
        if ("string" != typeof e2 || !/^[a-zA-Z0-9 \!\#\$\%\&\(\)\+\-\:\;\<\=\.\>\?\@\[\]\^\_\{\}\|\~\,]{1,64}$/.test(e2))
          throw OE.error("Invalid Channel Name ".concat(e2)), new SE(fE.INVALID_PARAMS, "The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,");
      }
      function Zm(e2) {
        if (!(t2 = e2, "number" == typeof t2 && Math.floor(t2) === t2 && 0 <= t2 && t2 <= 4294967295 || ef(e2, 1, 255)))
          throw OE.error("Invalid UID ".concat(e2, " ").concat(typeof e2)), new SE(fE.INVALID_PARAMS, "[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]");
        var t2;
        "string" == typeof e2 && OE.warning("You input a string as the user ID, to ensure better end-user experience, Agora highly suggests not using a string as the user ID.");
      }
      function $m(e2) {
        return null == e2;
      }
      function ef(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 255, n2 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
        return "string" == typeof e2 && e2.length <= i2 && e2.length >= t2 && (!n2 || nf(e2));
      }
      function tf(e2) {
        return "number" == typeof e2 && e2 % 1 == 0;
      }
      function nf(e2) {
        if ("string" != typeof e2)
          return false;
        for (let t2 = 0; t2 < e2.length; t2 += 1) {
          const i2 = e2.charCodeAt(t2);
          if (i2 < 0 || i2 > 255)
            return false;
        }
        return true;
      }
      let rf, of, sf;
      !function(e2) {
        e2.FREE = "free", e2.UPLOADING = "uploading";
      }(rf || (rf = {})), function(e2) {
        e2[e2.MISC = 0] = "MISC", e2[e2.INTERNAL_EVENT = 1] = "INTERNAL_EVENT", e2[e2.PUBLIC_EVENT = 2] = "PUBLIC_EVENT", e2[e2.WEB_EVENT = 3] = "WEB_EVENT", e2[e2.INTERNAL_API = 4] = "INTERNAL_API", e2[e2.WEB_API = 5] = "WEB_API", e2[e2.PUBLIC_API = 6] = "PUBLIC_API";
      }(of || (of = {})), function(e2) {
        e2.NONE = "none", e2.INIT = "init", e2.CANPLAY = "canplay", e2.PLAYING = "playing", e2.PAUSED = "paused", e2.SUSPEND = "suspend", e2.STALLED = "stalled", e2.WAITING = "waiting", e2.ERROR = "error", e2.DESTROYED = "destroyed", e2.ABORT = "abort", e2.ENDED = "ended", e2.EMPTIED = "emptied", e2.LOADEDDATA = "loadeddata";
      }(sf || (sf = {}));
      const af = { uninit: 100, none: 110, init: 120, loadeddata: 130, canplay: 200, playing: 210, paused: 220, suspend: 300, stalled: 310, waiting: 320, error: 330, destroyed: 340, abort: 350, ended: 360, emptied: 370 };
      function cf(e2) {
        return Xm(e2.reportId, "params.reportId", 0, 100, false), Xm(e2.category, "params.category", 0, 100, false), Xm(e2.event, "params.event", 0, 100, false), Xm(e2.label, "params.label", 0, 100, false), qm(e2.value, "params.value", Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, false), true;
      }
      const df = { sid: "", lts: 0, success: null, cname: null, uid: null, peer: null, cid: null, elapse: null, extend: null, vid: 0 };
      let uf, lf, hf, pf, _f, Ef, mf, ff, Sf, Tf, gf, Rf, If, Cf, vf, yf, Af, Of, Nf, bf, wf, Df, Pf, Lf;
      function kf(e2) {
        return qm(e2.timeout, "config.timeout", 0, 1e5), qm(e2.timeoutFactor, "config.timeoutFactor", 0, 100, false), qm(e2.maxRetryCount, "config.maxRetryConfig", 0, 1 / 0), qm(e2.maxRetryTimeout, "config.maxRetryTimeout", 0, 1 / 0), true;
      }
      function Mf(e2) {
        return Ym(e2.codec, "config.codec", ["vp8", "vp9", "av1", "h264", "h265"]), Ym(e2.mode, "config.mode", ["rtc", "live"]), void 0 !== e2.audioCodec && Ym(e2.audioCodec, "config.audioCodec", ["opus", "pcmu", "pcma", "g722"]), void 0 !== e2.proxyServer && Xm(e2.proxyServer, "config.proxyServer", 1, 1e4), void 0 !== e2.turnServer && xf(e2.turnServer), void 0 !== e2.httpRetryConfig && kf(e2.httpRetryConfig), void 0 !== e2.websocketRetryConfig && kf(e2.websocketRetryConfig), true;
      }
      function Uf(e2) {
        if (!Array.isArray(e2) || e2.length < 1)
          return false;
        try {
          e2.forEach((e3) => {
            if (!e3.urls)
              throw Error();
          });
        } catch (e3) {
          return false;
        }
        return true;
      }
      function xf(e2) {
        return Xm(e2.turnServerURL, "turnServerURL"), Xm(e2.username, "username"), Xm(e2.password, "password"), e2.udpport && qm(e2.udpport, "udpport", 1, 99999, true), e2.forceturn && Km(e2.forceturn, "forceturn"), e2.security && Km(e2.security, "security"), e2.tcpport && qm(e2.tcpport, "tcpport", 1, 99999, true), true;
      }
      function Vf(e2) {
        return void 0 !== e2.level && Ym(e2.level, "level", [1, 2, 3]), true;
      }
      !function(e2) {
        e2.PUBLISH = "publish", e2.SUBSCRIBE = "subscribe", e2.WS_COMPRESSOR_INIT = "ws_compressor_init", e2.SESSION_INIT = "session_init", e2.JOIN_CHOOSE_SERVER = "join_choose_server", e2.REQ_USER_ACCOUNT = "req_user_account", e2.JOIN_GATEWAY = "join_gateway", e2.REJOIN_GATEWAY = "rejoin_gateway", e2.STREAM_SWITCH = "stream_switch", e2.REQUEST_PROXY_WORKER_MANAGER = "request_proxy_worker_manager", e2.REQUEST_PROXY_APPCENTER = "request_proxy_appcenter", e2.FIRST_VIDEO_RECEIVED = "first_video_received", e2.FIRST_AUDIO_RECEIVED = "first_audio_received", e2.FIRST_VIDEO_DECODE = "first_video_decode", e2.FIRST_AUDIO_DECODE = "first_audio_decode", e2.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e2.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e2.ON_UPDATE_STREAM = "on_update_stream", e2.ON_REMOVE_STREAM = "on_remove_stream", e2.USER_ANALYTICS = "req_user_analytics", e2.PC_STATS = "pc_stats";
      }(uf || (uf = {})), function(e2) {
        e2.SESSION = "io.agora.pb.Wrtc.Session", e2.JOIN_CHOOSE_SERVER = "io.agora.pb.Wrtc.JoinChooseServer", e2.REQ_USER_ACCOUNT = "io.agora.pb.Wrtc.ReqUserAccount", e2.JOIN_GATEWAY = "io.agora.pb.Wrtc.JoinGateway", e2.RE_JOIN_GATEWAY = "io.agora.pb.Wrtc.ReJoinGateway", e2.PUBLISH = "io.agora.pb.Wrtc.Publish", e2.SUBSCRIBE = "io.agora.pb.Wrtc.Subscribe", e2.WS_COMPRESSOR_INIT = "io.agora.pb.Wrtc.WsCompressorInit", e2.STREAM_SWITCH = "io.agora.pb.Wrtc.StreamSwitch", e2.AUDIO_SENDING_STOPPED = "io.agora.pb.Wrtc.AudioSendingStopped", e2.VIDEO_SENDING_STOPPED = "io.agora.pb.Wrtc.VideoSendingStopped", e2.REQUEST_PROXY_APPCENTER = "io.agora.pb.Wrtc.RequestProxyAppCenter", e2.REQUEST_PROXY_WORKER_MANAGER = "io.agora.pb.Wrtc.RequestProxyWorkerManager", e2.API_INVOKE = "io.agora.pb.Wrtc.ApiInvoke", e2.FIRST_VIDEO_RECEIVED = "io.agora.pb.Wrtc.FirstVideoReceived", e2.FIRST_AUDIO_RECEIVED = "io.agora.pb.Wrtc.FirstAudioReceived", e2.FIRST_VIDEO_DECODE = "io.agora.pb.Wrtc.FirstVideoDecode", e2.FIRST_AUDIO_DECODE = "io.agora.pb.Wrtc.FirstAudioDecode", e2.ON_ADD_AUDIO_STREAM = "io.agora.pb.Wrtc.OnAddAudioStream", e2.ON_ADD_VIDEO_STREAM = "io.agora.pb.Wrtc.OnAddVideoStream", e2.ON_UPDATE_STREAM = "io.agora.pb.Wrtc.OnUpdateStream", e2.ON_REMOVE_STREAM = "io.agora.pb.Wrtc.OnRemoveStream", e2.JOIN_CHANNEL_TIMEOUT = "io.agora.pb.Wrtc.JoinChannelTimeout", e2.PEER_PUBLISH_STATUS = "io.agora.pb.Wrtc.PeerPublishStatus", e2.WORKER_EVENT = "io.agora.pb.Wrtc.WorkerEvent", e2.AP_WORKER_EVENT = "io.agora.pb.Wrtc.APWorkerEvent", e2.JOIN_WEB_PROXY_AP = "io.agora.pb.Wrtc.JoinWebProxyAP", e2.WEBSOCKET_QUIT = "io.agora.pb.Wrtc.WebSocketQuit", e2.USER_ANALYTICS = "io.agora.pb.Wrtc.UserAnalytics", e2.AUTOPLAY_FAILED = "io.agora.pb.Wrtc.AutoplayFailed", e2.PC_STATS = "io.agora.pb.Wrtc.PCStats";
      }(lf || (lf = {})), function(e2) {
        e2[e2.WORKER_EVENT = 156] = "WORKER_EVENT", e2[e2.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT";
      }(hf || (hf = {})), function(e2) {
        e2[e2.SESSION = 26] = "SESSION", e2[e2.JOIN_CHOOSE_SERVER = 27] = "JOIN_CHOOSE_SERVER", e2[e2.REQ_USER_ACCOUNT = 196] = "REQ_USER_ACCOUNT", e2[e2.JOIN_GATEWAY = 28] = "JOIN_GATEWAY", e2[e2.PUBLISH = 30] = "PUBLISH", e2[e2.SUBSCRIBE = 29] = "SUBSCRIBE", e2[e2.WS_COMPRESSOR_INIT = 9430] = "WS_COMPRESSOR_INIT", e2[e2.STREAM_SWITCH = 32] = "STREAM_SWITCH", e2[e2.AUDIO_SENDING_STOPPED = 33] = "AUDIO_SENDING_STOPPED", e2[e2.VIDEO_SENDING_STOPPED = 34] = "VIDEO_SENDING_STOPPED", e2[e2.REQUEST_PROXY_APPCENTER = 35] = "REQUEST_PROXY_APPCENTER", e2[e2.REQUEST_PROXY_WORKER_MANAGER = 36] = "REQUEST_PROXY_WORKER_MANAGER", e2[e2.API_INVOKE = 41] = "API_INVOKE", e2[e2.FIRST_VIDEO_RECEIVED = 348] = "FIRST_VIDEO_RECEIVED", e2[e2.FIRST_AUDIO_RECEIVED = 349] = "FIRST_AUDIO_RECEIVED", e2[e2.FIRST_VIDEO_DECODE = 350] = "FIRST_VIDEO_DECODE", e2[e2.FIRST_AUDIO_DECODE = 351] = "FIRST_AUDIO_DECODE", e2[e2.ON_ADD_AUDIO_STREAM = 352] = "ON_ADD_AUDIO_STREAM", e2[e2.ON_ADD_VIDEO_STREAM = 353] = "ON_ADD_VIDEO_STREAM", e2[e2.ON_UPDATE_STREAM = 356] = "ON_UPDATE_STREAM", e2[e2.ON_REMOVE_STREAM = 355] = "ON_REMOVE_STREAM", e2[e2.JOIN_CHANNEL_TIMEOUT = 407] = "JOIN_CHANNEL_TIMEOUT", e2[e2.PEER_PUBLISH_STATUS = 408] = "PEER_PUBLISH_STATUS", e2[e2.WORKER_EVENT = 156] = "WORKER_EVENT", e2[e2.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT", e2[e2.JOIN_WEB_PROXY_AP = 700] = "JOIN_WEB_PROXY_AP", e2[e2.WEBSOCKET_QUIT = 671] = "WEBSOCKET_QUIT", e2[e2.USER_ANALYTICS = 1e4] = "USER_ANALYTICS", e2[e2.AUTOPLAY_FAILED = 9178] = "AUTOPLAY_FAILED";
      }(pf || (pf = {})), function(e2) {
        e2.CREATE_CLIENT = "createClient", e2.CHECK_SYSTEM_REQUIREMENTS = "checkSystemRequirements", e2.SET_AREA = "setArea", e2.CHECK_VIDEO_TRACK_IS_ACTIVE = "checkVideoTrackIsActive", e2.CHECK_AUDIO_TRACK_IS_ACTIVE = "checkAudioTrackIsActive", e2.CREATE_MIC_AUDIO_TRACK = "createMicrophoneAudioTrack", e2.CREATE_CUSTOM_AUDIO_TRACK = "createCustomAudioTrack", e2.CREATE_BUFFER_AUDIO_TRACK = "createBufferSourceAudioTrack", e2.CREATE_CAM_VIDEO_TRACK = "createCameraVideoTrack", e2.CREATE_CUSTOM_VIDEO_TRACK = "createCustomVideoTrack", e2.CREATE_MIC_AND_CAM_TRACKS = "createMicrophoneAndCameraTracks", e2.CREATE_SCREEN_VIDEO_TRACK = "createScreenVideoTrack", e2.SET_ENCRYPTION_CONFIG = "Client.setEncryptionConfig", e2.START_PROXY_SERVER = "Client.startProxyServer", e2.STOP_PROXY_SERVER = "Client.stopProxyServer", e2.SET_PROXY_SERVER = "Client.setProxyServer", e2.SET_TURN_SERVER = "Client.setTurnServer", e2.SET_CLIENT_ROLE = "Client.setClientRole", e2.SET_LOW_STREAM_PARAMETER = "Client.setLowStreamParameter", e2.ENABLE_DUAL_STREAM = "Client.enableDualStream", e2.DISABLE_DUAL_STREAM = "Client.disableDualStream", e2.JOIN = "Client.join", e2.LEAVE = "Client.leave", e2.PUBLISH = "Client.publish", e2.UNPUBLISH = "Client.unpublish", e2.SUBSCRIBE = "Client.subscribe", e2.MASS_SUBSCRIBE = "Client.massSubscribe", e2.MASS_UNSUBSCRIBE = "Client.massUnsubscribe", e2.UNSUBSCRIBE = "Client.unsubscribe", e2.RENEW_TOKEN = "Client.renewToken", e2.SET_REMOTE_VIDEO_STREAM_TYPE = "Client.setRemoteVideoStreamType", e2.SET_STREAM_FALLBACK_OPTION = "Client.setStreamFallbackOption", e2.ENABLE_AUDIO_VOLUME_INDICATOR = "Client.enableAudioVolumeIndicator", e2.SEND_CUSTOM_REPORT_MESSAGE = "Client.sendCustomReportMessage", e2.INSPECT_VIDEO_CONTENT = "Client.inspectVideoContent", e2.STOP_INSPECT_VIDEO_CONTENT = "Client.stopInspectVideoContent", e2.JOIN_FALLBACK_TO_PROXY = "Client._joinFallbackToProxy", e2.DATACHANNEL_FAILBACK = "Client._datachannelFailback", e2.ON_LIVE_STREAM_WARNING = "Client.onLiveStreamWarning", e2.ON_LIVE_STREAM_ERROR = "Client.onLiveStreamingError", e2.START_LIVE_STREAMING = "Client.startLiveStreaming", e2.SET_LIVE_TRANSCODING = "Client.setLiveTranscoding", e2.STOP_LIVE_STREAMING = "Client.stopLiveStreaming", e2.ADD_INJECT_STREAM_URL = "Client.addInjectStreamUrl", e2.REMOVE_INJECT_STREAM_URL = "Client.removeInjectStreamUrl", e2.START_CHANNEL_MEDIA_RELAY = "Client.startChannelMediaRelay", e2.UPDATE_CHANNEL_MEDIA_RELAY = "Client.updateChannelMediaRelay", e2.STOP_CHANNEL_MEDIA_RELAY = "Client.stopChannelMediaRelay", e2.REQUEST_CONFIG_DISTRIBUTE = "_config-distribute-request", e2.SET_CONFIG_DISTRIBUTE = "_configDistribute", e2.LOCAL_TRACK_SET_MUTED = "LocalTrack.setMute", e2.LOCAL_AUDIO_TRACK_PLAY = "LocalAudioTrack.play", e2.LOCAL_AUDIO_TRACK_PLAY_IN_ELEMENT = "LocalAudioTrack.playInElement", e2.LOCAL_AUDIO_TRACK_STOP = "LocalAudioTrack.stop", e2.LOCAL_AUDIO_TRACK_SET_VOLUME = "LocalAudioTrack.setVolume", e2.MIC_AUDIO_TRACK_SET_DEVICE = "MicrophoneAudioTrack.setDevice", e2.BUFFER_AUDIO_TRACK_START = "BufferSourceAudioTrack.startProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_STOP = "BufferSourceAudioTrack.stopProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_PAUSE = "BufferSourceAudioTrack.pauseProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_RESUME = "BufferSourceAudioTrack.resumeProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_SEEK = "BufferSourceAudioTrack.seekAudioBuffer", e2.LOCAL_VIDEO_TRACK_PLAY = "LocalVideoTrack.play", e2.LOCAL_VIDEO_TRACK_STOP = "LocalVideoTrack.stop", e2.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE = "LocalVideoTrack.getVideoElementVisibleStatus", e2.LOCAL_VIDEO_TRACK_BEAUTY = "LocalVideoTrack.setBeautyEffect", e2.CAM_VIDEO_TRACK_SET_DEVICE = "CameraVideoTrack.setDevice", e2.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG = "CameraVideoTrack.setEncoderConfiguration", e2.REMOTE_VIDEO_TRACK_PLAY = "RemoteVideoTrack.play", e2.REMOTE_VIDEO_TRACK_STOP = "RemoteVideoTrack.stop", e2.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE = "RemoteVideoTrack.getVideoElementVisibleStatus", e2.REMOTE_AUDIO_TRACK_PLAY = "RemoteAudioTrack.play", e2.REMOTE_AUDIO_TRACK_STOP = "RemoteAudioTrack.stop", e2.REMOTE_AUDIO_SET_VOLUME = "RemoteAudioTrack.setVolume", e2.REMOTE_AUDIO_SET_OUTPUT_DEVICE = "RemoteAudioTrack.setOutputDevice", e2.GET_MEDIA_STREAM_TRACK = "Track.getMediaStreamTrack", e2.STREAM_TYPE_CHANGE = "streamTypeChange", e2.CONNECTION_STATE_CHANGE = "connectionStateChange", e2.LOAD_CONFIG_FROM_LOCALSTORAGE = "loadConfigFromLocalStorage", e2.IMAGE_MODERATION_UPLOAD = "imageModerationUpload";
      }(_f || (_f = {})), function(e2) {
        e2.TRACER = "tracer";
      }(Ef || (Ef = {})), function(e2) {
        e2.IDLE = "IDLE", e2.INITING = "INITING", e2.INITEND = "INITEND";
      }(mf || (mf = {})), function(e2) {
        e2.STATE_CHANGE = "state_change", e2.RECORDING_DEVICE_CHANGED = "recordingDeviceChanged", e2.PLAYOUT_DEVICE_CHANGED = "playoutDeviceChanged", e2.CAMERA_DEVICE_CHANGED = "cameraDeviceChanged";
      }(ff || (ff = {})), function(e2) {
        e2[e2.ACCESS_POINT = 101] = "ACCESS_POINT", e2[e2.UNILBS = 201] = "UNILBS", e2[e2.STRING_UID_ALLOCATOR = 901] = "STRING_UID_ALLOCATOR";
      }(Sf || (Sf = {})), function(e2) {
        e2[e2.IIIEGAL_APPID = 1] = "IIIEGAL_APPID", e2[e2.IIIEGAL_UID = 2] = "IIIEGAL_UID", e2[e2.INTERNAL_ERROR = 3] = "INTERNAL_ERROR";
      }(Tf || (Tf = {})), function(e2) {
        e2[e2.INVALID_VENDOR_KEY = 5] = "INVALID_VENDOR_KEY", e2[e2.INVALID_CHANNEL_NAME = 7] = "INVALID_CHANNEL_NAME", e2[e2.INTERNAL_ERROR = 8] = "INTERNAL_ERROR", e2[e2.NO_AUTHORIZED = 9] = "NO_AUTHORIZED", e2[e2.DYNAMIC_KEY_TIMEOUT = 10] = "DYNAMIC_KEY_TIMEOUT", e2[e2.NO_ACTIVE_STATUS = 11] = "NO_ACTIVE_STATUS", e2[e2.DYNAMIC_KEY_EXPIRED = 13] = "DYNAMIC_KEY_EXPIRED", e2[e2.STATIC_USE_DYNAMIC_KEY = 14] = "STATIC_USE_DYNAMIC_KEY", e2[e2.DYNAMIC_USE_STATIC_KEY = 15] = "DYNAMIC_USE_STATIC_KEY", e2[e2.USER_OVERLOAD = 16] = "USER_OVERLOAD", e2[e2.FORBIDDEN_REGION = 18] = "FORBIDDEN_REGION", e2[e2.CANNOT_MEET_AREA_DEMAND = 19] = "CANNOT_MEET_AREA_DEMAND";
      }(gf || (gf = {})), function(e2) {
        e2[e2.NO_FLAG_SET = 100] = "NO_FLAG_SET", e2[e2.FLAG_SET_BUT_EMPTY = 101] = "FLAG_SET_BUT_EMPTY", e2[e2.INVALID_FALG_SET = 102] = "INVALID_FALG_SET", e2[e2.FLAG_SET_BUT_NO_RE = 103] = "FLAG_SET_BUT_NO_RE", e2[e2.INVALID_SERVICE_ID = 104] = "INVALID_SERVICE_ID", e2[e2.NO_SERVICE_AVAILABLE = 200] = "NO_SERVICE_AVAILABLE", e2[e2.NO_SERVICE_AVAILABLE_P2P = 201] = "NO_SERVICE_AVAILABLE_P2P", e2[e2.NO_SERVICE_AVAILABLE_VOICE = 202] = "NO_SERVICE_AVAILABLE_VOICE", e2[e2.NO_SERVICE_AVAILABLE_WEBRTC = 203] = "NO_SERVICE_AVAILABLE_WEBRTC", e2[e2.NO_SERVICE_AVAILABLE_CDS = 204] = "NO_SERVICE_AVAILABLE_CDS", e2[e2.NO_SERVICE_AVAILABLE_CDN = 205] = "NO_SERVICE_AVAILABLE_CDN", e2[e2.NO_SERVICE_AVAILABLE_TDS = 206] = "NO_SERVICE_AVAILABLE_TDS", e2[e2.NO_SERVICE_AVAILABLE_REPORT = 207] = "NO_SERVICE_AVAILABLE_REPORT", e2[e2.NO_SERVICE_AVAILABLE_APP_CENTER = 208] = "NO_SERVICE_AVAILABLE_APP_CENTER", e2[e2.NO_SERVICE_AVAILABLE_ENV0 = 209] = "NO_SERVICE_AVAILABLE_ENV0", e2[e2.NO_SERVICE_AVAILABLE_VOET = 210] = "NO_SERVICE_AVAILABLE_VOET", e2[e2.NO_SERVICE_AVAILABLE_STRING_UID = 211] = "NO_SERVICE_AVAILABLE_STRING_UID", e2[e2.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS = 212] = "NO_SERVICE_AVAILABLE_WEBRTC_UNILBS", e2[e2.NO_SERVICE_AVAILABLE_UNILBS_FLV = 213] = "NO_SERVICE_AVAILABLE_UNILBS_FLV";
      }(Rf || (Rf = {})), function(e2) {
        e2[e2.K_TIMESTAMP_EXPIRED = 2] = "K_TIMESTAMP_EXPIRED", e2[e2.K_CHANNEL_PERMISSION_INVALID = 3] = "K_CHANNEL_PERMISSION_INVALID", e2[e2.K_CERTIFICATE_INVALID = 4] = "K_CERTIFICATE_INVALID", e2[e2.K_CHANNEL_NAME_EMPTY = 5] = "K_CHANNEL_NAME_EMPTY", e2[e2.K_CHANNEL_NOT_FOUND = 6] = "K_CHANNEL_NOT_FOUND", e2[e2.K_TICKET_INVALID = 7] = "K_TICKET_INVALID", e2[e2.K_CHANNEL_CONFLICTED = 8] = "K_CHANNEL_CONFLICTED", e2[e2.K_SERVICE_NOT_READY = 9] = "K_SERVICE_NOT_READY", e2[e2.K_SERVICE_TOO_HEAVY = 10] = "K_SERVICE_TOO_HEAVY", e2[e2.K_UID_BANNED = 14] = "K_UID_BANNED", e2[e2.K_IP_BANNED = 15] = "K_IP_BANNED", e2[e2.K_CHANNEL_BANNED = 16] = "K_CHANNEL_BANNED", e2[e2.WARN_NO_AVAILABLE_CHANNEL = 103] = "WARN_NO_AVAILABLE_CHANNEL", e2[e2.WARN_LOOKUP_CHANNEL_TIMEOUT = 104] = "WARN_LOOKUP_CHANNEL_TIMEOUT", e2[e2.WARN_LOOKUP_CHANNEL_REJECTED = 105] = "WARN_LOOKUP_CHANNEL_REJECTED", e2[e2.WARN_OPEN_CHANNEL_TIMEOUT = 106] = "WARN_OPEN_CHANNEL_TIMEOUT", e2[e2.WARN_OPEN_CHANNEL_REJECTED = 107] = "WARN_OPEN_CHANNEL_REJECTED", e2[e2.WARN_REQUEST_DEFERRED = 108] = "WARN_REQUEST_DEFERRED", e2[e2.ERR_DYNAMIC_KEY_TIMEOUT = 109] = "ERR_DYNAMIC_KEY_TIMEOUT", e2[e2.ERR_NO_AUTHORIZED = 110] = "ERR_NO_AUTHORIZED", e2[e2.ERR_VOM_SERVICE_UNAVAILABLE = 111] = "ERR_VOM_SERVICE_UNAVAILABLE", e2[e2.ERR_NO_CHANNEL_AVAILABLE_CODE = 112] = "ERR_NO_CHANNEL_AVAILABLE_CODE", e2[e2.ERR_MASTER_VOCS_UNAVAILABLE = 114] = "ERR_MASTER_VOCS_UNAVAILABLE", e2[e2.ERR_INTERNAL_ERROR = 115] = "ERR_INTERNAL_ERROR", e2[e2.ERR_NO_ACTIVE_STATUS = 116] = "ERR_NO_ACTIVE_STATUS", e2[e2.ERR_INVALID_UID = 117] = "ERR_INVALID_UID", e2[e2.ERR_DYNAMIC_KEY_EXPIRED = 118] = "ERR_DYNAMIC_KEY_EXPIRED", e2[e2.ERR_STATIC_USE_DYANMIC_KE = 119] = "ERR_STATIC_USE_DYANMIC_KE", e2[e2.ERR_DYNAMIC_USE_STATIC_KE = 120] = "ERR_DYNAMIC_USE_STATIC_KE", e2[e2.ERR_NO_VOCS_AVAILABLE = 2e3] = "ERR_NO_VOCS_AVAILABLE", e2[e2.ERR_NO_VOS_AVAILABLE = 2001] = "ERR_NO_VOS_AVAILABLE", e2[e2.ERR_JOIN_CHANNEL_TIMEOUT = 2002] = "ERR_JOIN_CHANNEL_TIMEOUT", e2[e2.ERR_REPEAT_JOIN_CHANNEL = 2003] = "ERR_REPEAT_JOIN_CHANNEL", e2[e2.ERR_JOIN_BY_MULTI_IP = 2004] = "ERR_JOIN_BY_MULTI_IP", e2[e2.ERR_NOT_JOINED = 2011] = "ERR_NOT_JOINED", e2[e2.ERR_REPEAT_JOIN_REQUEST = 2012] = "ERR_REPEAT_JOIN_REQUEST", e2[e2.ERR_INVALID_VENDOR_KEY = 2013] = "ERR_INVALID_VENDOR_KEY", e2[e2.ERR_INVALID_CHANNEL_NAME = 2014] = "ERR_INVALID_CHANNEL_NAME", e2[e2.ERR_INVALID_STRINGUID = 2015] = "ERR_INVALID_STRINGUID", e2[e2.ERR_TOO_MANY_USERS = 2016] = "ERR_TOO_MANY_USERS", e2[e2.ERR_SET_CLIENT_ROLE_TIMEOUT = 2017] = "ERR_SET_CLIENT_ROLE_TIMEOUT", e2[e2.ERR_SET_CLIENT_ROLE_NO_PERMISSION = 2018] = "ERR_SET_CLIENT_ROLE_NO_PERMISSION", e2[e2.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE = 2019] = "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", e2[e2.ERR_PUBLISH_REQUEST_INVALID = 2020] = "ERR_PUBLISH_REQUEST_INVALID", e2[e2.ERR_SUBSCRIBE_REQUEST_INVALID = 2021] = "ERR_SUBSCRIBE_REQUEST_INVALID", e2[e2.ERR_NOT_SUPPORTED_MESSAGE = 2022] = "ERR_NOT_SUPPORTED_MESSAGE", e2[e2.ERR_ILLEAGAL_PLUGIN = 2023] = "ERR_ILLEAGAL_PLUGIN", e2[e2.ERR_REJOIN_TOKEN_INVALID = 2024] = "ERR_REJOIN_TOKEN_INVALID", e2[e2.ERR_REJOIN_USER_NOT_JOINED = 2025] = "ERR_REJOIN_USER_NOT_JOINED", e2[e2.ERR_INVALID_OPTIONAL_INFO = 2027] = "ERR_INVALID_OPTIONAL_INFO", e2[e2.ILLEGAL_AES_PASSWORD = 2028] = "ILLEGAL_AES_PASSWORD", e2[e2.ILLEGAL_CLIENT_ROLE_LEVEL = 2029] = "ILLEGAL_CLIENT_ROLE_LEVEL", e2[e2.ERR_TOO_MANY_BROADCASTERS = 2031] = "ERR_TOO_MANY_BROADCASTERS", e2[e2.ERR_TOO_MANY_SUBSCRIBERS = 2032] = "ERR_TOO_MANY_SUBSCRIBERS", e2[e2.ERR_LICENSE_MISSING = 32769] = "ERR_LICENSE_MISSING", e2[e2.ERR_LICENSE_EXPIRED = 32771] = "ERR_LICENSE_EXPIRED", e2[e2.ERR_LICENSE_MINUTES_EXCEEDED = 32773] = "ERR_LICENSE_MINUTES_EXCEEDED", e2[e2.ERR_LICENSE_PERIOD_INVALID = 32774] = "ERR_LICENSE_PERIOD_INVALID", e2[e2.ERR_LICENSE_MULTIPLE_SDK_SERVICE = 32778] = "ERR_LICENSE_MULTIPLE_SDK_SERVICE", e2[e2.ERR_LICENSE_ILLEGAL = 32783] = "ERR_LICENSE_ILLEGAL", e2[e2.ERR_TEST_RECOVER = 9e3] = "ERR_TEST_RECOVER", e2[e2.ERR_TEST_TRYNEXT = 9001] = "ERR_TEST_TRYNEXT", e2[e2.ERR_TEST_RETRY = 9002] = "ERR_TEST_RETRY";
      }(If || (If = {})), function(e2) {
        e2[e2.AUDIENCE_LEVEL_LOW_LATENCY = 1] = "AUDIENCE_LEVEL_LOW_LATENCY", e2[e2.AUDIENCE_LEVEL_ULTRA_LOW_LATENCY = 2] = "AUDIENCE_LEVEL_ULTRA_LOW_LATENCY", e2[e2.AUDIENCE_LEVEL_SYNC_LATENCY = 3] = "AUDIENCE_LEVEL_SYNC_LATENCY";
      }(Cf || (Cf = {})), function(e2) {
        e2.LEAVE = "LEAVE", e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.UID_BANNED = "UID_BANNED", e2.IP_BANNED = "IP_BANNED", e2.CHANNEL_BANNED = "CHANNEL_BANNED", e2.FALLBACK = "FALLBACK", e2.LICENSE_MISSING = "LICENSE_MISSING", e2.LICENSE_EXPIRED = "LICENSE_EXPIRED", e2.LICENSE_MINUTES_EXCEEDED = "LICENSE_MINUTES_EXCEEDED", e2.LICENSE_PERIOD_INVALID = "LICENSE_PERIOD_INVALID", e2.LICENSE_MULTIPLE_SDK_SERVICE = "LICENSE_MULTIPLE_SDK_SERVICE", e2.LICENSE_ILLEGAL = "LICENSE_ILLEGAL";
      }(vf || (vf = {})), function(e2) {
        e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.MEDIA_RECONNECT_START = "media-reconnect-start", e2.MEDIA_RECONNECT_END = "media-reconnect-end", e2.IS_USING_CLOUD_PROXY = "is-using-cloud-proxy", e2.USER_JOINED = "user-joined", e2.USER_LEAVED = "user-left", e2.USER_PUBLISHED = "user-published", e2.USER_UNPUBLISHED = "user-unpublished", e2.USER_INFO_UPDATED = "user-info-updated", e2.CLIENT_BANNED = "client-banned", e2.CHANNEL_MEDIA_RELAY_STATE = "channel-media-relay-state", e2.CHANNEL_MEDIA_RELAY_EVENT = "channel-media-relay-event", e2.VOLUME_INDICATOR = "volume-indicator", e2.CRYPT_ERROR = "crypt-error", e2.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "token-privilege-will-expire", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "token-privilege-did-expire", e2.NETWORK_QUALITY = "network-quality", e2.STREAM_TYPE_CHANGED = "stream-type-changed", e2.STREAM_FALLBACK = "stream-fallback", e2.RECEIVE_METADATA = "receive-metadata", e2.STREAM_MESSAGE = "stream-message", e2.LIVE_STREAMING_ERROR = "live-streaming-error", e2.LIVE_STREAMING_WARNING = "live-streaming-warning", e2.INJECT_STREAM_STATUS = "stream-inject-status", e2.EXCEPTION = "exception", e2.ERROR = "error", e2.P2P_LOST = "p2p_lost", e2.JOIN_FALLBACK_TO_PROXY = "join-fallback-to-proxy", e2.CHANNEL_FALLBACK_TO_WEBSOCKET = "channel-fallback-to-websocket", e2.MEDIA_CONNECTION_TYPE_CHANGE = "media-connection-type-change", e2.PUBLISHED_USER_LIST = "published-user-list", e2.CONTENT_INSPECT_CONNECTION_STATE_CHANGE = "content-inspect-connection-state-change", e2.CONTENT_INSPECT_ERROR = "content-inspect-error", e2.CONTENT_INSPECT_RESULT = "content-inspect-result", e2.IMAGE_MODERATION_CONNECTION_STATE_CHANGE = "image-moderation-connection-state-change";
      }(yf || (yf = {})), function(e2) {
        e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.MULTI_IP = "MULTI_IP", e2.TIMEOUT = "TIMEOUT", e2.OFFLINE = "OFFLINE", e2.LEAVE = "LEAVE", e2.P2P_FAILED = "P2P_FAILED", e2.FALLBACK = "FALLBACK";
      }(Af || (Af = {})), function(e2) {
        e2.CONNECTING = "connecting", e2.CONNECTED = "connected", e2.RECONNECTING = "reconnecting", e2.CLOSED = "closed";
      }(Of || (Of = {})), function(e2) {
        e2.WS_CONNECTED = "ws_connected", e2.WS_RECONNECTING = "ws_reconnecting", e2.WS_CLOSED = "ws_closed", e2.WS_RECONNECT_WAITTING_FINISH = "ws_reconnect_waitting_finish", e2.WS_RECONNECT_CREATE_CONNECTION = "ws_reconnect_create_connection", e2.ON_BINARY_DATA = "on_binary_data", e2.REQUEST_RECOVER = "request_recover", e2.REQUEST_JOIN_INFO = "request_join_info", e2.REQUEST_REJOIN_INFO = "req_rejoin_info", e2.IS_P2P_DISCONNECTED = "is_p2p_dis", e2.DISCONNECT_P2P = "dis_p2p", e2.ABORT_P2P_EXECUTION = "abort_p2p_execution", e2.NEED_RENEW_SESSION = "need-sid", e2.REPORT_JOIN_GATEWAY = "report_join_gateway", e2.REQUEST_TIMEOUT = "request_timeout", e2.REQUEST_SUCCESS = "request_success", e2.JOIN_RESPONSE = "join_response", e2.DATACHANNEL_PRECONNECT = "datachannel_preconnect", e2.DATACHANNEL_CONNECTING = "datachannel_connecting", e2.DATACHANNEL_FAILBACK = "datachannel_failback";
      }(Nf || (Nf = {})), function(e2) {
        e2.PING = "ping", e2.PING_BACK = "ping_back", e2.JOIN = "join_v3", e2.REJOIN = "rejoin_v3", e2.LEAVE = "leave", e2.SET_CLIENT_ROLE = "set_client_role", e2.PUBLISH = "publish", e2.UNPUBLISH = "unpublish", e2.SUBSCRIBE = "subscribe", e2.SUBSCRIBE_STREAMS = "subscribe_streams", e2.UNSUBSCRIBE = "unsubscribe", e2.UNSUBSCRIBE_STREAMS = "unsubscribe_streams", e2.SUBSCRIBE_CHANGE = "subscribe_change", e2.TRAFFIC_STATS = "traffic_stats", e2.RENEW_TOKEN = "renew_token", e2.SWITCH_VIDEO_STREAM = "switch_video_stream", e2.DEFAULT_VIDEO_STREAM = "default_video_stream", e2.SET_FALLBACK_OPTION = "set_fallback_option", e2.GATEWAY_INFO = "gateway_info", e2.CONTROL = "control", e2.SEND_METADATA = "send_metadata", e2.DATA_STREAM = "data_stream", e2.PICK_SVC_LAYER = "pick_svc_layer", e2.RESTART_ICE = "restart_ice", e2.CONNECT_PC = "connect_pc", e2.SET_VIDEO_PROFILE = "set_video_profile", e2.SET_PARAMETER = "set_parameter";
      }(bf || (bf = {})), function(e2) {
        e2.PUBLISH_STATS = "publish_stats", e2.PUBLISH_RELATED_STATS = "publish_related_stats", e2.SUBSCRIBE_STATS = "subscribe_stats", e2.SUBSCRIBE_RELATED_STATS = "subscribe_related_stats", e2.WS_INFLATE_DATA_LENGTH = "ws_inflate_data_length", e2.DENOISER_STATS = "denoiser_stats", e2.TRANSPORT_STATS = "transport_stats", e2.EXTENSION_USAGE_STATS = "extension_usage_stats";
      }(wf || (wf = {})), function(e2) {
        e2.ON_USER_ONLINE = "on_user_online", e2.ON_USER_OFFLINE = "on_user_offline", e2.ON_STREAM_FALLBACK_UPDATE = "on_stream_fallback_update", e2.ON_PUBLISH_STREAM = "on_publish_stream", e2.ON_UPLINK_STATS = "on_uplink_stats", e2.ON_P2P_LOST = "on_p2p_lost", e2.ON_REMOVE_STREAM = "on_remove_stream", e2.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e2.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e2.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "on_token_privilege_will_expire", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "on_token_privilege_did_expire", e2.ON_USER_BANNED = "on_user_banned", e2.ON_USER_LICENSE_BANNED = "on_user_license_banned", e2.ON_NOTIFICATION = "on_notification", e2.ON_CRYPT_ERROR = "on_crypt_error", e2.MUTE_AUDIO = "mute_audio", e2.MUTE_VIDEO = "mute_video", e2.UNMUTE_AUDIO = "unmute_audio", e2.UNMUTE_VIDEO = "unmute_video", e2.ON_P2P_OK = "on_p2p_ok", e2.RECEIVE_METADATA = "receive_metadata", e2.ON_DATA_STREAM = "on_data_stream", e2.ENABLE_LOCAL_VIDEO = "enable_local_video", e2.DISABLE_LOCAL_VIDEO = "disable_local_video", e2.ENABLE_LOCAL_AUDIO = "enable_local_audio", e2.DISABLE_LOCAL_AUDIO = "disable_local_audio", e2.ON_PUBLISHED_USER_LIST = "on_published_user_list";
      }(Df || (Df = {})), function(e2) {
        e2.CONNECTION_STATE_CHANGE = "CONNECTION_STATE_CHANGE", e2.NEED_ANSWER = "NEED_ANSWER", e2.NEED_RENEGOTIATE = "NEED_RENEGOTIATE", e2.P2P_LOST = "P2P_LOST", e2.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST", e2.NEED_UNPUB = "NEED_UNPUB", e2.NEED_UNSUB = "NEED_UNSUB", e2.NEED_UPLOAD = "NEED_UPLOAD", e2.NEED_CONTROL = "NEED_CONTROL", e2.START_RECONNECT = "START_RECONNECT", e2.END_RECONNECT = "END_RECONNECT", e2.NEED_SIGNAL_RTT = "NEED_SIGNAL_RTT";
      }(Pf || (Pf = {})), function(e2) {
        e2.AUDIO_SOURCE_STATE_CHANGE = "audio_source_state_change", e2.RECEIVE_TRACK_BUFFER = "receive_track_buffer", e2.ON_AUDIO_BUFFER = "on_audio_buffer", e2.UPDATE_SOURCE = "update_source";
      }(Lf || (Lf = {}));
      const jf = { sendVolumeLevel: 0, sendBitrate: 0, sendBytes: 0, sendPackets: 0, sendPacketsLost: 0, currentPacketLossRate: 0 }, Ff = { sendBytes: 0, sendBitrate: 0, sendPackets: 0, sendPacketsLost: 0, sendResolutionHeight: 0, sendResolutionWidth: 0, captureResolutionHeight: 0, captureResolutionWidth: 0, targetSendBitrate: 0, totalDuration: 0, totalFreezeTime: 0, currentPacketLossRate: 0 }, Bf = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveLevel: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 }, Gf = { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 }, Wf = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, receiveResolutionHeight: 0, receiveResolutionWidth: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 };
      let Hf, Kf, Yf;
      !function(e2) {
        e2.CONNECTED = "websocket:connected", e2.RECONNECTING = "websocket:reconnecting", e2.WILL_RECONNECT = "websocket:will_reconnect", e2.CLOSED = "websocket:closed", e2.FAILED = "websocket:failed", e2.ON_MESSAGE = "websocket:on_message", e2.REQUEST_NEW_URLS = "websocket:request_new_urls", e2.RECONNECT_WAITTING_FINISH = "websocket:reconnect_waitting_finish", e2.RECONNECT_CREATE_CONNECTION = "websocket:reconnect_create_connection", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "websocket:on_token_privilege_did_expire";
      }(Hf || (Hf = {})), function(e2) {
        e2.TRANSCODE = "mix_streaming", e2.RAW = "raw_streaming", e2.INJECT = "inject_streaming";
      }(Kf || (Kf = {})), function(e2) {
        e2[e2.INJECT_STREAM_STATUS_START_SUCCESS = 0] = "INJECT_STREAM_STATUS_START_SUCCESS", e2[e2.INJECT_STREAM_STATUS_START_ALREADY_EXISTS = 1] = "INJECT_STREAM_STATUS_START_ALREADY_EXISTS", e2[e2.INJECT_STREAM_STATUS_START_UNAUTHORIZED = 2] = "INJECT_STREAM_STATUS_START_UNAUTHORIZED", e2[e2.INJECT_STREAM_STATUS_START_TIMEOUT = 3] = "INJECT_STREAM_STATUS_START_TIMEOUT", e2[e2.INJECT_STREAM_STATUS_START_FAILED = 4] = "INJECT_STREAM_STATUS_START_FAILED", e2[e2.INJECT_STREAM_STATUS_STOP_SUCCESS = 5] = "INJECT_STREAM_STATUS_STOP_SUCCESS", e2[e2.INJECT_STREAM_STATUS_STOP_NOT_FOUND = 6] = "INJECT_STREAM_STATUS_STOP_NOT_FOUND", e2[e2.INJECT_STREAM_STATUS_STOP_UNAUTHORIZED = 7] = "INJECT_STREAM_STATUS_STOP_UNAUTHORIZED", e2[e2.INJECT_STREAM_STATUS_STOP_TIMEOUT = 8] = "INJECT_STREAM_STATUS_STOP_TIMEOUT", e2[e2.INJECT_STREAM_STATUS_STOP_FAILED = 9] = "INJECT_STREAM_STATUS_STOP_FAILED", e2[e2.INJECT_STREAM_STATUS_BROKEN = 10] = "INJECT_STREAM_STATUS_BROKEN";
      }(Yf || (Yf = {}));
      const qf = { alpha: 1, height: 640, width: 360, x: 0, y: 0, zOrder: 0, audioChannel: 0 }, Jf = { x: 0, y: 0, width: 160, height: 160, zOrder: 255, alpha: 1 };
      function Xf(e2, t2) {
        Xm(e2.url, "".concat(t2, ".url"), 1, 1e3, false), $m(e2.x) || qm(e2.x, "".concat(t2, ".x"), 0, 1e4), $m(e2.y) || qm(e2.y, "".concat(t2, ".y"), 0, 1e4), $m(e2.width) || qm(e2.width, "".concat(t2, ".width"), 0, 1e4), $m(e2.height) || qm(e2.height, "".concat(t2, ".height"), 0, 1e4), $m(e2.zOrder) || qm(e2.zOrder, "".concat(t2, ".zOrder"), 0, 255), $m(e2.alpha) || qm(e2.alpha, "".concat(t2, ".alpha"), 0, 1, false);
      }
      const zf = { audioBitrate: 48, audioChannels: 1, audioSampleRate: 48e3, backgroundColor: 0, height: 360, lowLatency: false, videoBitrate: 400, videoCodecProfile: 100, videoCodecType: 1, videoFrameRate: 15, videoGop: 30, width: 640, images: [], userConfigs: [], userConfigExtraInfo: "" }, Qf = { audioBitrate: 48, audioChannels: 2, audioVolume: 100, audioSampleRate: 48e3, height: 0, width: 0, videoBitrate: 400, videoFramerate: 15, videoGop: 30 };
      let Zf, $f, eS, tS, iS, nS, rS, oS, sS, aS, cS, dS, uS, lS, hS, pS, _S, ES, mS, fS, SS;
      function TS(e2) {
        if (!e2.channelName)
          throw new SE(fE.INVALID_PARAMS, "invalid channelName in info");
        if ("number" != typeof e2.uid)
          throw new SE(fE.INVALID_PARAMS, "invalid uid in info, uid must be a number");
        return e2.token && Xm(e2.token, "info.token", 1, 2047), Zm(e2.uid), Qm(e2.channelName), true;
      }
      function gS(e2) {
        return Ym(e2, "mediaSource", ["screen", "window", "application"]), true;
      }
      !function(e2) {
        e2.WARNING = "@live_uap-warning", e2.ERROR = "@line_uap-error", e2.PUBLISH_STREAM_STATUS = "@live_uap-publish-status", e2.INJECT_STREAM_STATUS = "@live_uap-inject-status", e2.WORKER_STATUS = "@live_uap-worker-status", e2.REQUEST_NEW_ADDRESS = "@live_uap-request-address";
      }(Zf || (Zf = {})), function(e2) {
        e2.REQUEST_WORKER_MANAGER_LIST = "@live_req_worker_manager";
      }($f || ($f = {})), function(e2) {
        e2[e2.LIVE_STREAM_RESPONSE_SUCCEED = 200] = "LIVE_STREAM_RESPONSE_SUCCEED", e2[e2.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM = 454] = "LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM", e2[e2.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR = 450] = "LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_BAD_STREAM = 451] = "LIVE_STREAM_RESPONSE_BAD_STREAM", e2[e2.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR = 400] = "LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST = 404] = "LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST", e2[e2.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED = 456] = "LIVE_STREAM_RESPONSE_NOT_AUTHORIZED", e2[e2.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE = 457] = "LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE", e2[e2.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN = 429] = "LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN", e2[e2.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH = 452] = "LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH", e2[e2.LIVE_STREAM_RESPONSE_NOT_SUPPORTED = 453] = "LIVE_STREAM_RESPONSE_NOT_SUPPORTED", e2[e2.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM = 455] = "LIVE_STREAM_RESPONSE_MAX_STREAM_NUM", e2[e2.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR = 500] = "LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_WORKER_LOST = 501] = "LIVE_STREAM_RESPONSE_WORKER_LOST", e2[e2.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT = 502] = "LIVE_STREAM_RESPONSE_RESOURCE_LIMIT", e2[e2.LIVE_STREAM_RESPONSE_WORKER_QUIT = 503] = "LIVE_STREAM_RESPONSE_WORKER_QUIT", e2[e2.ERROR_FAIL_SEND_MESSAGE = 504] = "ERROR_FAIL_SEND_MESSAGE", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE = 30] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT = 31] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH = 32] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH", e2[e2.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN = 33] = "PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN";
      }(eS || (eS = {})), function(e2) {
        e2.CONNECT_FAILED = "connect failed", e2.CONNECT_TIMEOUT = "connect timeout", e2.WS_DISCONNECTED = "websocket disconnected", e2.REQUEST_TIMEOUT = "request timeout", e2.REQUEST_FAILED = "request failed", e2.WAIT_STATUS_TIMEOUT = "wait status timeout", e2.WAIT_STATUS_ERROR = "wait status error", e2.BAD_STATE = "bad state", e2.WS_ABORT = "ws abort", e2.AP_REQUEST_TIMEOUT = "AP request timeout", e2.AP_JSON_PARSE_ERROR = "AP json parse error", e2.AP_REQUEST_ERROR = "AP request error", e2.AP_REQUEST_ABORT = "AP request abort";
      }(tS || (tS = {})), function(e2) {
        e2[e2.SetSdkProfile = 0] = "SetSdkProfile", e2[e2.SetSourceChannel = 1] = "SetSourceChannel", e2[e2.SetSourceUserId = 2] = "SetSourceUserId", e2[e2.SetDestChannel = 3] = "SetDestChannel", e2[e2.StartPacketTransfer = 4] = "StartPacketTransfer", e2[e2.StopPacketTransfer = 5] = "StopPacketTransfer", e2[e2.UpdateDestChannel = 6] = "UpdateDestChannel", e2[e2.Reconnect = 7] = "Reconnect", e2[e2.SetVideoProfile = 8] = "SetVideoProfile";
      }(iS || (iS = {})), function(e2) {
        e2.NETWORK_DISCONNECTED = "NETWORK_DISCONNECTED", e2.NETWORK_CONNECTED = "NETWORK_CONNECTED", e2.PACKET_JOINED_SRC_CHANNEL = "PACKET_JOINED_SRC_CHANNEL", e2.PACKET_JOINED_DEST_CHANNEL = "PACKET_JOINED_DEST_CHANNEL", e2.PACKET_SENT_TO_DEST_CHANNEL = "PACKET_SENT_TO_DEST_CHANNEL", e2.PACKET_RECEIVED_VIDEO_FROM_SRC = "PACKET_RECEIVED_VIDEO_FROM_SRC", e2.PACKET_RECEIVED_AUDIO_FROM_SRC = "PACKET_RECEIVED_AUDIO_FROM_SRC", e2.PACKET_UPDATE_DEST_CHANNEL = "PACKET_UPDATE_DEST_CHANNEL", e2.PACKET_UPDATE_DEST_CHANNEL_REFUSED = "PACKET_UPDATE_DEST_CHANNEL_REFUSED", e2.PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE = "PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE";
      }(nS || (nS = {})), function(e2) {
        e2.RELAY_STATE_IDLE = "RELAY_STATE_IDLE", e2.RELAY_STATE_CONNECTING = "RELAY_STATE_CONNECTING", e2.RELAY_STATE_RUNNING = "RELAY_STATE_RUNNING", e2.RELAY_STATE_FAILURE = "RELAY_STATE_FAILURE";
      }(rS || (rS = {})), function(e2) {
        e2.RELAY_OK = "RELAY_OK", e2.SERVER_CONNECTION_LOST = "SERVER_CONNECTION_LOST", e2.SRC_TOKEN_EXPIRED = "SRC_TOKEN_EXPIRED", e2.DEST_TOKEN_EXPIRED = "DEST_TOKEN_EXPIRED";
      }(oS || (oS = {})), function(e2) {
        e2.High = "high", e2.Low = "low", e2.Audio = "audio", e2.Screen = "screen", e2.ScreenLow = "screen_low";
      }(sS || (sS = {})), function(e2) {
        e2.DISCONNECT = "disconnect", e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.NETWORK_QUALITY = "network-quality", e2.STREAM_TYPE_CHANGE = "stream-type-change", e2.IS_P2P_DISCONNECTED = "is-p2p-dis", e2.DISCONNECT_P2P = "dis-p2p", e2.REQUEST_NEW_GATEWAY_LIST = "req-gate-url", e2.NEED_RENEW_SESSION = "need-sid", e2.REQUEST_P2P_CONNECTION_PARAMS = "request-p2p-connection-params", e2.JOIN_RESPONSE = "join-response", e2.REQUEST_DC_CONNECTION_PARAMS = "request-dc-connection-params", e2.RESET_CONNECTION_EVENTS = "reset-connection-events", e2.DATACHANNEL_PRECONNECT = "datachannel_preconnect", e2.DATACHANNEL_FAILBACK = "datachannel_failback", e2.RESET_SIGNAL = "reset-signal";
      }(aS || (aS = {})), function(e2) {
        e2[e2.Nothing = 0] = "Nothing", e2[e2.Audio = 1] = "Audio", e2[e2.LwoVideo = 2] = "LwoVideo", e2[e2.Video = 4] = "Video", e2[e2.Data = 8] = "Data";
      }(cS || (cS = {})), function(e2) {
        e2[e2.websocket = 0] = "websocket", e2[e2.datachannel = 1] = "datachannel";
      }(dS || (dS = {})), function(e2) {
        e2.NEED_RENEGOTIATE = "@need_renegotiate", e2.NEED_REPLACE_TRACK = "@need_replace_track", e2.NEED_CLOSE = "@need_close", e2.NEED_ENABLE_TRACK = "@need_enable_track", e2.NEED_DISABLE_TRACK = "@need_disable_track", e2.NEED_SESSION_ID = "@need_sid", e2.SET_OPTIMIZATION_MODE = "@set_optimization_mode", e2.GET_STATS = "@get_stats", e2.GET_LOW_VIDEO_TRACK = "@get_low_video_track", e2.NEED_RESET_REMOTE_SDP = "@need_reset_remote_sdp", e2.NEED_UPDATE_VIDEO_ENCODER = "@need_update_video_encoder", e2.NEED_MUTE_TRACK = "@need_mute_track", e2.NEED_UNMUTE_TRACK = "@need_unmute_track";
      }(uS || (uS = {})), function(e2) {
        e2.SCREEN_TRACK = "screen_track", e2.CUSTOM_TRACK = "custome_track", e2.LOW_STREAM = "low_stream";
      }(lS || (lS = {})), function(e2) {
        e2[e2.HIGH_STREAM = 0] = "HIGH_STREAM", e2[e2.LOW_STREAM = 1] = "LOW_STREAM";
      }(hS || (hS = {})), function(e2) {
        e2[e2.HIGH_STREAM = 0] = "HIGH_STREAM", e2[e2.LOW_STREAM = 1] = "LOW_STREAM";
      }(pS || (pS = {})), function(e2) {
        e2[e2.DISABLE = 0] = "DISABLE", e2[e2.LOW_STREAM = 1] = "LOW_STREAM", e2[e2.AUDIO_ONLY = 2] = "AUDIO_ONLY";
      }(_S || (_S = {})), function(e2) {
        e2.TRANSCEIVER_UPDATED = "transceiver-updated";
      }(ES || (ES = {})), function(e2) {
        e2.SOURCE_STATE_CHANGE = "source-state-change", e2.TRACK_ENDED = "track-ended", e2.BEAUTY_EFFECT_OVERLOAD = "beauty-effect-overload", e2.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status", e2.CLOSED = "closed";
      }(mS || (mS = {})), function(e2) {
        e2.FIRST_FRAME_DECODED = "first-frame-decoded", e2.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status";
      }(fS || (fS = {})), function(e2) {
        e2.CHINA = "CHINA", e2.ASIA = "ASIA", e2.NORTH_AMERICA = "NORTH_AMERICA", e2.EUROPE = "EUROPE", e2.JAPAN = "JAPAN", e2.INDIA = "INDIA", e2.KOREA = "KOREA", e2.HKMC = "HKMC", e2.US = "US", e2.OCEANIA = "OCEANIA", e2.SOUTH_AMERICA = "SOUTH_AMERICA", e2.AFRICA = "AFRICA", e2.OVERSEA = "OVERSEA", e2.GLOBAL = "GLOBAL", e2.EXTENSIONS = "EXTENSIONS";
      }(SS || (SS = {}));
      const RS = [SS.AFRICA, SS.ASIA, SS.CHINA, SS.EUROPE, SS.GLOBAL, SS.INDIA, SS.JAPAN, SS.NORTH_AMERICA, SS.OCEANIA, SS.OVERSEA, SS.SOUTH_AMERICA];
      let IS;
      !function(e2) {
        e2.CHINA = "CN", e2.ASIA = "AS", e2.NORTH_AMERICA = "NA", e2.EUROPE = "EU", e2.JAPAN = "JP", e2.INDIA = "IN", e2.KOREA = "KR", e2.HKMC = "HK", e2.US = "US", e2.OCEANIA = "OC", e2.SOUTH_AMERICA = "SA", e2.AFRICA = "AF", e2.OVERSEA = "OVERSEA", e2.GLOBAL = "GLOBAL", e2.EXTENSIONS = "GLOBAL";
      }(IS || (IS = {}));
      const CS = { CHINA: {}, ASIA: { CODE: IS.ASIA, WEBCS_DOMAIN: ["ap-web-1-asia.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-asia.agora.io"], PROXY_CS: ["proxy-ap-web-asia.agora.io"], CDS_AP: ["cds-ap-web-asia.agora.io", "cds-ap-web-asia2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-asia.agora.io", "sua-ap-web-asia2.agora.io"], UAP_AP: ["uap-ap-web-asia.agora.io", "uap-ap-web-asia2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-asia.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-asia.agora.io"], LOG_UPLOAD_SERVER: ["logservice-asia.agora.io"], PROXY_SERVER_TYPE3: ["southeast-asia.webrtc-cloud-proxy.sd-rtn.com"] }, NORTH_AMERICA: { CODE: IS.NORTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-north-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-north-america.agora.io"], PROXY_CS: ["proxy-ap-web-america.agora.io"], CDS_AP: ["cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], UAP_AP: ["uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-north-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-north-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-north-america.agora.io"], PROXY_SERVER_TYPE3: ["east-usa.webrtc-cloud-proxy.sd-rtn.com"] }, EUROPE: { CODE: IS.EUROPE, WEBCS_DOMAIN: ["ap-web-1-europe.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-europe.agora.io"], PROXY_CS: ["proxy-ap-web-europe.agora.io"], CDS_AP: ["cds-ap-web-europe.agora.io", "cds-ap-web-europe2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-europe.agora.io", "sua-ap-web-europe.agora.io"], UAP_AP: ["uap-ap-web-europe.agora.io", "uap-ap-web-europe2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-europe.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-europe.agora.io"], LOG_UPLOAD_SERVER: ["logservice-europe.agora.io"], PROXY_SERVER_TYPE3: ["europe.webrtc-cloud-proxy.sd-rtn.com"] }, JAPAN: { CODE: IS.JAPAN, WEBCS_DOMAIN: ["ap-web-1-japan.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-japan.agora.io"], PROXY_CS: ["proxy-ap-web-japan.agora.io"], CDS_AP: ["cds-ap-web-japan.agora.io", "cds-ap-web-japan2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-japan.agora.io", "sua-ap-web-japan2.agora.io"], UAP_AP: ["uap-ap-web-japan.agora.io", "	uap-ap-web-japan2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-japan.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-japan.agora.io"], LOG_UPLOAD_SERVER: ["logservice-japan.agora.io"], PROXY_SERVER_TYPE3: ["japan.webrtc-cloud-proxy.sd-rtn.com"] }, INDIA: { CODE: IS.INDIA, WEBCS_DOMAIN: ["ap-web-1-india.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-india.agora.io"], PROXY_CS: ["proxy-ap-web-india.agora.io"], CDS_AP: ["cds-ap-web-india.agora.io", "cds-ap-web-india2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-india.agora.io", "sua-ap-web-india2.agora.io"], UAP_AP: ["uap-ap-web-india.agora.io", "uap-ap-web-india2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-india.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-india.agora.io"], LOG_UPLOAD_SERVER: ["logservice-india.agora.io"], PROXY_SERVER_TYPE3: ["india.webrtc-cloud-proxy.sd-rtn.com"] }, KOREA: { CODE: IS.KOREA, WEBCS_DOMAIN: ["ap-web-1-korea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-korea.agora.io"], PROXY_CS: ["proxy-ap-web-korea.agora.io"], CDS_AP: ["cds-ap-web-korea.agora.io", "cds-ap-web-korea2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-korea.agora.io", "sua-ap-web-korea2.agora.io"], UAP_AP: ["uap-ap-web-korea.agora.io", "uap-ap-web-korea2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-korea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-korea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-korea.agora.io"], PROXY_SERVER_TYPE3: ["korea.webrtc-cloud-proxy.sd-rtn.com"] }, HKMC: { CODE: IS.HKMC, WEBCS_DOMAIN: ["ap-web-1-hkmc.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-hkmc.agora.io"], PROXY_CS: ["proxy-ap-web-hkmc.agora.io"], CDS_AP: ["cds-ap-web-hkmc.agora.io", "cds-ap-web-hkmc2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-hkmc.agora.io", "sua-ap-web-hkmc2.agora.io"], UAP_AP: ["uap-ap-web-hkmc.agora.io", "uap-ap-web-hkmc2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-hkmc.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-hkmc.agora.io"], LOG_UPLOAD_SERVER: ["logservice-hkmc.agora.io"], PROXY_SERVER_TYPE3: ["hkmc.webrtc-cloud-proxy.sd-rtn.com"] }, US: { CODE: IS.US, WEBCS_DOMAIN: ["ap-web-1-us.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-us.agora.io"], PROXY_CS: ["proxy-ap-web-us.agora.io"], CDS_AP: ["cds-ap-web-us.agora.io", "cds-ap-web-us2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-us.agora.io", "sua-ap-web-us2.agora.io"], UAP_AP: ["uap-ap-web-us.agora.io", "uap-ap-web-us2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-us.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-us.agora.io"], LOG_UPLOAD_SERVER: ["logservice-us.agora.io"], PROXY_SERVER_TYPE3: ["us.webrtc-cloud-proxy.sd-rtn.com"] }, OVERSEA: { CODE: IS.OVERSEA, WEBCS_DOMAIN: ["ap-web-1-oversea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oversea.agora.io"], PROXY_CS: ["proxy-ap-web-oversea.agora.io"], CDS_AP: ["cds-ap-web-oversea.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oversea.agora.io"], UAP_AP: ["uap-ap-web-oversea.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oversea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oversea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oversea.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.agora.io"] }, GLOBAL: { CODE: IS.GLOBAL, WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-ap-web-3.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-ap-web-3.agora.io"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-ap-web-3.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2.agora.io"], LOG_UPLOAD_SERVER: ["logservice.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com"] }, OCEANIA: { CODE: IS.OCEANIA, WEBCS_DOMAIN: ["ap-web-1-oceania.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oceania.agora.io"], PROXY_CS: ["proxy-ap-web-oceania.agora.io"], CDS_AP: ["cds-ap-web-oceania.agora.io", "cds-ap-web-oceania2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oceania.agora.io", "sua-ap-web-oceania2.agora.io"], UAP_AP: ["uap-ap-web-oceania.agora.io", "uap-ap-web-oceania2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oceania.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oceania.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oceania.agora.io"], PROXY_SERVER_TYPE3: ["oceania.webrtc-cloud-proxy.sd-rtn.com"] }, SOUTH_AMERICA: { CODE: IS.SOUTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-south-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-south-america.agora.io"], PROXY_CS: ["proxy-ap-web-south-america.agora.io"], CDS_AP: ["cds-ap-web-south-america.agora.io", "cds-ap-web-south-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-south-america.agora.io", "sua-ap-web-south-america2.agora.io"], UAP_AP: ["uap-ap-web-south-america.agora.io", "uap-ap-web-south-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-south-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-south-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-america.agora.io"], PROXY_SERVER_TYPE3: ["south-america.webrtc-cloud-proxy.sd-rtn.com"] }, AFRICA: { CODE: IS.AFRICA, WEBCS_DOMAIN: ["ap-web-1-africa.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-africa.agora.io"], PROXY_CS: ["proxy-ap-web-africa.agora.io"], CDS_AP: ["cds-ap-web-africa.agora.io", "cds-ap-web-africa2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-africa.agora.io", "sua-ap-web-africa2.agora.io"], UAP_AP: ["uap-ap-web-africa.agora.io", "uap-ap-web-africa2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-africa.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-africa.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-africa.agora.io"], PROXY_SERVER_TYPE3: ["africa.webrtc-cloud-proxy.sd-rtn.com"] }, EXTENSIONS: {} };
      let vS, yS, AS, OS, NS, bS, wS, DS, PS, LS, kS, MS, US, xS, VS, jS, FS, BS, GS, WS, HS, KS;
      wE && (CS.CHINA = { CODE: IS.CHINA, WEBCS_DOMAIN: ["webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["proxy-web.ap.sd-rtn.com"], CDS_AP: ["cds-web-2.ap.sd-rtn.com", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-web-2.ap.sd-rtn.com", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-web-2.ap.sd-rtn.com", "uap-web-4.ap.sd-rtn.com"], EVENT_REPORT_DOMAIN: ["web-3.statscollector.sd-rtn.com"], EVENT_REPORT_BACKUP_DOMAIN: ["web-4.statscollector.sd-rtn.com"], LOG_UPLOAD_SERVER: ["logservice-china.agora.io"], PROXY_SERVER_TYPE3: ["east-cn.webrtc-cloud-proxy.sd-rtn.com"] }), function(e2) {
        e2.UPDATE_BITRATE_LIMIT = "update_bitrate_limit";
      }(vS || (vS = {}));
      class YS extends EE {
        constructor(e2, t2) {
          super(), _p(this, "onICEConnectionStateChange", void 0), _p(this, "onConnectionStateChange", void 0), _p(this, "onDTLSTransportStateChange", void 0), _p(this, "onDTLSTransportError", void 0), _p(this, "onICETransportStateChange", void 0), _p(this, "onFirstAudioReceived", void 0), _p(this, "onFirstVideoReceived", void 0), _p(this, "onFirstAudioDecoded", void 0), _p(this, "onFirstVideoDecoded", void 0), _p(this, "onFirstVideoDecodedTimeout", void 0), _p(this, "onSelectedLocalCandidateChanged", void 0), _p(this, "onSelectedRemoteCandidateChanged", void 0), _p(this, "establishPromise", void 0);
        }
      }
      !function(e2) {
        e2.SEND = "sendonly", e2.RECV = "recvonly", e2.SENDRECV = "sendrecv", e2.INACTIVE = "inactive";
      }(yS || (yS = {})), function(e2) {
        e2.VIDEO = "video", e2.AUDIO = "audio";
      }(AS || (AS = {})), function(e2) {
        e2[e2.UDP = 0] = "UDP", e2[e2.TCP = 1] = "TCP", e2[e2.RELAY = 2] = "RELAY";
      }(OS || (OS = {})), function(e2) {
        e2[e2.FIRST_CONNECTION = 0] = "FIRST_CONNECTION", e2[e2.TCP_RESTART = 1] = "TCP_RESTART", e2[e2.RELAY_RESTART = 2] = "RELAY_RESTART", e2[e2.OLD_FIRST_CONNECTION = 10] = "OLD_FIRST_CONNECTION", e2[e2.OLD_RESTART = 11] = "OLD_RESTART", e2[e2.DISCONNECTED_OR_FAILED = 20] = "DISCONNECTED_OR_FAILED";
      }(NS || (NS = {})), function(e2) {
        e2.LocalVideoTrack = "videoTrack", e2.LocalAudioTrack = "audioTrack", e2.LocalVideoLowTrack = "videoLowTrack";
      }(bS || (bS = {})), function(e2) {
        e2.New = "new", e2.Connected = "connected", e2.Reconnecting = "reconnecting", e2.Disconnected = "disconnected";
      }(wS || (wS = {})), function(e2) {
        e2.StateChange = "stateChange", e2.IceConnectionStateChange = "iceConnectionStateChange", e2.RequestMuteLocal = "requestMuteLocal", e2.RequestUnmuteLocal = "requestUnmuteLocal", e2.RequestRePublish = "requestRePublish", e2.RequestReSubscribe = "requestReSubscribe", e2.RequestUploadStats = "requestUploadStats", e2.MediaReconnectStart = "MediaReconnectStart", e2.MediaReconnectEnd = "MediaReconnectEnd", e2.NeedSignalRTT = "NeedSignalRTT", e2.RequestRestartICE = "RequestRestartIce", e2.PeerConnectionStateChange = "PeerConnectionStateChange", e2.RequestReconnect = "RequestReconnect", e2.RequestReconnectPC = "RequestReconnectPC", e2.RequestUnpublishForReconnectPC = "RequestUnpublishForReconnectPC", e2.P2PLost = "P2PLost", e2.UpdateVideoEncoder = "UpdateVideoEncoder", e2.ConnectionTypeChange = "ConnectionTypeChange", e2.RequestLowStreamParameter = "RequestLowStreamParameter", e2.QueryClientConnectionState = "QueryClientConnectionState";
      }(DS || (DS = {})), function(e2) {
        e2.ONLINE = "ONLINE", e2.OFFLINE = "OFFLINE";
      }(PS || (PS = {})), function(e2) {
        e2.NETWORK_STATE_CHANGE = "NETWORK_STATE_CHANGE", e2.ONLINE = "ONLINE", e2.OFFLINE = "OFFLINE";
      }(LS || (LS = {})), function(e2) {
        e2.ON_TRACK = "on_track", e2.ON_NODE = "on_node";
      }(kS || (kS = {})), function(e2) {
        e2.REQUEST_UPDATE_CONSTRAINTS = "request_update_constraints", e2.REQUEST_CONSTRAINTS = "request_constraints";
      }(MS || (MS = {})), function(e2) {
        e2.CONNECTING = "CONNECTING", e2.RECONNECTING = "RECONNECTING", e2.CONNECTED = "CONNECTED", e2.CLOSED = "CLOSED";
      }(US || (US = {})), function(e2) {
        e2[e2.CONNECT_AP = 0] = "CONNECT_AP", e2[e2.AP_CONNECTED = 1] = "AP_CONNECTED", e2[e2.CONNECT_WORKER_MANAGER = 2] = "CONNECT_WORKER_MANAGER", e2[e2.WORKER_MANAGER_CONNECTED = 3] = "WORKER_MANAGER_CONNECTED", e2[e2.GET_WORKER_MANAGER_RESPONSE = 4] = "GET_WORKER_MANAGER_RESPONSE", e2[e2.CONNECT_WORKER = 5] = "CONNECT_WORKER", e2[e2.WORKER_CONNECTED = 6] = "WORKER_CONNECTED", e2[e2.CLOSED = 7] = "CLOSED";
      }(xS || (xS = {})), function(e2) {
        e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.STATE_CHANGE = "state-change", e2.INSPECT_RESULT = "inspect-result", e2.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track", e2.REQUEST_NEW_WORKER_URL = "request-new-worker-url";
      }(VS || (VS = {})), function(e2) {
        e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.MULTI_IP = "MULTI_IP", e2.TIMEOUT = "TIMEOUT", e2.OFFLINE = "OFFLINE", e2.LEAVE = "LEAVE", e2.P2P_FAILED = "P2P_FAILED", e2.FALLBACK = "FALLBACK";
      }(jS || (jS = {})), function(e2) {
        e2.CONNECTED = "transmitter:connected", e2.RECONNECTING = "transmitter:reconnecting", e2.WILL_RECONNECT = "transmitter:will_reconnect", e2.CLOSED = "transmitter:closed", e2.FAILED = "transmitter:failed", e2.ON_MESSAGE = "transmitter:on_message", e2.REQUEST_NEW_URLS = "transmitter:request_new_urls", e2.RECONNECT_WAITTING_FINISH = "transmitter:reconnect_waitting_finish", e2.RECONNECT_CREATE_CONNECTION = "transmitter:reconnect_create_connection", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "transmitter:on_token_privilege_did_expire", e2.TO_CONNECT_DATACHANNEL = "transmitter:to_connect_datachannel", e2.FAILBACK = "transmitter:failback";
      }(FS || (FS = {})), function(e2) {
        e2.CAMERA_CHANGED = "camera-changed", e2.MICROPHONE_CHANGED = "microphone-changed", e2.PLAYBACK_DEVICE_CHANGED = "playback-device-changed", e2.AUDIO_AUTOPLAY_FAILED = "audio-autoplay-failed", e2.AUTOPLAY_FAILED = "autoplay-failed", e2.SECURITY_POLICY_VIOLATION = "security-policy-violation";
      }(BS || (BS = {})), function(e2) {
        e2[e2.APP_TYPE_INVALID_VALUE = -1] = "APP_TYPE_INVALID_VALUE", e2[e2.APP_TYPE_NATIVE = 0] = "APP_TYPE_NATIVE", e2[e2.APP_TYPE_NATIVE_COCOS = 1] = "APP_TYPE_NATIVE_COCOS", e2[e2.APP_TYPE_NATIVE_UNITY = 2] = "APP_TYPE_NATIVE_UNITY", e2[e2.APP_TYPE_NATIVE_ELECTRON = 3] = "APP_TYPE_NATIVE_ELECTRON", e2[e2.APP_TYPE_NATIVE_FLUTTER = 4] = "APP_TYPE_NATIVE_FLUTTER", e2[e2.APP_TYPE_NATIVE_UNREAL = 5] = "APP_TYPE_NATIVE_UNREAL", e2[e2.APP_TYPE_NATIVE_XAMARIN = 6] = "APP_TYPE_NATIVE_XAMARIN", e2[e2.APP_TYPE_NATIVE_API_CLOUD = 7] = "APP_TYPE_NATIVE_API_CLOUD", e2[e2.APP_TYPE_NATIVE_REACT_NATIVE = 8] = "APP_TYPE_NATIVE_REACT_NATIVE", e2[e2.APP_TYPE_NATIVE_PYTHON = 9] = "APP_TYPE_NATIVE_PYTHON", e2[e2.APP_TYPE_NATIVE_COCOS_CREATOR = 10] = "APP_TYPE_NATIVE_COCOS_CREATOR", e2[e2.APP_TYPE_NATIVE_RUST = 11] = "APP_TYPE_NATIVE_RUST", e2[e2.APP_TYPE_NATIVE_C_SHARP = 12] = "APP_TYPE_NATIVE_C_SHARP", e2[e2.APP_TYPE_NATIVE_CEF = 13] = "APP_TYPE_NATIVE_CEF", e2[e2.APP_TYPE_NATIVE_UNI_APP = 14] = "APP_TYPE_NATIVE_UNI_APP", e2[e2.APP_TYPE_WEBRTC = 1e3] = "APP_TYPE_WEBRTC", e2[e2.APP_TYPE_WEBRTC_REACT = 1001] = "APP_TYPE_WEBRTC_REACT", e2[e2.APP_TYPE_WEBRTC_VUE = 1002] = "APP_TYPE_WEBRTC_VUE", e2[e2.APP_TYPE_WEBRTC_ANGULAR = 1003] = "APP_TYPE_WEBRTC_ANGULAR";
      }(GS || (GS = {})), function(e2) {
        e2.CONNECTING = "CONNECTING", e2.RECONNECTING = "RECONNECTING", e2.CONNECTED = "CONNECTED", e2.CLOSED = "CLOSED";
      }(WS || (WS = {})), function(e2) {
        e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.STATE_CHANGE = "state-change", e2.INSPECT_RESULT = "inspect-result", e2.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track", e2.REQUEST_NEW_WORKER_URL = "request-new-worker-url";
      }(HS || (HS = {})), function(e2) {
        e2[e2.CONNECT_AP = 0] = "CONNECT_AP", e2[e2.AP_CONNECTED = 1] = "AP_CONNECTED", e2[e2.CONNECT_WORKER_MANAGER = 2] = "CONNECT_WORKER_MANAGER", e2[e2.WORKER_MANAGER_CONNECTED = 3] = "WORKER_MANAGER_CONNECTED", e2[e2.GET_WORKER_MANAGER_RESPONSE = 4] = "GET_WORKER_MANAGER_RESPONSE", e2[e2.CONNECT_WORKER = 5] = "CONNECT_WORKER", e2[e2.WORKER_CONNECTED = 6] = "WORKER_CONNECTED", e2[e2.CLOSED = 7] = "CLOSED";
      }(KS || (KS = {}));
      const qS = { getDisplayMedia: false, getStreamFromExtension: false, supportUnifiedPlan: false, supportMinBitrate: false, supportSetRtpSenderParameters: false, supportDualStream: true, webAudioMediaStreamDest: false, supportReplaceTrack: false, supportWebGL: false, webAudioWithAEC: false, supportRequestFrame: false, supportShareAudio: false, supportDualStreamEncoding: false, supportDataChannel: false, supportPCSetConfiguration: false, supportWebRTCEncodedTransform: false };
      function JS() {
        return qS;
      }
      let XS;
      !function(e2) {
        e2[e2.CHOOSE_SERVER = 11] = "CHOOSE_SERVER", e2[e2.CLOUD_PROXY = 18] = "CLOUD_PROXY", e2[e2.CLOUD_PROXY_5 = 20] = "CLOUD_PROXY_5", e2[e2.CLOUD_PROXY_FALLBACK = 26] = "CLOUD_PROXY_FALLBACK";
      }(XS || (XS = {}));
      var zS = k, QS = Array.isArray || function(e2) {
        return "Array" == zS(e2);
      }, ZS = h, $S = QS, eT = oc, tT = q, iT = rt("species"), nT = ZS.Array, rT = function(e2) {
        var t2;
        return $S(e2) && (t2 = e2.constructor, (eT(t2) && (t2 === nT || $S(t2.prototype)) || tT(t2) && null === (t2 = t2[iT])) && (t2 = void 0)), void 0 === t2 ? nT : t2;
      }, oT = function(e2, t2) {
        return new (rT(e2))(0 === t2 ? 0 : t2);
      }, sT = Wt, aT = F, cT = je, dT = bi, uT = oT, lT = d([].push), hT = function(e2) {
        var t2 = 1 == e2, i2 = 2 == e2, n2 = 3 == e2, r2 = 4 == e2, o2 = 6 == e2, s2 = 7 == e2, a2 = 5 == e2 || o2;
        return function(c2, d2, u2, l2) {
          for (var h2, p2, _2 = cT(c2), E2 = aT(_2), m2 = sT(d2, u2), f2 = dT(E2), S2 = 0, T2 = l2 || uT, g2 = t2 ? T2(c2, f2) : i2 || s2 ? T2(c2, 0) : void 0; f2 > S2; S2++)
            if ((a2 || S2 in E2) && (p2 = m2(h2 = E2[S2], S2, _2), e2))
              if (t2)
                g2[S2] = p2;
              else if (p2)
                switch (e2) {
                  case 3:
                    return true;
                  case 5:
                    return h2;
                  case 6:
                    return S2;
                  case 2:
                    lT(g2, h2);
                }
              else
                switch (e2) {
                  case 4:
                    return false;
                  case 7:
                    lT(g2, h2);
                }
          return o2 ? -1 : n2 || r2 ? r2 : g2;
        };
      }, pT = { forEach: hT(0), map: hT(1), filter: hT(2), some: hT(3), every: hT(4), find: hT(5), findIndex: hT(6), filterReject: hT(7) }, _T = pT.forEach, ET = Vi("forEach") ? [].forEach : function(e2) {
        return _T(this, e2, arguments.length > 1 ? arguments[1] : void 0);
      };
      Ii({ target: "Array", proto: true, forced: [].forEach != ET }, { forEach: ET });
      var mT = Hi("Array").forEach, fT = Zr, ST = Ge, TT = u, gT = mT, RT = Array.prototype, IT = { DOMTokenList: true, NodeList: true }, CT = function(e2) {
        var t2 = e2.forEach;
        return e2 === RT || TT(RT, e2) && t2 === RT.forEach || ST(IT, fT(e2)) ? gT : t2;
      }, vT = je, yT = hr;
      Ii({ target: "Object", stat: true, forced: i(function() {
        yT(1);
      }) }, { keys: function(e2) {
        return yT(vT(e2));
      } });
      var AT = J.Object.keys, OT = Xi, NT = Ii, bT = QS, wT = d([].reverse), DT = [1, 2];
      NT({ target: "Array", proto: true, forced: String(DT) === String(DT.reverse()) }, { reverse: function() {
        return bT(this) && (this.length = this.length), wT(this);
      } });
      var PT = Hi("Array").reverse, LT = u, kT = PT, MT = Array.prototype, UT = function(e2) {
        var t2 = e2.reverse;
        return e2 === MT || LT(MT, e2) && t2 === MT.reverse ? kT : t2;
      }, xT = i, VT = ae, jT = rt("species"), FT = function(e2) {
        return VT >= 51 || !xT(function() {
          var t2 = [];
          return (t2.constructor = {})[jT] = function() {
            return { foo: 1 };
          }, 1 !== t2[e2](Boolean).foo;
        });
      }, BT = Ii, GT = h, WT = QS, HT = oc, KT = q, YT = Un, qT = bi, JT = K, XT = im, zT = rt, QT = pc, ZT = FT("slice"), $T = zT("species"), eg = GT.Array, tg = Math.max;
      BT({ target: "Array", proto: true, forced: !ZT }, { slice: function(e2, t2) {
        var i2, n2, r2, o2 = JT(this), s2 = qT(o2), a2 = YT(e2, s2), c2 = YT(void 0 === t2 ? s2 : t2, s2);
        if (WT(o2) && (i2 = o2.constructor, (HT(i2) && (i2 === eg || WT(i2.prototype)) || KT(i2) && null === (i2 = i2[$T])) && (i2 = void 0), i2 === eg || void 0 === i2))
          return QT(o2, a2, c2);
        for (n2 = new (void 0 === i2 ? eg : i2)(tg(c2 - a2, 0)), r2 = 0; a2 < c2; a2++, r2++)
          a2 in o2 && XT(n2, r2, o2[a2]);
        return n2.length = r2, n2;
      } });
      var ig = Hi("Array").slice, ng = u, rg = ig, og = Array.prototype, sg = function(e2) {
        var t2 = e2.slice;
        return e2 === og || ng(og, e2) && t2 === og.slice ? rg : t2;
      };
      function ag(e2, t2, i2, n2, r2) {
        var o2, s2, a2, c2 = {};
        return CT(o2 = AT(n2)).call(o2, function(e3) {
          c2[e3] = n2[e3];
        }), c2.enumerable = !!c2.enumerable, c2.configurable = !!c2.configurable, ("value" in c2 || c2.initializer) && (c2.writable = true), c2 = OT(s2 = UT(a2 = sg(i2).call(i2)).call(a2)).call(s2, function(i3, n3) {
          return n3(e2, t2, i3) || i3;
        }, c2), r2 && void 0 !== c2.initializer && (c2.value = c2.initializer ? c2.initializer.call(r2) : void 0, c2.initializer = void 0), void 0 === c2.initializer && (pp(e2, t2, c2), c2 = null), c2;
      }
      var cg = Hi("Array").keys, dg = Zr, ug = Ge, lg = u, hg = cg, pg = Array.prototype, _g = { DOMTokenList: true, NodeList: true }, Eg = function(e2) {
        var t2 = e2.keys;
        return e2 === pg || lg(pg, e2) && t2 === pg.keys || ug(_g, dg(e2)) ? hg : t2;
      };
      function mg(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function fg(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? mg(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : mg(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      let Sg = 0, Tg = 0;
      function gg(e2, t2, i2, n2) {
        return new Sl((r2, o2) => {
          t2.timeout = t2.timeout || GE("HTTP_CONNECT_TIMEOUT"), t2.responseType = t2.responseType || "json", t2.data && !i2 ? (t2.data = JSON.stringify(t2.data), Sg += XI(t2.data)) : i2 && (t2.data.size ? Sg += t2.data.size : t2.data instanceof FormData ? Sg += function(e3) {
            let t3 = 0;
            /DingTalk/i.test(navigator.userAgent) && e3.realFormData && (e3 = e3.realFormData);
            return e3.forEach((e4) => {
              t3 += "string" == typeof e4 ? XI(e4) : e4.size;
            }), t3 + 138;
          }(t2.data) : Sg += XI(JSON.stringify(t2.data))), t2.headers = t2.headers || {}, t2.headers["Content-Type"] = t2.headers["Content-Type"] || "application/json", t2.method = "POST", t2.url = e2, pE.request(t2).then((e3) => {
            "string" == typeof e3.data ? Tg += XI(e3.data) : e3.data instanceof ArrayBuffer || e3.data instanceof Uint8Array ? Tg += e3.data.byteLength : Tg += XI(JSON.stringify(e3.data)), n2 && r2({ data: e3.data, headers: e3.headers }), r2(e3.data);
          }).catch((e3) => {
            pE.isCancel(e3) ? o2(new SE(fE.OPERATION_ABORTED, "cancel token canceled")) : "ECONNABORTED" === e3.code ? o2(new SE(fE.NETWORK_TIMEOUT, e3.message)) : e3.response ? o2(new SE(fE.NETWORK_RESPONSE_ERROR, e3.response.status)) : o2(new SE(fE.NETWORK_ERROR, e3.message));
          });
        });
      }
      async function Rg(e2, t2) {
        const i2 = new Blob([t2.data], { type: "buffer" });
        return await gg(e2, fg(fg({}, t2), {}, { data: i2, headers: { "Content-Type": "application/octet-stream" } }), true);
      }
      const Ig = new class extends EE {
        set networkState(e2) {
          OE.info("[".concat(this._moduleName, "]") + "network state changed, " + this._networkState + " -> " + e2), this.emit(LS.NETWORK_STATE_CHANGE, e2, this._networkState), e2 === PS.ONLINE ? this.emit(LS.ONLINE) : e2 === PS.OFFLINE && (this.onlineWaiter = new Sl((e3) => {
            this.once(LS.ONLINE, () => {
              this.onlineWaiter = void 0, e3(PS.ONLINE);
            });
          }), this.emit(LS.OFFLINE)), this._networkState = e2;
        }
        get networkState() {
          return this._networkState;
        }
        constructor() {
          super(), _p(this, "_moduleName", "network-indicator"), _p(this, "_networkState", PS.ONLINE), _p(this, "onlineWaiter", void 0), window.addEventListener("online", () => {
            this.networkState = PS.ONLINE;
          }), window.addEventListener("offline", () => {
            this.networkState = PS.OFFLINE;
          });
        }
      }();
      let Cg = false;
      const vg = new class extends EE {
        constructor() {
          super(...arguments), _p(this, "onAutoplayFailed", void 0), _p(this, "onAudioAutoplayFailed", void 0);
        }
      }();
      function yg() {
        if (xh(), !Cg) {
          const e2 = (t2) => {
            t2.preventDefault(), Cg = false, sp() ? document.body.removeEventListener("click", e2, true) : (document.body.removeEventListener("touchstart", e2, true), document.body.removeEventListener("mousedown", e2, true));
          };
          Cg = true, sp() ? document.body.addEventListener("click", e2, true) : (document.body.addEventListener("touchstart", e2, true), document.body.addEventListener("mousedown", e2, true)), OE.info("detect media autoplay failed, document: https://docs.agora.io/cn/Voice/autoplay_policy_web_ng?platform=Web"), vg.onAutoplayFailed ? vg.onAutoplayFailed() : vg.onAudioAutoplayFailed ? OE.warning("AgoraRTC.onAudioAutoplayFailed has been deprecated in favor of AgoraRTC.onAutoplayFailed.\n\n  Please refer to the Agora document to migrate the newer API, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web .") : OE.warning("We have detected a media autoplay failed event, and found out that you haven't implemented AgoraRTC.onAutoplayFailed callback yet.\n\n  It will cause audio/video element not playing automatically on some browsers without user interaction, possibly hurting user experiences.\n\n  Please refer to the Agora document to properly handle autoplay failed event, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web ."), vg.emit("autoplay-failed");
        }
      }
      function Ag(e2) {
        return new TextEncoder().encode(e2);
      }
      const Og = function(e2, t2) {
        const i2 = new Uint8Array(e2.byteLength + t2.byteLength);
        return i2.set(new Uint8Array(e2), 0), i2.set(new Uint8Array(t2), e2.byteLength), i2;
      };
      const Ng = async (e2) => function(e3, t2) {
        let i2 = "";
        return new Uint8Array(e3).forEach((e4) => {
          i2 += e4.toString(t2).padStart(2, "0");
        }), i2;
      }(await crypto.subtle.digest("SHA-256", Ag(e2)), 16);
      function bg(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function wg(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? bg(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : bg(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      function Dg() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        return function(t2, i2, n2) {
          const r2 = n2.value;
          if ("function" == typeof r2) {
            const o2 = e2.className || t2.__className__ || ("AgoraRTCClient" === t2.constructor.name ? "Client" : t2.constructor.name);
            n2.value = function() {
              for (var t3 = arguments.length, n3 = new Array(t3), s2 = 0; s2 < t3; s2++)
                n3[s2] = arguments[s2];
              let a2 = n3;
              if (e2.argsMap)
                try {
                  a2 = e2.argsMap(this, ...n3);
                } catch (e3) {
                  OE.warning(e3), a2 = [];
                }
              try {
                JSON.stringify(a2);
              } catch (e3) {
                OE.warning("arguments for method ".concat(o2, ".").concat(String(i2), " not serializable for apiInvoke.")), a2 = [];
              }
              const c2 = (e2.report || Pg).reportApiInvoke(this._sessionId || null, { name: "".concat(o2, ".").concat(String(i2)), options: a2, tag: Ef.TRACER, reportResult: e2.reportResult }, e2.throttleTime);
              try {
                const t4 = r2.apply(this, n3);
                return t4 instanceof Sl ? t4.then((t5) => (c2.onSuccess(e2.reportResult && t5), t5)).catch((e3) => {
                  throw c2.onError(e3), e3;
                }) : (c2.onSuccess(e2.reportResult && t4), t4);
              } catch (e3) {
                throw c2.onError(e3), e3;
              }
            };
          }
          return n2;
        };
      }
      const Pg = new class {
        constructor() {
          _p(this, "baseInfoMap", /* @__PURE__ */ new Map()), _p(this, "proxyServer", void 0), _p(this, "clientList", zE), _p(this, "eventUploadTimer", void 0), _p(this, "setSessionIdTimer", void 0), _p(this, "url", void 0), _p(this, "backupUrl", void 0), _p(this, "_appId", void 0), _p(this, "keyEventUploadPendingItems", []), _p(this, "normalEventUploadPendingItems", []), _p(this, "apiInvokeUploadPendingItems", []), _p(this, "apiInvokeCount", 0), _p(this, "ltsList", []), _p(this, "lastSendNormalEventTime", Date.now()), _p(this, "customReportCounterTimer", void 0), _p(this, "customReportCount", 0), _p(this, "extApiInvoke", async (e2) => {
            for (const t2 of e2) {
              const e3 = wg(wg({}, t2), {}, { sid: null, invokeId: ++this.apiInvokeCount, tag: Ef.TRACER });
              this.sendApiInvoke(e3);
            }
          }), this.eventUploadTimer = window.setInterval(this.doSend.bind(this), GE("EVENT_REPORT_SEND_INTERVAL")), this.setSessionIdTimer = window.setInterval(this.appendSessionId.bind(this), GE("EVENT_REPORT_SEND_INTERVAL"));
        }
        adjustSessionStartTime(e2) {
          if (!this.baseInfoMap.has(e2) && !this.baseInfoMap.get(e2))
            return void OE.error("adjust session ".concat(e2, " start time, sid is not exist or info is undefined"));
          const t2 = this.baseInfoMap.get(e2), i2 = Date.now(), n2 = t2.startTime;
          t2.startTime = i2, OE.debug("rewrite session ".concat(e2, " startTime: ").concat(i2, " , ").concat(i2 - n2, "ms")), this.baseInfoMap.set(e2, t2);
        }
        setAppId(e2) {
          this._appId = e2;
        }
        reportApiInvoke(e2, t2, i2) {
          t2.timeout = t2.timeout || 6e4, t2.reportResult = void 0 === t2.reportResult || t2.reportResult;
          const n2 = Date.now();
          this.apiInvokeCount += 1;
          const r2 = this.apiInvokeCount, o2 = () => ({ tag: t2.tag, invokeId: r2, sid: e2, name: t2.name, apiInvokeTime: n2, options: t2.options, states: t2.states || null }), s2 = !!GE("SHOW_REPORT_INVOKER_LOG");
          s2 && OE.info("".concat(t2.name, " start"), t2.options);
          let a2 = false;
          zI(t2.timeout).then(() => {
            a2 || (this.sendApiInvoke(wg(wg({}, o2()), {}, { error: fE.API_INVOKE_TIMEOUT, success: false })), OE.debug("".concat(t2.name, " timeout")));
          });
          const c2 = new SE(fE.UNEXPECTED_ERROR, "".concat(t2.name, ": this api invoke is end"));
          return { onSuccess: (e3) => {
            const n3 = () => {
              if (a2)
                throw c2;
              return a2 = true, this.sendApiInvoke(wg(wg({}, o2()), {}, { success: true }, t2.reportResult && { result: e3 })), s2 && OE.info("".concat(t2.name, " onSuccess")), e3;
            };
            return i2 ? mC(n3, t2.name + "Success", i2, () => a2 = true) : n3();
          }, onError: (e3) => {
            const n3 = () => {
              if (a2)
                throw e3;
              a2 = true, this.sendApiInvoke(wg(wg({}, o2()), {}, { success: false, error: e3 })), s2 && OE.info("".concat(t2.name, " onFailure"), e3.toString());
            };
            return i2 ? mC(n3, t2.name + "Error", i2, () => a2 = true) : n3();
          } };
        }
        sessionInit(e2, t2) {
          if (this.baseInfoMap.has(e2))
            return;
          const i2 = Date.now(), n2 = this.createBaseInfo(e2, i2);
          n2.cname = t2.cname;
          const r2 = Object.assign({}, { willUploadConsoleLog: GE("UPLOAD_LOG"), maxTouchPoints: navigator.maxTouchPoints, areaVersion: wE ? "global" : "oversea", areas: GE("AREAS") && GE("AREAS").join(",") }, t2.extend), o2 = Date.now(), s2 = wg(wg({}, n2), {}, { eventType: uf.SESSION_INIT, appid: t2.appid, browser: navigator.userAgent, build: NE, lts: o2, elapse: o2 - i2, extend: JSON.stringify(r2), mode: t2.mode, process: GE("PROCESS_ID"), appType: GE("APP_TYPE"), success: true, version: bE });
          this.send({ type: lf.SESSION, data: s2 }, true);
        }
        joinChooseServer(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2)
            return;
          const n2 = i2.info, r2 = Date.now(), o2 = wg(wg({}, n2), {}, { eventType: uf.JOIN_CHOOSE_SERVER, lts: r2, eventElapse: r2 - t2.lts, chooseServerAddr: t2.csAddr, errorCode: t2.ec, elapse: r2 - i2.startTime, success: t2.succ, chooseServerAddrList: JSON.stringify(t2.serverList), uid: t2.uid ? parseInt(t2.uid) : null, cid: t2.cid ? parseInt(t2.cid) : null, chooseServerIp: t2.csIp || "", opid: t2.opid, unilbsServerIds: t2.unilbsServerIds, extend: t2.extend || void 0, isHttp3: t2.isHttp3 });
          this.send({ type: lf.JOIN_CHOOSE_SERVER, data: o2 }, true);
        }
        reqUserAccount(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2)
            return;
          const n2 = i2.info, r2 = Date.now(), o2 = wg(wg({}, n2), {}, { eventType: uf.REQ_USER_ACCOUNT, lts: r2, success: t2.success, serverAddress: t2.serverAddr, stringUid: t2.stringUid, uid: t2.uid, errorCode: t2.errorCode, elapse: r2 - i2.startTime, eventElapse: r2 - t2.lts, extend: JSON.stringify(t2.extend) });
          this.send({ type: lf.REQ_USER_ACCOUNT, data: o2 }, true);
        }
        joinGateway(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2)
            return;
          const n2 = i2.info;
          t2.vid && (n2.vid = t2.vid), n2.uid = t2.uid, n2.cid = t2.cid;
          const r2 = Date.now(), { firstSuccess: o2, avoidJoinStartTime: s2, isProxy: a2, addr: c2 } = t2, d2 = r2 - (o2 && s2 ? s2 : i2.startTime), u2 = wg(wg({}, n2), {}, { eventType: uf.JOIN_GATEWAY, lts: r2, gatewayAddr: t2.addr, success: t2.succ, errorCode: t2.ec, elapse: d2, eventElapse: r2 - t2.lts, firstSuccess: o2, signalChannel: t2.signalChannel }), l2 = u2.success ? 1 : 0;
          if (t2.succ && (i2.lastJoinSuccessTime = r2), o2)
            this.send({ type: lf.JOIN_GATEWAY, data: u2 }, true);
          else {
            let e3;
            if (c2)
              if (a2) {
                const t4 = c2.match(/h=(\d{1,3}-){3}\d{1,3}/g), i3 = c2.match(/p=[0-9]{1,6}/g);
                e3 = { isSuccess: l2, gatewayIp: t4 && t4.length ? t4[0].split("=")[1].replace(/-/g, ".") : "", port: i3 && i3.length ? i3[0].split("=")[1] : "", isProxy: a2 ? 1 : 0 };
              } else {
                const t4 = c2.match(/wss:\/\/(\d{1,3}-){3}\d{1,3}/g), i3 = c2.match(/:[0-9]{1,6}/g);
                e3 = { isSuccess: l2, gatewayIp: t4 && t4.length ? t4[0].split("//")[1].replace(/-/g, ".") : "", port: i3 && i3.length ? i3[0].split(":")[1] : "", isProxy: a2 ? 1 : 0 };
              }
            else
              e3 = { isSuccess: l2, gatewayIp: "", port: "", isProxy: a2 ? 1 : 0 };
            delete u2.success, delete u2.eventType, delete u2.firstSuccess, u2.vid = Number(u2.vid);
            const t3 = Object.assign({}, u2, e3, { eventType: uf.REJOIN_GATEWAY });
            this.send({ type: lf.RE_JOIN_GATEWAY, data: t3 }, true);
          }
        }
        joinChannelTimeout(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2)
            return;
          const n2 = Date.now(), r2 = wg(wg({}, i2.info), {}, { lts: n2, timeout: t2, elapse: n2 - i2.startTime });
          this.send({ type: lf.JOIN_CHANNEL_TIMEOUT, data: r2 }, true);
        }
        publish(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2)
            return;
          const n2 = i2.info, r2 = Date.now(), o2 = wg(wg({}, n2), {}, { eventType: uf.PUBLISH, lts: r2, eventElapse: t2.eventElapse, elapse: r2 - i2.startTime, success: t2.succ, errorCode: t2.ec, videoName: t2.videoName, audioName: t2.audioName, screenName: t2.screenName, screenshare: t2.screenshare, audio: t2.audio, video: t2.video, p2pid: t2.p2pid, publishRequestid: t2.publishRequestid });
          this.send({ type: lf.PUBLISH, data: o2 }, true);
        }
        subscribe(e2, t2, i2) {
          const n2 = this.baseInfoMap.get(e2);
          if (!n2)
            return;
          const r2 = n2.info, o2 = Date.now(), s2 = wg(wg({}, r2), {}, { eventType: uf.SUBSCRIBE, lts: o2, eventElapse: t2.eventElapse, elapse: o2 - n2.startTime, success: t2.succ, errorCode: t2.ec, video: t2.video, audio: t2.audio, subscribeRequestid: t2.subscribeRequestid, p2pid: t2.p2pid }, i2 && { extend: JSON.stringify({ isMassSubscribe: true }) });
          "string" == typeof t2.peerid ? s2.peerSuid = t2.peerid : s2.peer = t2.peerid, this.send({ type: lf.SUBSCRIBE, data: s2 }, true);
        }
        wsCompressorInit(e2) {
          var t2;
          const i2 = [...Eg(t2 = this.baseInfoMap).call(t2)], n2 = i2.length ? i2[0] : "UnableToGetSid", r2 = this.baseInfoMap.get(n2);
          if (!r2)
            return;
          const o2 = r2.info, s2 = Date.now(), a2 = wg(wg({}, o2), {}, { eventType: uf.WS_COMPRESSOR_INIT, lts: s2, eventElapse: e2.eventElapse, elapse: s2 - r2.startTime, status: e2.status ? 1 : 2 });
          this.send({ type: lf.WS_COMPRESSOR_INIT, data: a2 }, true);
        }
        firstRemoteVideoDecode(e2, t2, i2, n2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2)
            return;
          const o2 = r2.info, s2 = Date.now(), a2 = wg(wg(wg({}, o2), n2), {}, { elapse: s2 - r2.startTime, eventType: t2, lts: s2, firstDecodeFrame: Math.max(s2 - r2.startTime, 0), apEnd: Math.max(n2.apEnd - r2.startTime, 0), apStart: Math.max(n2.apStart - r2.startTime, 0), joinGwEnd: Math.max(n2.joinGwEnd - r2.startTime, 0), joinGwStart: Math.max(n2.joinGwStart - r2.startTime, 0), pcEnd: Math.max(n2.pcEnd - r2.startTime, 0), pcStart: Math.max(n2.pcStart - r2.startTime, 0), subscriberEnd: Math.max(n2.subscriberEnd - r2.startTime, 0), subscriberStart: Math.max(n2.subscriberStart - r2.startTime, 0), videoAddNotify: Math.max(n2.videoAddNotify - r2.startTime, 0) });
          this.send({ type: i2, data: a2 }, true);
        }
        firstRemoteFrame(e2, t2, i2, n2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2)
            return;
          const o2 = r2.info, s2 = Date.now(), a2 = wg(wg(wg({}, o2), n2), {}, { elapse: s2 - r2.startTime, eventType: t2, lts: s2 });
          this.send({ type: i2, data: a2 }, true);
        }
        pcStats(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2)
            return;
          const n2 = i2.info, r2 = Date.now(), o2 = wg(wg(wg({}, n2), t2), {}, { vid: void 0 === n2.vid ? 0 : Number(n2.vid), elapse: r2 - i2.startTime, eventType: uf.PC_STATS, lts: r2 });
          this.send({ type: lf.PC_STATS, data: o2 }, true);
        }
        onGatewayStream(e2, t2, i2, n2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2)
            return;
          const o2 = r2.info, s2 = Date.now(), a2 = wg(wg(wg({}, o2), n2), {}, { eventType: t2, lts: s2 });
          this.send({ type: i2, data: a2 }, true);
        }
        streamSwitch(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2)
            return;
          const n2 = i2.info, r2 = Date.now(), o2 = wg(wg({}, n2), {}, { eventType: uf.STREAM_SWITCH, lts: r2, isDual: t2.isdual, elapse: r2 - i2.startTime, success: t2.succ });
          this.send({ type: lf.STREAM_SWITCH, data: o2 }, true);
        }
        requestProxyAppCenter(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2)
            return;
          const n2 = i2.info, r2 = Date.now(), o2 = wg(wg({}, n2), {}, { eventType: uf.REQUEST_PROXY_APPCENTER, lts: r2, eventElapse: r2 - t2.lts, elapse: r2 - i2.startTime, APAddr: t2.APAddr, workerManagerList: t2.workerManagerList, response: t2.response, errorCode: t2.ec, success: t2.succ });
          this.send({ type: lf.REQUEST_PROXY_APPCENTER, data: o2 }, true);
        }
        requestProxyWorkerManager(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2)
            return;
          const n2 = i2.info, r2 = Date.now(), o2 = wg(wg({}, n2), {}, { eventType: uf.REQUEST_PROXY_WORKER_MANAGER, lts: r2, eventElapse: r2 - t2.lts, elapse: r2 - i2.startTime, workerManagerAddr: t2.workerManagerAddr, response: t2.response, errorCode: t2.ec, success: t2.succ });
          this.send({ type: lf.REQUEST_PROXY_WORKER_MANAGER, data: o2 }, true);
        }
        setProxyServer(e2) {
          this.proxyServer = e2, e2 ? OE.debug("reportProxyServerurl: ".concat(e2)) : OE.debug("disable reportProxyServerurl: ".concat(e2));
        }
        peerPublishStatus(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2)
            return;
          const n2 = i2.info, r2 = Date.now(), o2 = wg(wg({}, n2), {}, { subscribeElapse: t2.subscribeElapse, peer: t2.peer, peerPublishDuration: Math.max(t2.audioPublishDuration, t2.videoPublishDuration), audiotag: t2.audioPublishDuration > 0 ? 1 : -1, videotag: t2.videoPublishDuration > 0 ? 1 : -1, lts: r2, elapse: r2 - i2.startTime, joinChannelSuccessElapse: r2 - (i2.lastJoinSuccessTime || r2), peerPublishDurationVideo: t2.videoPublishDuration, peerPublishDurationAudio: t2.audioPublishDuration });
          this.send({ type: lf.PEER_PUBLISH_STATUS, data: o2 }, true);
        }
        workerEvent(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2)
            return;
          const n2 = i2.info, r2 = Date.now();
          (function(e3, t3, i3) {
            const n3 = e3[t3];
            if (!n3 || "string" != typeof n3)
              return [e3];
            e3[t3] = "";
            const r3 = XI(JSON.stringify(e3));
            let o2 = 0;
            const s2 = [];
            let a2 = 0;
            for (let c2 = 0; c2 < n3.length; c2++)
              a2 += n3.charCodeAt(c2) <= 127 ? 1 : 3, a2 <= i3 - r3 || (s2[s2.length] = JI(JI({}, e3), {}, { [t3]: n3.substring(o2, c2) }), o2 = c2, a2 = n3.charCodeAt(c2) <= 127 ? 1 : 3);
            o2 !== n3.length - 1 && (s2[s2.length] = JI(JI({}, e3), {}, { [t3]: n3.substring(o2) }));
            return s2;
          })(wg(wg(wg({}, n2), t2), {}, { elapse: r2 - i2.startTime, lts: r2, productType: "WebRTC" }), "payload", 1300).forEach((e3) => this.send({ type: lf.WORKER_EVENT, data: e3 }, true));
        }
        apworkerEvent(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2)
            return;
          const n2 = i2.info, r2 = Date.now(), o2 = wg(wg(wg({}, n2), t2), {}, { elapse: r2 - i2.startTime, lts: r2 });
          this.send({ type: lf.AP_WORKER_EVENT, data: o2 }, true);
        }
        joinWebProxyAP(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2)
            return;
          const n2 = i2.info, r2 = Date.now(), o2 = wg(wg(wg({}, n2), t2), {}, { elapse: r2 - i2.startTime, lts: r2, extend: t2.extend || void 0 });
          this.send({ type: lf.JOIN_WEB_PROXY_AP, data: o2 }, true);
        }
        WebSocketQuit(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2)
            return;
          const n2 = i2.info, r2 = Date.now(), o2 = wg(wg(wg({}, n2), t2), {}, { elapse: r2 - i2.startTime, lts: r2 });
          this.send({ type: lf.WEBSOCKET_QUIT, data: o2 }, true);
        }
        async sendCustomReportMessage(e2, t2) {
          if (this.customReportCount += t2.length, this.customReportCount > GE("CUSTOM_REPORT_LIMIT"))
            throw new SE(fE.CUSTOM_REPORT_FREQUENCY_TOO_HIGH);
          this.customReportCounterTimer || (this.customReportCounterTimer = window.setInterval(() => {
            this.customReportCount = 0;
          }, 5e3));
          const i2 = Date.now(), n2 = t2.map((t3) => ({ type: lf.USER_ANALYTICS, data: wg(wg({ sid: e2 }, t3), {}, { lts: i2 }) }));
          try {
            GE("NEW_REPORT_SERVER") ? await this.postDataToStatsCollector2(n2) : await this.postDataToStatsCollector(n2);
          } catch (e3) {
            throw OE.error("send custom report message failed", e3.toString()), new SE(fE.CUSTOM_REPORT_SEND_FAILED, e3.message);
          }
        }
        autoplayFailed(e2, t2, i2, n2) {
          if (!e2)
            return;
          const r2 = this.baseInfoMap.get(e2);
          if (!r2)
            return;
          const o2 = r2.info, s2 = Date.now(), a2 = wg(wg({}, o2), {}, { vid: void 0 === o2.vid ? 0 : Number(o2.vid), lts: s2, elapse: s2 - r2.startTime, cbRegistered: vg.onAutoplayFailed || vg.onAudioAutoplayFailed ? 1 : -1, errorMsg: i2, mediaType: t2, trackId: n2, extend: void 0 });
          this.send({ type: lf.AUTOPLAY_FAILED, data: a2 }, true);
        }
        sendApiInvoke(e2) {
          const t2 = GE("NOT_REPORT_EVENT");
          if (e2.tag && t2.includes && t2.includes(e2.tag))
            return false;
          if (null === e2.sid)
            return this.apiInvokeUploadPendingItems.push(e2), false;
          const i2 = this.baseInfoMap.get(e2.sid);
          if (!i2)
            return this.apiInvokeUploadPendingItems.push(e2), false;
          const { cname: n2, uid: r2, cid: o2 } = i2.info;
          e2.lts = e2.lts || Date.now();
          let s2 = void 0;
          if (e2.error)
            if (e2.error instanceof SE) {
              const { code: t3, message: i3 } = e2.error;
              s2 = t3 || (i3 || e2.error.toString());
            } else
              s2 = e2.error.toString();
          const a2 = { invokeId: e2.invokeId, sid: e2.sid, cname: n2, cid: o2, uid: r2, lts: e2.lts, success: e2.success, elapse: e2.lts - i2.startTime, execElapse: e2.lts - e2.apiInvokeTime, apiName: e2.name, options: e2.options ? JSON.stringify(e2.options) : void 0, execStates: e2.states ? JSON.stringify(e2.states) : void 0, execResult: e2.result ? JSON.stringify(e2.result) : void 0, errorCode: e2.error ? s2 : void 0, errorMsg: e2.error ? JSON.stringify(e2.error) : void 0 };
          return this.send({ type: lf.API_INVOKE, data: a2 }, false), true;
        }
        appendSessionId() {
          this.clientList.forEach((e2) => {
            if (e2._sessionId) {
              const t2 = this.apiInvokeUploadPendingItems.length;
              for (let i2 = 0; i2 < t2; i2++) {
                const t3 = this.apiInvokeUploadPendingItems.shift();
                t3 && (t3.sid = e2._sessionId, this.sendApiInvoke(Object.assign({}, t3)));
              }
            }
          });
        }
        send(e2, t2) {
          if (t2)
            return this.keyEventUploadPendingItems.push(e2), void this.sendItems(this.keyEventUploadPendingItems, true);
          this.normalEventUploadPendingItems.push(e2), this.normalEventUploadPendingItems.length > GE("NORMAL_EVENT_QUEUE_CAPACITY") && this.normalEventUploadPendingItems.splice(0, 1), this.normalEventUploadPendingItems.length >= 10 && this.sendItems(this.normalEventUploadPendingItems, false);
        }
        doSend() {
          this.keyEventUploadPendingItems.length > 0 && this.sendItems(this.keyEventUploadPendingItems, true), this.normalEventUploadPendingItems.length > 0 && Date.now() - this.lastSendNormalEventTime >= 5e3 && this.sendItems(this.normalEventUploadPendingItems, false);
        }
        sendItems(e2, t2) {
          const i2 = [], n2 = [];
          for (; e2.length; ) {
            const t3 = e2.shift();
            i2.length < 20 ? i2.push(t3) : n2.push(t3);
          }
          e2.push(...n2);
          for (const e3 of [...i2]) {
            var r2;
            if (-1 !== this.ltsList.indexOf(e3.data.lts))
              e3.data.lts = this.ltsList[this.ltsList.length - 1] + 1, this.ltsList.push(e3.data.lts);
            else
              this.ltsList.push(e3.data.lts), Hm(r2 = this.ltsList).call(r2, (e4, t3) => e4 - t3);
          }
          t2 || (this.lastSendNormalEventTime = Date.now());
          return GE("ENABLE_EVENT_REPORT") ? (i2.length && (GE("NEW_REPORT_SERVER") ? this.postDataToStatsCollector2(i2) : this.postDataToStatsCollector(i2)).catch(((e3) => (i3) => {
            GE("EVENT_REPORT_RETRY") && (t2 ? this.keyEventUploadPendingItems = this.keyEventUploadPendingItems.concat(e3) : (this.normalEventUploadPendingItems = this.normalEventUploadPendingItems.concat(e3), this.normalEventUploadPendingItems.length > GE("NORMAL_EVENT_QUEUE_CAPACITY") && (this.normalEventUploadPendingItems.splice(0, this.normalEventUploadPendingItems.length - GE("NORMAL_EVENT_QUEUE_CAPACITY")), OE.warning("report: drop normal events"))));
          })(i2)), e2) : e2;
        }
        async postDataToStatsCollector2(e2) {
          Ig.networkState === PS.OFFLINE && await Sl.race([Ig.onlineWaiter, zI(2 * TE.maxRetryTimeout)]);
          const t2 = (e3) => {
            let t3 = new Uint8Array();
            return e3.forEach((e4) => {
              const i3 = Ag(JSON.stringify(e4.data)), n3 = new ArrayBuffer(5), r2 = ((e5) => {
                let t4 = 0;
                return Object.entries(lf).forEach((i4) => {
                  let [n4, r3] = i4;
                  r3 === e5.type && (t4 = pf[n4]);
                }), t4;
              })(e4), o2 = new DataView(n3);
              o2.setUint16(0, i3.byteLength, true), o2.setUint8(2, 255 & r2), o2.setUint8(3, r2 >>> 8 & 255), o2.setUint8(4, r2 >>> 16 & 255), t3 = Og(t3, new Uint8Array(n3)), t3 = Og(t3, i3);
            }), t3;
          }, i2 = "event";
          let n2 = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(GE("NEW_REPORT_SERVER_DOMAINS")[0], "&p=443&d=").concat(i2) : "https://".concat(GE("NEW_REPORT_SERVER_DOMAINS")[0], "/").concat(i2);
          for (let r2 = 0; r2 < 2; r2 += 1) {
            1 === r2 && (n2 = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(GE("NEW_REPORT_SERVER_DOMAINS")[1], "&p=443&d=").concat(i2) : "https://".concat(GE("NEW_REPORT_SERVER_DOMAINS")[1], "/").concat(i2));
            try {
              await gg(n2, { timeout: 1e4, data: t2(e2), headers: wg(wg({ biz: "webrtc", sendts: Math.round(Date.now() / 1e3), debug: "false" }, this._appId && { appid: this._appId }), {}, { "Content-Type": "application/octet-stream" }) }, true);
            } catch (e3) {
              if (1 === r2)
                throw e3;
              continue;
            }
            return;
          }
        }
        async postDataToStatsCollector(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          const i2 = { msgType: "EventMessages", sentTs: Math.round(Date.now() / 1e3), payloads: e2.map((e3) => JSON.stringify(e3)), vid: ((e3) => {
            const t3 = e3 && e3.data.sid && this.baseInfoMap.get(e3.data.sid);
            return t3 && t3.info.vid && +t3.info.vid || 0;
          })(e2[0]) };
          Ig.networkState === PS.OFFLINE && await Sl.race([Ig.onlineWaiter, zI(2 * TE.maxRetryTimeout)]);
          const n2 = t2 ? "/events/proto-raws" : "/events/messages";
          let r2 = this.url || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(GE("EVENT_REPORT_DOMAIN"), "&p=").concat(GE("STATS_COLLECTOR_PORT"), "&d=").concat(n2) : "https://".concat(GE("EVENT_REPORT_DOMAIN"), ":").concat(GE("STATS_COLLECTOR_PORT")).concat(n2));
          for (let e3 = 0; e3 < 2; e3 += 1) {
            1 === e3 && (r2 = this.backupUrl || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(GE("EVENT_REPORT_BACKUP_DOMAIN"), "&p=").concat(GE("STATS_COLLECTOR_PORT"), "&d=").concat(n2) : "https://".concat(GE("EVENT_REPORT_BACKUP_DOMAIN"), ":").concat(GE("STATS_COLLECTOR_PORT")).concat(n2)));
            try {
              t2 ? await Rg(r2, { timeout: 1e4, data: i2 }) : await gg(r2, { timeout: 1e4, data: i2 });
            } catch (t3) {
              if (1 === e3)
                throw t3;
              continue;
            }
            return;
          }
        }
        createBaseInfo(e2, t2) {
          const i2 = Object.assign({}, df);
          return i2.sid = e2, this.baseInfoMap.set(e2, { info: i2, startTime: t2 }), i2;
        }
        reportResourceTiming(e2, t2) {
          const i2 = performance.getEntriesByName(e2), n2 = i2[i2.length - 1];
          n2 && this.reportApiInvoke(t2, { name: "Client.resourceTiming", options: n2, tag: Ef.TRACER }).onSuccess();
        }
      }();
      mE.on("REPORT_LOG_UPLOAD", (e2) => {
        e2.networkState = Ig.networkState, Pg.reportApiInvoke(null, { name: "logUploadError", options: e2, tag: Ef.TRACER });
      });
      class Lg extends EE {
        constructor(e2, t2) {
          super(), _p(this, "trackMediaType", void 0), _p(this, "_ID", void 0), _p(this, "_rtpTransceiver", void 0), _p(this, "_lowRtpTransceiver", void 0), _p(this, "_hints", []), _p(this, "_isClosed", false), _p(this, "_originMediaStreamTrack", void 0), _p(this, "_mediaStreamTrack", void 0), _p(this, "_external", {}), this._ID = t2 || ZI(8, "track-"), this._originMediaStreamTrack = e2, this._mediaStreamTrack = e2, function(e3) {
            QE.includes(e3) || QE.push(e3);
          }(this);
        }
        toString() {
          return this._ID;
        }
        getTrackId() {
          return this._ID;
        }
        getMediaStreamTrack(e2) {
          if (!e2) {
            const e3 = Pg.reportApiInvoke(null, { name: _f.GET_MEDIA_STREAM_TRACK, options: [], tag: Ef.TRACER });
            this._mediaStreamTrack && "string" == typeof this._mediaStreamTrack.label ? e3.onSuccess(this._mediaStreamTrack.label) : e3.onSuccess("");
          }
          return this._mediaStreamTrack;
        }
        getRTCRtpTransceiver(e2) {
          return e2 === hS.LOW_STREAM ? this._lowRtpTransceiver : this._rtpTransceiver;
        }
        getMediaStreamTrackSettings() {
          return this.getMediaStreamTrack(true).getSettings();
        }
        close() {
          this._isClosed = true, this._lowRtpTransceiver = void 0, this._rtpTransceiver = void 0, function(e2) {
            const t2 = QE.indexOf(e2);
            -1 !== t2 && QE.splice(t2, 1);
          }(this), this.emit(mS.CLOSED);
        }
        _updateRtpTransceiver(e2, t2) {
          if (t2 === hS.LOW_STREAM) {
            if (this._lowRtpTransceiver === e2)
              return;
            this._lowRtpTransceiver = e2;
          } else {
            if (this._rtpTransceiver === e2)
              return;
            this._rtpTransceiver = e2;
          }
          this.emit(ES.TRANSCEIVER_UPDATED, e2, t2);
        }
      }
      let kg, Mg = 1;
      class Ug {
        constructor(e2) {
          _p(this, "lockingPromise", Sl.resolve()), _p(this, "locks", 0), _p(this, "name", ""), _p(this, "lockId", void 0), this.lockId = Mg++, e2 && (this.name = e2), OE.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is created."));
        }
        get isLocked() {
          return this.locks > 0;
        }
        lock(e2) {
          let t2;
          this.locks += 1, OE.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is locked, current queue ").concat(this.locks, ". ").concat("string" == typeof e2 ? e2 : ""));
          const i2 = new Sl((i3) => {
            t2 = () => {
              this.locks -= 1, OE.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is not locked, current queue ").concat(this.locks, ". ").concat("string" == typeof e2 ? e2 : "")), i3();
            };
          }), n2 = this.lockingPromise.then(() => t2);
          return this.lockingPromise = this.lockingPromise.then(() => i2), n2;
        }
      }
      function xg(e2, t2) {
        return function(i2, n2, r2) {
          const o2 = r2.value;
          if ("function" != typeof o2)
            throw new Error("Cannot use mutex on object property.");
          return r2.value = async function() {
            const i3 = this[t2];
            if (!i3)
              throw new Error("mutex property key ".concat(t2, " doesn't exist on ").concat(e2));
            const r3 = await i3.lock("From ".concat(e2, ".").concat(n2));
            try {
              for (var s2 = arguments.length, a2 = new Array(s2), c2 = 0; c2 < s2; c2++)
                a2[c2] = arguments[c2];
              return await o2.apply(this, a2);
            } finally {
              r3();
            }
          }, r2;
        };
      }
      class Vg extends Lg {
        get isExternalTrack() {
          return this._isExternalTrack;
        }
        get muted() {
          return this._muted;
        }
        get enabled() {
          return this._enabled;
        }
        get processorContext() {
          return this._processorContext;
        }
        set processorContext(e2) {
          this._processorContext = e2;
        }
        constructor(e2, t2) {
          super(e2, t2), _p(this, "_enabled", true), _p(this, "_muted", false), _p(this, "_isExternalTrack", false), _p(this, "_isClosed", false), _p(this, "_enabledMutex", void 0), _p(this, "processor", void 0), _p(this, "_processorContext", void 0), _p(this, "_handleTrackEnded", () => {
            this.onTrackEnded();
          }), this._enabledMutex = new Ug("".concat(this.getTrackId())), e2.addEventListener("ended", this._handleTrackEnded);
        }
        getTrackLabel() {
          var e2, t2;
          return null !== (e2 = null === (t2 = this._originMediaStreamTrack) || void 0 === t2 ? void 0 : t2.label) && void 0 !== e2 ? e2 : "";
        }
        close() {
          this._isClosed || (this.stop(), this._originMediaStreamTrack.stop(), this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack.stop(), this._mediaStreamTrack = null), this._originMediaStreamTrack = null, this._enabledMutex = null, OE.debug("[".concat(this.getTrackId(), "] close")), this.emit(uS.NEED_CLOSE), super.close());
        }
        async _updateOriginMediaStreamTrack(e2, t2) {
          let i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          this._isExternalTrack = i2, e2 !== this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), t2 && this._originMediaStreamTrack.stop(), e2.addEventListener("ended", this._handleTrackEnded), this._originMediaStreamTrack = e2, this._muted && (this._originMediaStreamTrack.enabled = false), this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await rC(this, uS.NEED_REPLACE_TRACK, this), this.processor && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }));
        }
        _getDefaultPlayerConfig() {
          return {};
        }
        onTrackEnded() {
          OE.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(mS.TRACK_ENDED);
        }
        stateCheck(e2, t2) {
          if (OE.debug("check track state, [muted: ".concat(this._muted, ", enabled: ").concat(this._enabled, "] to [").concat(e2, ": ").concat(t2, "]")), Km(t2, e2), this._enabled && this._muted && "enabled" === e2 && false === t2)
            throw new SE(fE.TRACK_STATE_UNREACHABLE, "cannot set enabled while the track is muted").print();
          if (!this._enabled && !this._muted && "muted" === e2 && true === t2)
            throw new SE(fE.TRACK_STATE_UNREACHABLE, "cannot set muted while the track is disabled").print();
        }
        getProcessorStats() {
          return this.processorContext.gatherStats();
        }
        getProcessorUsage() {
          return this.processorContext.gatherUsage();
        }
      }
      function jg(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      !function(e2) {
        e2.IOS_15_16_INTERRUPTION_START = "ios15_16-interruption-start", e2.IOS_15_16_INTERRUPTION_END = "ios15_16-interruption-end", e2.IOS_INTERRUPTION_START = "ios-interruption-start", e2.IOS_INTERRUPTION_END = "ios-interruption-end", e2.STATE_CHANGE = "state-change";
      }(kg || (kg = {}));
      const Fg = window.AudioContext || window.webkitAudioContext;
      let Bg = null;
      const Gg = new class extends EE {
        constructor() {
          super(...arguments), _p(this, "prevState", void 0), _p(this, "curState", void 0), _p(this, "currentTime", void 0), _p(this, "currentTimeStuckAt", void 0), _p(this, "interruptDetectorTrack", void 0), _p(this, "onLocalAudioTrackMute", () => {
            OE.info("ios15-interruption-start"), this.emit(kg.IOS_15_16_INTERRUPTION_START);
          }), _p(this, "onLocalAudioTrackUnmute", async () => {
            OE.info("ios15-interruption-end"), "running" !== this.curState || this.duringInterruption ? OE.info("ios15-interruption-end-canceled") : (Bg && await Bg.suspend(), this.emit(kg.IOS_15_16_INTERRUPTION_END));
          });
        }
        get duringInterruption() {
          return "running" === this.prevState && "interrupted" === this.curState;
        }
        bindInterruptDetectorTrack(e2) {
          OE.debug("webaudio bindInterruptDetectorTrack ".concat(e2.getTrackId())), this.interruptDetectorTrack || (this.interruptDetectorTrack = e2, this.interruptDetectorTrack._mediaStreamTrack.onmute = this.onLocalAudioTrackMute, this.interruptDetectorTrack._mediaStreamTrack.onunmute = this.onLocalAudioTrackUnmute);
        }
        unbindInterruptDetectorTrack(e2) {
          OE.debug("webaudio unbindInterruptDetectorTrack ".concat(e2.getTrackId())), this.interruptDetectorTrack && this.interruptDetectorTrack === e2 && (this.interruptDetectorTrack._mediaStreamTrack && (this.interruptDetectorTrack._mediaStreamTrack.onmute = null, this.interruptDetectorTrack._mediaStreamTrack.onunmute = null), this.interruptDetectorTrack = void 0);
        }
      }();
      function Wg() {
        if (!Fg)
          return void OE.error("your browser is not support web audio");
        OE.info("create audio context");
        const e2 = function(e3) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? jg(Object(i2), true).forEach(function(t3) {
              _p(e3, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i2)) : jg(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e3, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e3;
        }({}, GE("WEBAUDIO_INIT_OPTIONS"));
        OE.debug("audio context init option:", JSON.stringify(e2)), Bg = new Fg(e2), Gg.curState = Bg.state, Bg.onstatechange = () => {
          Gg.prevState = Gg.curState, Gg.curState = Bg ? Bg.state : void 0;
          const { prevState: e3, curState: t2 } = Gg, i2 = "running" === t2, n2 = "interrupted" === t2, r2 = "running" === e3, o2 = "suspended" === e3, s2 = "interrupted" === e3, a2 = xh().osVersion;
          (Yh() || tp()) && r2 && n2 && (OE.info("ios".concat(a2, "-interruption-start")), Gg.emit(kg.IOS_INTERRUPTION_START)), (Yh() || tp()) && (o2 || s2) && i2 && (OE.info("ios".concat(a2, "-interruption-end")), Gg.emit(kg.IOS_INTERRUPTION_END)), e3 !== t2 && (OE.debug("AudioContext State Change", "".concat(e3, "=>").concat(t2)), Gg.emit(kg.STATE_CHANGE));
        }, setInterval(() => {
          var e3;
          const t2 = null === (e3 = Bg) || void 0 === e3 ? void 0 : e3.currentTime;
          if (Gg.currentTime !== t2)
            Gg.currentTimeStuckAt && (OE.debug("AudioContext current time resume at ".concat(t2)), Gg.currentTimeStuckAt = void 0), Gg.currentTime = t2;
          else {
            if (t2 !== Gg.currentTimeStuckAt) {
              Pg.reportApiInvoke(null, { name: "WEB_AUDIO_CURRENT_TIME_STUCK", options: { currentTime: t2 }, tag: Ef.TRACER }).onSuccess(), OE.warning("AudioContext current time stuck at ".concat(t2));
            }
            Gg.currentTimeStuckAt = t2;
          }
        }, 5e3), async function(e3) {
          const t2 = ["click", "contextmenu", "auxclick", "dblclick", "mousedown", "mouseup", "touchend", "keydown", "keyup"];
          let i2, n2 = false, r2 = false, o2 = false;
          function s2(t3) {
            "running" === e3.state ? a2(false) : Yh() || tp() ? "suspended" === e3.state && (a2(true), t3 && e3.resume().then(d2, d2)) : "closed" !== e3.state && (a2(true), t3 && e3.resume().then(d2, d2));
          }
          function a2(e4) {
            if (n2 !== e4) {
              n2 = e4;
              for (let i3 = 0, n3 = t2; i3 < n3.length; i3 += 1) {
                const t3 = n3[i3];
                e4 ? window.addEventListener(t3, u2, { capture: true, passive: true }) : window.removeEventListener(t3, u2, { capture: true, passive: true });
              }
            }
          }
          function c2() {
            s2(true);
          }
          function d2() {
            s2(false);
          }
          function u2() {
            s2(true);
          }
          function l2(e4) {
            if (!o2)
              if (i2.paused)
                if (e4) {
                  h2(false), o2 = true;
                  let e5 = void 0;
                  try {
                    e5 = i2.play(), e5 ? e5.then(p2, p2) : (i2.addEventListener("playing", p2), i2.addEventListener("abort", p2), i2.addEventListener("error", p2));
                  } catch (e6) {
                    p2();
                  }
                } else
                  h2(true);
              else
                h2(false);
          }
          function h2(e4) {
            if (r2 !== e4) {
              r2 = e4;
              for (let i3 = 0, n3 = t2; i3 < n3.length; i3++) {
                const t3 = n3[i3];
                e4 ? window.addEventListener(t3, _2, { capture: true, passive: true }) : window.removeEventListener(t3, _2, { capture: true, passive: true });
              }
            }
          }
          function p2() {
            i2.removeEventListener("playing", p2), i2.removeEventListener("abort", p2), i2.removeEventListener("error", p2), o2 = false, l2(false);
          }
          function _2() {
            l2(true);
          }
          if (Yh()) {
            const t3 = e3.createMediaStreamDestination(), n3 = document.createElement("div");
            n3.innerHTML = "<audio x-webkit-airplay='deny'></audio>", i2 = n3.children.item(0), i2.controls = false, i2.disableRemotePlayback = true, i2.preload = "auto", i2.srcObject = t3.stream, l2(true);
          }
          Gg.on(kg.STATE_CHANGE, c2), s2(false);
        }(Bg);
      }
      function Hg() {
        if (!Bg) {
          if (Wg(), !Bg)
            throw new SE(fE.NOT_SUPPORTED, "can not create audio context");
          return Bg;
        }
        return Bg;
      }
      function Kg() {
        return !!Bg;
      }
      function Yg(e2) {
        if (function() {
          if (null !== qg)
            return qg;
          const e3 = Hg(), t3 = e3.createBufferSource(), i3 = e3.createGain(), n2 = e3.createGain();
          t3.connect(i3), t3.connect(n2), t3.disconnect(i3);
          let r2 = false;
          try {
            t3.disconnect(i3);
          } catch (e4) {
            r2 = true;
          }
          return t3.disconnect(), qg = r2, r2;
        }())
          return;
        const t2 = e2.connect, i2 = e2.disconnect;
        e2.connect = (i3, n2, r2) => (e2._inputNodes || (e2._inputNodes = []), e2._inputNodes.includes(i3) || (i3 instanceof AudioNode ? (e2._inputNodes.push(i3), t2.call(e2, i3, n2, r2)) : t2.call(e2, i3, n2)), e2), e2.disconnect = (n2, r2, o2) => {
          i2.call(e2), n2 ? aC(e2._inputNodes, n2) : e2._inputNodes = [];
          for (const i3 of e2._inputNodes)
            t2.call(e2, i3);
        };
      }
      let qg = null;
      function Jg(e2, t2) {
        let i2 = false;
        const n2 = 1 / t2;
        if (GE("DISABLE_WEBAUDIO")) {
          const t3 = window.setInterval(() => {
            i2 ? window.clearInterval(t3) : e2(performance.now() / 1e3);
          }, 1e3 * n2);
        } else {
          const t3 = Hg();
          let r2 = t3.createGain();
          r2.gain.value = 0, r2.connect(t3.destination);
          const o2 = () => {
            if (i2)
              return void (r2 = null);
            const s2 = t3.createOscillator();
            s2.onended = o2, s2.connect(r2), s2.start(0), s2.stop(t3.currentTime + n2), e2(t3.currentTime);
          };
          o2();
        }
        return () => {
          i2 = true;
        };
      }
      class Xg {
        constructor() {
          _p(this, "context", void 0), _p(this, "analyserNode", void 0), _p(this, "sourceNode", void 0), this.context = Hg(), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = 0.4;
        }
        updateSource(e2) {
          if (e2 !== this.sourceNode) {
            if (this.sourceNode)
              try {
                this.sourceNode.disconnect(this.analyserNode);
              } catch (e3) {
              }
            this.sourceNode = e2, null == e2 || e2.connect(this.analyserNode);
          }
        }
        getVolumeLevel() {
          if (!this.sourceNode)
            return 0;
          if (!this.context || Yh() || tp() || "running" !== this.context.state && this.context.resume(), !this.analyserNode)
            return 0;
          const e2 = new Float32Array(this.analyserNode.fftSize);
          if (this.analyserNode.getFloatTimeDomainData)
            this.analyserNode.getFloatTimeDomainData(e2);
          else {
            const t3 = new Uint8Array(this.analyserNode.fftSize);
            this.analyserNode.getByteTimeDomainData(t3);
            for (let i2 = 0; i2 < e2.length; ++i2)
              e2[i2] = t3[i2] / 128 - 1;
          }
          const t2 = zi(e2).call(e2, (e3, t3) => e3 + t3 * t3, 0) / e2.length;
          return Math.max(10 * Math.log10(t2) + 100, 0) / 100;
        }
        getAnalyserNode() {
          return this.analyserNode;
        }
        rebuildAnalyser() {
          try {
            var e2, t2;
            null === (e2 = this.sourceNode) || void 0 === e2 || e2.disconnect(this.analyserNode), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = 0.4, null === (t2 = this.sourceNode) || void 0 === t2 || t2.connect(this.analyserNode);
          } catch (e3) {
            OE.warning("rebuild analyser node failed.");
          }
        }
        destroy() {
          this.updateSource(void 0);
        }
      }
      class zg extends EE {
        get processSourceNode() {
          return this.sourceNode;
        }
        set processedNode(e2) {
          var t2;
          if (!this.isDestroyed && this._processedNode !== e2) {
            try {
              var i2;
              null === (i2 = this.sourceNode) || void 0 === i2 || i2.disconnect(this.outputNode);
            } catch (e3) {
            }
            null === (t2 = this._processedNode) || void 0 === t2 || t2.disconnect(), this._processedNode = e2, this.connect();
          }
        }
        get processedNode() {
          return this._processedNode;
        }
        constructor() {
          super(), _p(this, "outputNode", void 0), _p(this, "outputTrack", void 0), _p(this, "isPlayed", false), _p(this, "sourceNode", void 0), _p(this, "context", void 0), _p(this, "audioBufferNode", void 0), _p(this, "destNode", void 0), _p(this, "audioOutputLevel", 0), _p(this, "volumeLevelAnalyser", void 0), _p(this, "_processedNode", void 0), _p(this, "playNode", void 0), _p(this, "isDestroyed", false), _p(this, "onNoAudioInput", void 0), _p(this, "isNoAudioInput", false), _p(this, "_noAudioInputCount", 0), this.context = Hg(), this.playNode = this.context.destination, this.outputNode = this.context.createGain(), Yg(this.outputNode), this.volumeLevelAnalyser = new Xg();
        }
        startGetAudioBuffer(e2) {
          this.audioBufferNode || (this.audioBufferNode = this.context.createScriptProcessor(e2), this.outputNode.connect(this.audioBufferNode), this.audioBufferNode.connect(this.context.destination), this.audioBufferNode.onaudioprocess = (e3) => {
            this.emit(Lf.ON_AUDIO_BUFFER, function(e4) {
              for (let t2 = 0; t2 < e4.outputBuffer.numberOfChannels; t2 += 1) {
                const i2 = e4.outputBuffer.getChannelData(t2);
                for (let e5 = 0; e5 < i2.length; e5 += 1)
                  i2[e5] = 0;
              }
              return e4.inputBuffer;
            }(e3));
          });
        }
        stopGetAudioBuffer() {
          this.audioBufferNode && (this.audioBufferNode.onaudioprocess = null, this.outputNode.disconnect(this.audioBufferNode), this.audioBufferNode = void 0);
        }
        createOutputTrack() {
          if (!JS().webAudioMediaStreamDest)
            throw new SE(fE.NOT_SUPPORTED, "your browser is not support audio processor");
          return this.destNode && this.outputTrack || (this.destNode = this.context.createMediaStreamDestination(), this.outputNode.connect(this.destNode), this.outputTrack = this.destNode.stream.getAudioTracks()[0]), this.outputTrack;
        }
        play(e2) {
          "running" !== this.context.state && dC(() => {
            Gg.emit("autoplay-failed");
          }), this.isPlayed = true, this.playNode = e2 || this.context.destination, this.outputNode.connect(this.playNode);
        }
        stop() {
          if (this.isPlayed)
            try {
              this.outputNode.disconnect(this.playNode);
            } catch (e2) {
            }
          this.isPlayed = false;
        }
        getAccurateVolumeLevel() {
          return this.volumeLevelAnalyser.getVolumeLevel();
        }
        async checkHasAudioInput() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
          if (e2 > 5)
            return this.isNoAudioInput = true, this.onNoAudioInput && this.onNoAudioInput(), false;
          Yh() || tp() ? "suspended" === this.context.state && this.context.resume() : "running" !== this.context.state && this.context.resume();
          const t2 = this.volumeLevelAnalyser.getAnalyserNode();
          let i2;
          t2.getFloatTimeDomainData ? (i2 = new Float32Array(t2.fftSize), t2.getFloatTimeDomainData(i2)) : (i2 = new Uint8Array(t2.fftSize), t2.getByteTimeDomainData(i2));
          let n2 = false;
          for (let e3 = 0; e3 < i2.length; e3++)
            0 !== i2[e3] && (n2 = true);
          return n2 ? (this.isNoAudioInput = false, true) : (await zI(200), await this.checkHasAudioInput(e2 ? e2 + 1 : 1) && n2);
        }
        getAudioVolume() {
          return this.outputNode.gain.value;
        }
        setVolume(e2) {
          this.outputNode.gain.setValueAtTime(e2, this.context.currentTime);
        }
        destroy() {
          this.disconnect(), this.stop(), this.isDestroyed = true, this.onNoAudioInput = void 0;
        }
        disconnect() {
          var e2, t2;
          null === (e2 = this.processedNode) || void 0 === e2 || e2.disconnect(), null === (t2 = this.sourceNode) || void 0 === t2 || t2.disconnect(), this.outputNode && this.outputNode.disconnect();
        }
        connect() {
          var e2;
          this.processedNode ? null === (e2 = this.processedNode) || void 0 === e2 || e2.connect(this.outputNode) : this.sourceNode && this.sourceNode.connect(this.outputNode);
          this.volumeLevelAnalyser.updateSource(this.outputNode);
        }
      }
      class Qg extends zg {
        get isFreeze() {
          return false;
        }
        constructor(e2, t2, i2) {
          var n2;
          if (super(), _p(this, "sourceNode", void 0), _p(this, "track", void 0), _p(this, "clonedTrack", void 0), _p(this, "audioElement", void 0), _p(this, "isCurrentTrackCloned", false), _p(this, "isRemoteTrack", false), _p(this, "originVolumeLevelAnalyser", void 0), _p(this, "rebuildWebAudio", async () => {
            if (OE.debug("ready to rebuild web audio, state:", this.context.state), this.isNoAudioInput && await this.checkHasAudioInput(), !this.isNoAudioInput || this.isDestroyed)
              return document.body.removeEventListener("click", this.rebuildWebAudio, true), void OE.debug("rebuild web audio success, current volume status", this.getAccurateVolumeLevel());
            this.context.resume().then(() => OE.info("resume success")), OE.debug("rebuild web audio because of ios 12 bugs"), this.disconnect();
            const e3 = this.track;
            this.track = this.track.clone(), this.isCurrentTrackCloned ? e3.stop() : this.isCurrentTrackCloned = true;
            const t3 = new MediaStream([this.track]);
            this.sourceNode = this.context.createMediaStreamSource(t3), Yg(this.sourceNode), this.volumeLevelAnalyser.rebuildAnalyser();
            const i3 = this.outputNode.gain.value;
            this.outputNode = this.context.createGain(), this.outputNode.gain.setValueAtTime(i3, this.context.currentTime), Yg(this.outputNode), this.emit(Lf.UPDATE_SOURCE), this.connect(), this.audioElement.srcObject = t3, this.isPlayed && this.play(this.playNode), this.checkHasAudioInput();
          }), "audio" !== e2.kind)
            throw new SE(fE.UNEXPECTED_ERROR);
          this.track = e2;
          const r2 = new MediaStream([this.track]);
          if (this.isRemoteTrack = !!t2, this.sourceNode = this.context.createMediaStreamSource(r2), Yg(this.sourceNode), i2) {
            const e3 = i2.clone();
            e3.enabled = true, this.clonedTrack = e3, OE.debug("create an unmuted track ".concat(e3.id, " from the original track ").concat(i2.id, " to get the volume"));
            const t3 = this.context.createMediaStreamSource(new MediaStream([e3]));
            Yg(t3), this.originVolumeLevelAnalyser = new Xg(), this.originVolumeLevelAnalyser.updateSource(t3);
          }
          this.connect(), this.audioElement = document.createElement("audio"), this.audioElement.srcObject = r2;
          const o2 = xh();
          t2 && o2.os === bh.IOS && Number(null === (n2 = o2.osVersion) || void 0 === n2 ? void 0 : n2.split(".")[0]) < 15 && (Gg.on(kg.STATE_CHANGE, () => {
            "suspended" === this.context.state ? document.body.addEventListener("click", this.rebuildWebAudio, true) : "running" === this.context.state && this.rebuildWebAudio();
          }), this.checkHasAudioInput().then((e3) => {
            e3 || document.body.addEventListener("click", this.rebuildWebAudio, true);
          }));
        }
        updateTrack(e2) {
          this.sourceNode.disconnect(), this.track = e2, this.isCurrentTrackCloned = false;
          const t2 = new MediaStream([e2]);
          this.sourceNode = this.context.createMediaStreamSource(t2), Yg(this.sourceNode), this.processedNode || this.sourceNode.connect(this.outputNode), this.emit(Lf.UPDATE_SOURCE), this.audioElement.srcObject = t2;
        }
        destroy() {
          var e2;
          this.audioElement.srcObject = null, this.audioElement.remove(), Gg.off("state-change", this.rebuildWebAudio), null === (e2 = this.originVolumeLevelAnalyser) || void 0 === e2 || e2.destroy(), this.clonedTrack = void 0, super.destroy();
        }
        createMediaStreamSourceNode(e2) {
          return this.context.createMediaStreamSource(new MediaStream([e2]));
        }
        updateOriginTrack(e2) {
          const t2 = e2.clone();
          t2.enabled = true, this.clonedTrack && (this.clonedTrack.stop(), this.clonedTrack = t2), OE.debug("create an unmuted track ".concat(t2.id, " from the original track ").concat(e2.id, " to get the volume"));
          const i2 = this.context.createMediaStreamSource(new MediaStream([t2]));
          Yg(i2), this.originVolumeLevelAnalyser && this.originVolumeLevelAnalyser.updateSource(i2);
        }
        getOriginVolumeLevel() {
          return this.originVolumeLevelAnalyser ? this.originVolumeLevelAnalyser.getVolumeLevel() : this.getAccurateVolumeLevel();
        }
      }
      async function Zg(e2, t2) {
        const i2 = (e3, t3) => e3 ? "number" != typeof e3 ? e3.max || e3.exact || e3.ideal || e3.min || t3 : e3 : t3, n2 = { audio: false, video: { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: e2, maxHeight: i2(t2.height, 1080), maxWidth: i2(t2.width, 1920) } } };
        return t2.frameRate && "number" != typeof t2.frameRate ? (n2.video.mandatory.maxFrameRate = t2.frameRate.max, n2.video.mandatory.minFrameRate = t2.frameRate.min) : "number" == typeof t2.frameRate && (n2.video.mandatory.maxFrameRate = t2.frameRate), await navigator.mediaDevices.getUserMedia(n2);
      }
      async function $g(e2) {
        const t2 = await eR(e2.mediaSource), i2 = await function(e3) {
          return new Sl((t3, i3) => {
            const n2 = document.createElement("div");
            n2.innerText = "share screen", n2.setAttribute("style", "text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;");
            const r2 = document.createElement("div");
            r2.setAttribute("style", "width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;");
            const o2 = document.createElement("div");
            o2.innerText = "Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share.", o2.setAttribute("style", "height: 12%;");
            const s2 = document.createElement("div");
            s2.setAttribute("style", "width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;");
            const a2 = document.createElement("div");
            a2.setAttribute("style", "text-align: right; padding: 16px 0;");
            const c2 = document.createElement("button");
            c2.innerHTML = "cancel", c2.setAttribute("style", "width: 85px;"), c2.onclick = () => {
              document.body.removeChild(d2);
              const e4 = new Error("NotAllowedError");
              e4.name = "NotAllowedError", i3(e4);
            }, a2.appendChild(c2), r2.appendChild(o2), r2.appendChild(s2), r2.appendChild(a2);
            const d2 = document.createElement("div");
            d2.setAttribute("style", "position: fixed; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);"), d2.appendChild(n2), d2.appendChild(r2), document.body.appendChild(d2), e3.map((e4) => {
              if (e4.id) {
                const i4 = document.createElement("div");
                i4.setAttribute("style", "width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;");
                let n3 = e4.thumbnail;
                const { width: r3 } = n3.getSize();
                r3 > 1920 && (n3 = n3.resize({ width: 1920 })), i4.innerHTML = '<div style="height: 120px; display: table-cell; vertical-align: middle;"><img style="width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);" src=' + n3.toDataURL() + ' /></div><span style="	height: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + (e4.name.replace(/[\u00A0-\u9999<>\&]/g, function(e5) {
                  return "&#" + e5.charCodeAt(0) + ";";
                }) + "</span>"), i4.onclick = () => {
                  document.body.removeChild(d2), t3(e4.id);
                }, s2.appendChild(i4);
              }
            });
          });
        }(t2);
        return await Zg(i2, e2);
      }
      async function eR(e2) {
        let t2 = ["window", "screen"];
        "application" !== e2 && "window" !== e2 || (t2 = ["window"]), "screen" === e2 && (t2 = ["screen"]);
        const i2 = iR();
        if (!i2)
          throw new SE(fE.ELECTRON_IS_NULL);
        let n2 = null;
        try {
          var r2;
          n2 = (null === (r2 = i2.desktopCapturer) || void 0 === r2 ? void 0 : r2.getSources({ types: t2 })) || i2.ipcRenderer.invoke("DESKTOP_CAPTURER_GET_SOURCES", { types: t2 });
        } catch (e3) {
          n2 = null;
        }
        n2 && n2.then || (n2 = new Sl((e3, n3) => {
          i2.desktopCapturer.getSources({ types: t2 }, (t3, i3) => {
            t3 ? n3(t3) : e3(i3);
          });
        }));
        try {
          return await n2;
        } catch (e3) {
          throw new SE(fE.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR, e3.toString());
        }
      }
      let tR = null;
      function iR() {
        if (tR)
          return tR;
        try {
          return tR = window.require("electron"), tR;
        } catch (e2) {
          return null;
        }
      }
      function nR(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      const rR = new Ug("safari");
      let oR = false, sR = false;
      async function aR(e2, t2) {
        let i2 = 0, n2 = null;
        for (; i2 < 2; )
          try {
            n2 = await cR(e2, t2, i2 > 0);
            break;
          } catch (e3) {
            if (e3 instanceof SE)
              throw OE.error("[".concat(t2, "] ").concat(e3.toString())), e3;
            const n3 = dR(e3.name || e3.code || e3, e3.message);
            if (n3.code === fE.MEDIA_OPTION_INVALID) {
              OE.debug("[".concat(t2, "] detect media option invalid, retry")), i2 += 1, await zI(500);
              continue;
            }
            throw OE.error("[".concat(t2, "] ").concat(n3.toString())), n3;
          }
        if (!n2)
          throw new SE(fE.UNEXPECTED_ERROR, "can not find stream after getUserMedia");
        return n2;
      }
      async function cR(e2, t2, i2) {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)
          throw new SE(fE.NOT_SUPPORTED, "can not find getUserMedia");
        i2 && (e2.video && (delete e2.video.width, delete e2.video.height), e2.screen && (delete e2.screen.width, delete e2.screen.height));
        const n2 = JS(), r2 = new MediaStream();
        if (e2.audioSource && r2.addTrack(e2.audioSource), e2.videoSource && r2.addTrack(e2.videoSource), !e2.audio && !e2.video && !e2.screen)
          return OE.debug("Using Video Source/ Audio Source"), r2;
        if (e2.screen)
          if (iR())
            if (e2.screen.sourceId) {
              uR(r2, await Zg(e2.screen.sourceId, e2.screen));
            } else {
              uR(r2, await $g(e2.screen));
            }
          else if (Wh() && e2.screen.extensionId && e2.screen.mandatory) {
            if (!n2.getStreamFromExtension)
              throw new SE(fE.NOT_SUPPORTED, "This browser does not support screen sharing");
            OE.debug("[".concat(t2, '] Screen access on chrome stable, looking for extension"'));
            const i3 = await (s2 = e2.screen.extensionId, a2 = t2, new Sl((e3, t3) => {
              try {
                chrome.runtime.sendMessage(s2, { getStream: true }, (i4) => {
                  if (!i4 || !i4.streamId)
                    return OE.error("[".concat(a2, "] No response from Chrome Plugin. Plugin not installed properly"), i4), void t3(new SE(fE.CHROME_PLUGIN_NO_RESPONSE, "No response from Chrome Plugin. Plugin not installed properly"));
                  e3(i4.streamId);
                });
              } catch (e4) {
                OE.error("[".concat(a2, "] AgoraRTC screensharing plugin is not accessible(").concat(s2, ")"), e4.toString()), t3(new SE(fE.CHROME_PLUGIN_NOT_INSTALL));
              }
            }));
            e2.screen.mandatory.chromeMediaSourceId = i3;
            uR(r2, await navigator.mediaDevices.getUserMedia({ video: { mandatory: e2.screen.mandatory } }));
          } else if (n2.getDisplayMedia) {
            var o2;
            e2.screen.mediaSource && gS(e2.screen.mediaSource);
            const i3 = { width: e2.screen.width, height: e2.screen.height, frameRate: e2.screen.frameRate, displaySurface: null !== (o2 = e2.screen.displaySurface) && void 0 !== o2 ? o2 : "screen" === e2.screen.mediaSource ? "monitor" : e2.screen.mediaSource }, { selfBrowserSurface: n3, surfaceSwitching: s3, systemAudio: a3 } = e2.screen, c3 = { selfBrowserSurface: n3, surfaceSwitching: s3, systemAudio: a3 };
            !n3 && delete c3.selfBrowserSurface, !s3 && delete c3.surfaceSwitching, !a3 && delete c3.systemAudio, OE.debug("[".concat(t2, "] getDisplayMedia:"), JSON.stringify({ video: i3, audio: !!e2.screenAudio, controls: c3 }));
            uR(r2, await navigator.mediaDevices.getDisplayMedia(function(e3) {
              for (var t3 = 1; t3 < arguments.length; t3++) {
                var i4 = null != arguments[t3] ? arguments[t3] : {};
                t3 % 2 ? nR(Object(i4), true).forEach(function(t4) {
                  _p(e3, t4, i4[t4]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i4)) : nR(Object(i4)).forEach(function(t4) {
                  Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i4, t4));
                });
              }
              return e3;
            }({ video: i3, audio: !!e2.screenAudio }, c3)));
          } else {
            if (!Kh())
              throw OE.error("[".concat(t2, "] This browser does not support screenSharing")), new SE(fE.NOT_SUPPORTED, "This browser does not support screen sharing");
            {
              e2.screen.mediaSource && gS(e2.screen.mediaSource);
              const i3 = { video: { mediaSource: e2.screen.mediaSource, width: e2.screen.width, height: e2.screen.height, frameRate: e2.screen.frameRate } };
              OE.debug("[".concat(t2, "] getUserMedia: ").concat(JSON.stringify(i3)));
              uR(r2, await navigator.mediaDevices.getUserMedia(i3));
            }
          }
        var s2, a2;
        if (!e2.video && !e2.audio)
          return r2;
        let c2 = { video: e2.video, audio: e2.audio }, d2 = GE("MEDIA_DEVICE_CONSTRAINTS");
        if (d2)
          try {
            "string" == typeof d2 && (d2 = JSON.parse(d2)), c2 = function e3(t3, i3) {
              if (!SC(t3) || !SC(i3))
                return i3;
              if (Array.isArray(t3) && !Array.isArray(i3) || !Array.isArray(t3) && Array.isArray(i3))
                return i3;
              if (Array.isArray(i3) && Array.isArray(t3)) {
                const n3 = [...t3];
                for (let r3 = 0; r3 < i3.length; r3++)
                  n3[r3] = e3(t3[r3], i3[r3]);
                return n3;
              }
              {
                const n3 = JI({}, t3);
                for (const r3 in i3)
                  Object.prototype.hasOwnProperty.call(i3, r3) && (Object.prototype.hasOwnProperty.call(t3, r3) ? n3[r3] = e3(t3[r3], i3[r3]) : n3[r3] = i3[r3]);
                return n3;
              }
            }(c2, d2);
          } catch (e3) {
          }
        OE.debug("[".concat(t2, "] GetUserMedia"), JSON.stringify(c2)), xh();
        let u2, l2 = null;
        (Hh() || Yh() || Fh()) && (l2 = await rR.lock());
        try {
          u2 = await navigator.mediaDevices.getUserMedia(c2);
        } catch (e3) {
          throw l2 && l2(), e3;
        }
        return c2.audio && (oR = true), c2.video && (sR = true), uR(r2, u2), l2 && l2(), r2;
      }
      function dR(e2, t2) {
        switch (e2) {
          case "Starting video failed":
          case "OverconstrainedError":
          case "TrackStartError":
            return new SE(fE.MEDIA_OPTION_INVALID, "".concat(e2, ": ").concat(t2));
          case "NotFoundError":
          case "DevicesNotFoundError":
            return new SE(fE.DEVICE_NOT_FOUND, "".concat(e2, ": ").concat(t2));
          case "NotSupportedError":
            return new SE(fE.NOT_SUPPORTED, "".concat(e2, ": ").concat(t2));
          case "NotReadableError":
            return new SE(fE.NOT_READABLE, "".concat(e2, ": ").concat(t2));
          case "InvalidStateError":
          case "NotAllowedError":
          case "PERMISSION_DENIED":
          case "PermissionDeniedError":
            return new SE(fE.PERMISSION_DENIED, "".concat(e2, ": ").concat(t2));
          case "ConstraintNotSatisfiedError":
            return new SE(fE.CONSTRAINT_NOT_SATISFIED, "".concat(e2, ": ").concat(t2));
          default:
            return OE.error("getUserMedia unexpected error", e2), new SE(fE.UNEXPECTED_ERROR, "".concat(e2, ": ").concat(t2));
        }
      }
      function uR(e2, t2) {
        const i2 = e2.getVideoTracks()[0], n2 = e2.getAudioTracks()[0], r2 = t2.getVideoTracks()[0], o2 = t2.getAudioTracks()[0];
        o2 && (n2 && e2.removeTrack(n2), e2.addTrack(o2)), r2 && (i2 && e2.removeTrack(i2), e2.addTrack(r2));
      }
      const lR = new class extends EE {
        get state() {
          return this._state;
        }
        set state(e2) {
          e2 !== this._state && (this.emit(ff.STATE_CHANGE, e2), this._state = e2);
        }
        constructor() {
          super(), _p(this, "_state", mf.IDLE), _p(this, "isAccessMicrophonePermission", false), _p(this, "isAccessCameraPermission", false), _p(this, "lastAccessMicrophonePermission", false), _p(this, "lastAccessCameraPermission", false), _p(this, "checkdeviceMatched", false), _p(this, "deviceInfoMap", /* @__PURE__ */ new Map()), this.init().then(() => {
            navigator.mediaDevices.addEventListener && navigator.mediaDevices.addEventListener("devicechange", this.updateDevicesInfo.bind(this)), window.setInterval(() => {
              (GE("ENUMERATE_DEVICES_INTERVAL") || (op() || Vh() === bh.HARMONY_OS) && rp()) && this.updateDevicesInfo();
            }, GE("ENUMERATE_DEVICES_INTERVAL_TIME"));
          }).catch((e2) => OE.error(e2.toString()));
        }
        async enumerateDevices(e2, t2) {
          let i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
            return new SE(fE.NOT_SUPPORTED, "enumerateDevices() not supported.").throw();
          }
          const n2 = await navigator.mediaDevices.enumerateDevices(), r2 = this.checkMediaDeviceInfoIsOk(n2);
          let o2 = !this.isAccessMicrophonePermission && e2, s2 = !this.isAccessCameraPermission && t2;
          r2.audio && (o2 = false), r2.video && (s2 = false);
          let a2 = null, c2 = null, d2 = null;
          if (!i2 && (o2 || s2)) {
            if (rR.isLocked) {
              OE.debug("[device manager] wait GUM lock");
              (await rR.lock())(), OE.debug("[device manager] GUM unlock");
            }
            if (oR && (o2 = false, this.isAccessMicrophonePermission = true), sR && (s2 = false, this.isAccessCameraPermission = true), OE.debug("[device manager] check media device permissions", e2, t2, o2, s2), o2 && s2) {
              try {
                d2 = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
              } catch (e3) {
                const t3 = dR(e3.name || e3.code || e3, e3.message);
                if (t3.code === fE.PERMISSION_DENIED)
                  throw t3;
                OE.warning("getUserMedia failed in getDevices", t3);
              }
              this.isAccessCameraPermission = true, this.isAccessMicrophonePermission = true;
            } else if (o2) {
              try {
                a2 = await navigator.mediaDevices.getUserMedia({ audio: e2 });
              } catch (e3) {
                const t3 = dR(e3.name || e3.code || e3, e3.message);
                if (t3.code === fE.PERMISSION_DENIED)
                  throw t3;
                OE.warning("getUserMedia failed in getDevices", t3);
              }
              this.isAccessMicrophonePermission = true;
            } else if (s2) {
              try {
                c2 = await navigator.mediaDevices.getUserMedia({ video: t2 });
              } catch (e3) {
                const t3 = dR(e3.name || e3.code || e3, e3.message);
                if (t3.code === fE.PERMISSION_DENIED)
                  throw t3;
                OE.warning("getUserMedia failed in getDevices", t3);
              }
              this.isAccessCameraPermission = true;
            }
            OE.debug("[device manager] mic permission", e2, "cam permission", t2);
          }
          try {
            const e3 = await navigator.mediaDevices.enumerateDevices();
            return a2 && a2.getTracks().forEach((e4) => e4.stop()), c2 && c2.getTracks().forEach((e4) => e4.stop()), d2 && d2.getTracks().forEach((e4) => e4.stop()), a2 = null, c2 = null, d2 = null, e3;
          } catch (e3) {
            a2 && a2.getTracks().forEach((e4) => e4.stop()), c2 && c2.getTracks().forEach((e4) => e4.stop()), d2 && d2.getTracks().forEach((e4) => e4.stop()), a2 = null, c2 = null, d2 = null;
            return new SE(fE.ENUMERATE_DEVICES_FAILED, e3.toString()).throw();
          }
        }
        async getRecordingDevices() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return (await this.enumerateDevices(true, false, e2)).filter((e3) => "audioinput" === e3.kind);
        }
        async getCamerasDevices() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return (await this.enumerateDevices(false, true, e2)).filter((e3) => "videoinput" === e3.kind);
        }
        async getSpeakers() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return (await this.enumerateDevices(true, false, e2)).filter((e3) => "audiooutput" === e3.kind);
        }
        searchDeviceIdByName(e2) {
          let t2 = null;
          return this.deviceInfoMap.forEach((i2) => {
            i2.device.label === e2 && (t2 = i2.device.deviceId);
          }), t2;
        }
        async getDeviceById(e2) {
          const t2 = (await this.enumerateDevices(true, true, true)).find((t3) => t3.deviceId === e2);
          if (!t2)
            throw new SE(fE.DEVICE_NOT_FOUND, "deviceId: ".concat(e2));
          return t2;
        }
        async init() {
          this.state = mf.INITING;
          try {
            await this.updateDevicesInfo(), this.state = mf.INITEND;
          } catch (e2) {
            if (OE.warning("Device Detection functionality cannot start properly.", e2.toString()), this.state = mf.IDLE, !function() {
              if ("boolean" == typeof isSecureContext)
                return isSecureContext;
              return "https:" === location.protocol || "file:" === location.protocol || "localhost" === location.hostname || "127.0.0.1" === location.hostname || "::1" === location.hostname;
            }()) {
              new SE(fE.WEB_SECURITY_RESTRICT, "Your context is limited by web security, please try using https protocol or localhost.").throw();
            }
            throw e2;
          }
        }
        async updateDevicesInfo() {
          const e2 = await this.enumerateDevices(true, true, true), t2 = Date.now(), i2 = [];
          if (e2[0] && e2[0].label && false === this.checkdeviceMatched) {
            this.checkdeviceMatched = true;
            const t3 = e2.find((e3) => "audioinput" === e3.kind && "default" === e3.deviceId), i3 = e2.find((e3) => "audiooutput" === e3.kind && "default" === e3.deviceId);
            t3 && i3 ? i3.groupId === t3.groupId ? OE.debug("[device-check] default input ".concat(t3.label, " and output ").concat(i3.label, " is the same group")) : OE.warning("[device-check] default input ".concat(t3.label, " and output ").concat(i3.label, " is not the same group")) : OE.debug("[device-check] default input or output not found");
          }
          const n2 = this.checkMediaDeviceInfoIsOk(e2);
          if (e2.forEach((e3) => {
            if (!e3.deviceId)
              return;
            const n3 = this.deviceInfoMap.get("".concat(e3.kind, "_").concat(e3.deviceId));
            if ("ACTIVE" !== (n3 ? n3.state : "INACTIVE")) {
              const n4 = { initAt: t2, updateAt: t2, device: e3, state: "ACTIVE" };
              this.deviceInfoMap.set("".concat(e3.kind, "_").concat(e3.deviceId), n4), i2.push(n4);
            }
            n3 && (n3.updateAt = t2);
          }), this.deviceInfoMap.forEach((e3, n3) => {
            "ACTIVE" === e3.state && e3.updateAt !== t2 && (e3.state = "INACTIVE", i2.push(e3));
          }), this.state !== mf.INITEND)
            return n2.audio && (this.lastAccessMicrophonePermission = true, this.isAccessMicrophonePermission = true), void (n2.video && (this.lastAccessCameraPermission = true, this.isAccessCameraPermission = true));
          i2.forEach((e3) => {
            switch (e3.device.kind) {
              case "audioinput":
                this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(ff.RECORDING_DEVICE_CHANGED, e3);
                break;
              case "videoinput":
                this.lastAccessCameraPermission && this.isAccessCameraPermission && this.emit(ff.CAMERA_DEVICE_CHANGED, e3);
                break;
              case "audiooutput":
                this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(ff.PLAYOUT_DEVICE_CHANGED, e3);
            }
          }), n2.audio && (this.lastAccessMicrophonePermission = true, this.isAccessMicrophonePermission = true), n2.video && (this.lastAccessCameraPermission = true, this.isAccessCameraPermission = true);
        }
        checkMediaDeviceInfoIsOk(e2) {
          const t2 = e2.filter((e3) => "audioinput" === e3.kind), i2 = e2.filter((e3) => "videoinput" === e3.kind), n2 = { audio: false, video: false };
          for (const e3 of t2)
            if (e3.label && e3.deviceId) {
              n2.audio = true;
              break;
            }
          for (const e3 of i2)
            if (e3.label && e3.deviceId) {
              n2.video = true;
              break;
            }
          return n2;
        }
      }();
      const hR = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "error"], pR = new class {
        constructor() {
          _p(this, "onAutoplayFailed", void 0), _p(this, "elementMap", /* @__PURE__ */ new Map()), _p(this, "elementStateMap", /* @__PURE__ */ new Map()), _p(this, "elementsNeedToResume", []), _p(this, "sinkIdMap", /* @__PURE__ */ new Map()), _p(this, "autoResumeAfterInterruption", () => {
            Array.from(this.elementMap.entries()).forEach((e2) => {
              let [t2, i2] = e2;
              const n2 = this.elementStateMap.get(t2), r2 = i2.srcObject.getAudioTracks()[0];
              Zh() ? r2 && "live" === r2.readyState && "running" === Gg.curState && (OE.debug("auto resume after interruption for iOS 15"), i2.pause(), i2.play()) : n2 && "paused" === n2 && r2 && "live" === r2.readyState && "running" === Gg.curState && (OE.debug("auto resume after interruption for iOS"), i2.play());
            });
          }), _p(this, "autoResumeAfterInterruptionOnIOS15_16", () => {
            Array.from(this.elementMap.entries()).forEach((e2) => {
              let [t2, i2] = e2;
              const n2 = i2.srcObject.getAudioTracks()[0];
              n2 && "live" === n2.readyState && (OE.debug("auto resume after interruption inside autoResumeAfterInterruptionOnIOS15"), i2.pause(), i2.play());
            });
          }), this.autoResumeAudioElement(), Gg.on(kg.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), Gg.on(kg.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), Gg.on(kg.STATE_CHANGE, () => {
            Yh() && "suspended" === Gg.prevState && "running" === Gg.curState && this.autoResumeAfterInterruption();
          });
        }
        async setSinkID(e2, t2) {
          const i2 = this.elementMap.get(e2);
          if (this.sinkIdMap.set(e2, t2), i2)
            try {
              await i2.setSinkId(t2);
            } catch (e3) {
              throw new SE(fE.PERMISSION_DENIED, "can not set sink id: " + e3.toString());
            }
        }
        play(e2, t2, i2, n2) {
          if (this.elementMap.has(t2))
            return;
          const r2 = document.createElement("audio");
          r2.autoplay = true, r2.srcObject = new MediaStream([e2]), this.bindAudioElementEvents(t2, r2), this.elementMap.set(t2, r2), this.elementStateMap.set(t2, sf.INIT), this.setVolume(t2, i2);
          const o2 = this.sinkIdMap.get(t2);
          if (o2)
            try {
              r2.setSinkId(o2).catch((e3) => {
                OE.warning("[".concat(t2, "] set sink id failed"), e3.toString());
              });
            } catch (e3) {
              OE.warning("[".concat(t2, "] set sink id failed"), e3.toString());
            }
          const s2 = r2.play();
          s2 && s2.then && s2.catch((e3) => {
            n2 && Pg.autoplayFailed(n2, "audio", e3.message, t2), OE.warning("audio element play warning", e3.toString()), this.elementMap.has(t2) && "NotAllowedError" === e3.name && (OE.warning("detected audio element autoplay failed"), this.elementsNeedToResume.push(r2), dC(() => {
              this.onAutoplayFailed && this.onAutoplayFailed(), yg();
            }));
          });
        }
        updateTrack(e2, t2) {
          const i2 = this.elementMap.get(e2);
          i2 && (i2.srcObject = new MediaStream([t2]));
        }
        isPlaying(e2) {
          return this.elementMap.has(e2) && "playing" === this.elementStateMap.get(e2);
        }
        setVolume(e2, t2) {
          const i2 = this.elementMap.get(e2);
          i2 && (t2 = Math.max(0, Math.min(100, t2)), i2.volume = t2 / 100);
        }
        stop(e2) {
          const t2 = this.elementMap.get(e2);
          if (this.sinkIdMap.delete(e2), !t2)
            return;
          const i2 = this.elementsNeedToResume.indexOf(t2);
          this.elementsNeedToResume.splice(i2, 1), t2.srcObject = null, t2.remove(), this.elementMap.delete(e2), this.elementStateMap.delete(e2);
        }
        bindAudioElementEvents(e2, t2) {
          hR.forEach((i2) => {
            t2.addEventListener(i2, (i3) => {
              const n2 = this.elementStateMap.get(e2), r2 = "pause" === i3.type ? "paused" : i3.type;
              if (OE.debug("[".concat(e2, "] audio-element-status change ").concat(n2, " => ").concat(r2)), "error" === i3.type) {
                const i4 = null == t2 ? void 0 : t2.error;
                i4 && OE.error("[".concat(e2, "] media error, code: ").concat(i4.code, ", message: ").concat(i4.message));
              }
              this.elementStateMap.set(e2, r2);
            });
          });
        }
        getPlayerState(e2) {
          return this.elementStateMap.get(e2) || "uninit";
        }
        autoResumeAudioElement() {
          const e2 = () => {
            this.elementsNeedToResume.forEach((e3) => {
              e3.play().then((e4) => {
                OE.debug("Auto resume audio element success");
              }).catch((e4) => {
                OE.warning("Auto resume audio element failed!", e4);
              });
            }), this.elementsNeedToResume = [];
          };
          new Sl((e3) => {
            document.body ? e3() : window.addEventListener("load", () => e3());
          }).then(() => {
            sp() ? document.body.addEventListener("click", e2, true) : (document.body.addEventListener("touchstart", e2, true), document.body.addEventListener("mousedown", e2, true));
          });
        }
      }();
      function _R() {
        return function(e2, t2, i2) {
          const n2 = i2.value;
          return "function" == typeof n2 && (i2.value = function() {
            this._isClosed && new SE(fE.INVALID_OPERATION, "[".concat(this.getTrackId(), "] cannot operate a closed track")).print("warning");
            for (var e3 = arguments.length, t3 = new Array(e3), i3 = 0; i3 < e3; i3++)
              t3[i3] = arguments[i3];
            const r2 = n2.apply(this, t3);
            return r2 instanceof Sl ? new Sl((e4, t4) => {
              r2.then(e4).catch(t4);
            }) : r2;
          }), i2;
        };
      }
      var ER = Hi("Array").values, mR = Zr, fR = Ge, SR = u, TR = ER, gR = Array.prototype, RR = { DOMTokenList: true, NodeList: true }, IR = function(e2) {
        var t2 = e2.values;
        return e2 === gR || SR(gR, e2) && t2 === gR.values || fR(RR, mR(e2)) ? TR : t2;
      };
      function CR(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function vR(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? CR(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : CR(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class yR extends EE {
        constructor(e2) {
          super(), _p(this, "name", "VideoProcessorDestination"), _p(this, "ID", "0"), _p(this, "_source", void 0), _p(this, "videoContext", void 0), _p(this, "inputTrack", void 0), this.videoContext = e2;
        }
        get kind() {
          return "video";
        }
        get enabled() {
          return true;
        }
        pipe() {
          throw new SE(fE.NOT_SUPPORTED, "VideoProcessor cannot pipe to any other Processor");
        }
        unpipe() {
          throw new SE(fE.NOT_SUPPORTED, "VideoProcessor cannot unpipe to any other Processor");
        }
        enable() {
        }
        disable() {
        }
        updateInput(e2) {
          if (e2.context !== this.videoContext)
            throw new Error("ProcessorContext passed to VideoTrack.processorDestination doesn't match it's belonging VideoTrack's context.\nProbably you are making pipeline like this:\nvideoTrack1.pipe(processor).pipe(videoTrack2.processorDestination).");
          e2.track && e2.track !== this.inputTrack && (this.videoContext.chained = true, this.inputTrack = e2.track, this.emit(kS.ON_TRACK, e2.track));
        }
        reset() {
          this.inputTrack = void 0, this.videoContext.chained = false, this.emit(kS.ON_TRACK, void 0);
        }
      }
      class AR extends EE {
        set chained(e2) {
          this._chained = e2;
        }
        get chained() {
          return this._chained;
        }
        constructor(e2, t2) {
          super(), _p(this, "constraintsMap", /* @__PURE__ */ new Map()), _p(this, "statsRegistry", []), _p(this, "usageRegistry", []), _p(this, "trackId", void 0), _p(this, "direction", void 0), _p(this, "_chained", false), this.trackId = e2, this.direction = t2;
        }
        async getConstraints() {
          return await nC(this, MS.REQUEST_CONSTRAINTS);
        }
        async requestApplyConstraints(e2, t2) {
          var i2;
          return OE.info("processor ".concat(t2.name, " requestApplyConstraints for ").concat(this.trackId)), e2 && this.constraintsMap.set(t2, e2), rC(this, MS.REQUEST_UPDATE_CONSTRAINTS, Array.from(IR(i2 = this.constraintsMap).call(i2)));
        }
        async requestRevertConstraints(e2) {
          var t2;
          if (this.constraintsMap.has(e2))
            return OE.info("processor ".concat(e2.name, " requestRevertConstraints for ").concat(this.trackId)), this.constraintsMap.delete(e2), rC(this, MS.REQUEST_UPDATE_CONSTRAINTS, Array.from(IR(t2 = this.constraintsMap).call(t2)));
        }
        registerStats(e2, t2, i2) {
          this.statsRegistry.find((i3) => i3.processorID === e2.ID && i3.processorName === e2.name && i3.type === t2) || this.statsRegistry.push({ processorName: e2.name, processorID: e2.ID, type: t2, cb: i2 });
        }
        unregisterStats(e2, t2) {
          const i2 = this.statsRegistry.findIndex((i3) => i3.processorID === e2.ID && i3.processorName === e2.name && i3.type === t2);
          -1 !== i2 && this.statsRegistry.splice(i2, 1);
        }
        gatherStats() {
          const e2 = [];
          for (const { processorID: t2, processorName: i2, type: n2, cb: r2 } of this.statsRegistry)
            try {
              const o2 = r2();
              e2.push({ processorID: t2, processorName: i2, type: n2, stats: o2 });
            } catch (e3) {
              OE.error(new SE(fE.UNEXPECTED_ERROR, e3.message));
            }
          return e2;
        }
        registerUsage(e2, t2) {
          this.usageRegistry.find((t3) => t3.processorID === e2.ID && t3.processorName === e2.name) || this.usageRegistry.push({ processorID: e2.ID, processorName: e2.name, cb: t2 });
        }
        unregisterUsage(e2) {
          const t2 = this.usageRegistry.findIndex((t3) => t3.processorID === e2.ID && t3.processorName === e2.name);
          -1 !== t2 && this.usageRegistry.splice(t2, 1);
        }
        async gatherUsage() {
          const e2 = [];
          if (!this.chained)
            return [];
          for (const { cb: t2 } of this.usageRegistry)
            try {
              let i2 = t2();
              i2 instanceof Sl && (i2 = await i2), e2.push(vR(vR({}, i2), {}, { direction: this.direction }));
            } catch (e3) {
              OE.error("gather extension usage error", e3);
            }
          return e2;
        }
        getDirection() {
          return this.direction;
        }
      }
      class OR extends EE {
        constructor(e2) {
          super(), _p(this, "name", "AudioProcessorDestination"), _p(this, "ID", "0"), _p(this, "inputTrack", void 0), _p(this, "inputNode", void 0), _p(this, "audioProcessorContext", void 0), _p(this, "_source", void 0), this.audioProcessorContext = e2;
        }
        get kind() {
          return "audio";
        }
        get enabled() {
          return true;
        }
        pipe() {
          throw new SE(fE.NOT_SUPPORTED, "AudioProcessorDestination cannot pipe to any other Processor");
        }
        unpipe() {
          throw new SE(fE.NOT_SUPPORTED, "AudioProcessor cannot unpipe to any other Processor");
        }
        enable() {
        }
        disable() {
        }
        reset() {
          this.inputTrack = void 0, this.inputNode = void 0, this.audioProcessorContext.chained = false, this.emit(kS.ON_TRACK, void 0), this.emit(kS.ON_NODE, void 0);
        }
        updateInput(e2) {
          if (e2.context !== this.audioProcessorContext)
            throw new Error("ProcessorContext passed to AudioTrack.processorDestination doesn't match it's belonging AudioTrack's context.\n        Probably you are making pipeline like this: audioTrack1.pipe(processor).pipe(audioTrack2.processorDestination).");
          e2.track && this.inputTrack !== e2.track && (this.audioProcessorContext.chained = true, this.inputTrack = e2.track, this.emit(kS.ON_TRACK, this.inputTrack)), e2.node && this.inputNode !== e2.node && (this.audioProcessorContext.chained = true, this.inputNode = e2.node, this.emit(kS.ON_NODE, this.inputNode));
        }
      }
      class NR extends EE {
        set chained(e2) {
          this._chained = e2;
        }
        get chained() {
          return this._chained;
        }
        constructor(e2, t2, i2) {
          super(), _p(this, "constraintsMap", /* @__PURE__ */ new Map()), _p(this, "statsRegistry", []), _p(this, "audioContext", void 0), _p(this, "trackId", void 0), _p(this, "direction", void 0), _p(this, "usageRegistry", []), _p(this, "_chained", false), this.audioContext = e2, this.trackId = t2, this.direction = i2;
        }
        async getConstraints() {
          return nC(this, MS.REQUEST_CONSTRAINTS);
        }
        getAudioContext() {
          return this.audioContext;
        }
        async requestApplyConstraints(e2, t2) {
          var i2;
          return OE.info("processor ".concat(t2.name, " requestApplyConstraints for ").concat(this.trackId)), e2 && this.constraintsMap.set(t2, e2), rC(this, MS.REQUEST_UPDATE_CONSTRAINTS, Array.from(IR(i2 = this.constraintsMap).call(i2)));
        }
        async requestRevertConstraints(e2) {
          var t2;
          if (this.constraintsMap.has(e2))
            return this.constraintsMap.delete(e2), rC(this, MS.REQUEST_UPDATE_CONSTRAINTS, Array.from(IR(t2 = this.constraintsMap).call(t2)));
        }
        registerStats(e2, t2, i2) {
          this.statsRegistry.find((i3) => i3.processorID === e2.ID && i3.processorName === e2.name && i3.type === t2) || this.statsRegistry.push({ processorName: e2.name, processorID: e2.ID, type: t2, cb: i2 });
        }
        unregisterStats(e2, t2) {
          const i2 = this.statsRegistry.findIndex((i3) => i3.processorID === e2.ID && i3.processorName === e2.name && i3.type === t2);
          -1 !== i2 && this.statsRegistry.splice(i2, 1);
        }
        gatherStats() {
          const e2 = [];
          for (const { processorID: t2, processorName: i2, type: n2, cb: r2 } of this.statsRegistry)
            try {
              const o2 = r2();
              e2.push({ processorID: t2, processorName: i2, type: n2, stats: o2 });
            } catch (e3) {
              OE.error(new SE(fE.UNEXPECTED_ERROR, e3.message));
            }
          return e2;
        }
        registerUsage(e2, t2) {
          this.usageRegistry.find((t3) => t3.processorID === e2.ID && t3.processorName === e2.name) || this.usageRegistry.push({ processorID: e2.ID, processorName: e2.name, cb: t2 });
        }
        unregisterUsage(e2) {
          const t2 = this.usageRegistry.findIndex((t3) => t3.processorID === e2.ID && t3.processorName === e2.name);
          -1 !== t2 && this.usageRegistry.splice(t2, 1);
        }
        async gatherUsage() {
          const e2 = [];
          if (!this.chained)
            return [];
          for (const { cb: t2 } of this.usageRegistry)
            try {
              let i2 = t2();
              i2 instanceof Sl && (i2 = await i2), e2.push(vR(vR({}, i2), {}, { direction: this.direction }));
            } catch (e3) {
              OE.error("gather extension usage error", e3);
            }
          return e2;
        }
        getDirection() {
          return this.direction;
        }
      }
      class bR extends EE {
        get isPlayed() {
          return true;
        }
        get isFreeze() {
          return false;
        }
        constructor() {
          super(), _p(this, "context", void 0), _p(this, "processSourceNode", void 0), _p(this, "outputTrack", void 0), _p(this, "processedNode", void 0), _p(this, "clonedTrack", void 0), _p(this, "outputNode", void 0), this.outputNode = new wR();
        }
        setVolume() {
        }
        createOutputTrack() {
          throw new SE(fE.NOT_SUPPORTED, "can not create output MediaStreamTrack when WebAudio disabled");
        }
        getOriginVolumeLevel() {
          return 0;
        }
        getAccurateVolumeLevel() {
          return 0;
        }
        stopGetAudioBuffer() {
        }
        startGetAudioBuffer() {
        }
        play() {
        }
        stop() {
        }
        destroy() {
        }
        updateTrack() {
        }
        updateOriginTrack() {
        }
        createMediaStreamSourceNode() {
        }
      }
      class wR {
        disconnect() {
        }
        connect() {
        }
      }
      let DR, PR = null;
      class LR {
        constructor() {
          _p(this, "state", "open"), _p(this, "trigger", void 0), _p(this, "tasks", []), OE.debug("[macro-task-queue] is created."), this.trigger = setTimeout(() => {
            this.state = "closed", OE.debug("[macro-task-queue] will be closed, all remaining tasks will execute. [".concat(this.tasks.map((e2) => e2.key), "]")), this.trigger = void 0, this.tasks.forEach((e2) => {
              let { func: t2 } = e2;
              return t2();
            }), this.tasks.length = 0, OE.debug("[macro-task-queue] is closed.");
          });
        }
        enqueue(e2, t2) {
          "closed" !== this.state && (this.tasks.push({ key: e2, func: t2 }), OE.debug("[macro-task-queue] is queued, current queue ".concat(this.tasks.length, ". ").concat("string" == typeof e2 ? e2 : "")));
        }
        runTask(e2) {
          if ("closed" === this.state)
            return;
          const t2 = this.tasks.findIndex((t3) => t3.key === e2);
          if (-1 !== t2) {
            const i2 = this.tasks.splice(t2, 1);
            OE.debug("[macro-task-queue] is unqueued, current queue ".concat(this.tasks.length, ". ").concat("string" == typeof e2 ? e2 : "")), i2[0].func();
          }
        }
        release() {
          this.trigger && (this.state = "closed", clearTimeout(this.trigger), this.trigger = void 0, this.tasks.length = 0, OE.debug("[macro-task-queue] is closed."));
        }
      }
      function kR(e2) {
        return function(t2, i2, n2) {
          var r2;
          const o2 = null !== (r2 = n2.value) && void 0 !== r2 ? r2 : n2.get, s2 = function() {
            PR && "open" === PR.state && PR.runTask(e2);
            for (var t3 = arguments.length, i3 = new Array(t3), n3 = 0; n3 < t3; n3++)
              i3[n3] = arguments[n3];
            return null == o2 ? void 0 : o2.apply(this, ...i3);
          };
          return n2.value ? n2.value = s2 : n2.get = s2, n2;
        };
      }
      var MR, UR, xR, VR, jR, FR, BR, GR, WR, HR, KR, YR, qR, JR, XR, zR, QR, ZR, $R, eI, tI, iI, nI, rI, oI, sI, aI, cI, dI, uI, lI, hI, pI, _I, EI, mI, fI, SI, TI, gI, RI, II;
      function CI(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function vI(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? CI(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : CI(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      !function(e2) {
        e2.UPDATE_TRACK_SOURCE = "update-track-source";
      }(DR || (DR = {}));
      let yI = (MR = kR("INIT_WEBAUDIO"), UR = kR("INIT_WEBAUDIO"), xR = kR("INIT_WEBAUDIO"), VR = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2], throttleTime: 300 }), jR = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), FR = _R(), BR = xg("LocalAudioTrack", "_enabledMutex"), GR = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), WR = _R(), HR = xg("LocalAudioTrack", "_enabledMutex"), KR = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), YR = _R(), qR = _R(), JR = _R(), XR = Dg({ argsMap: (e2) => [e2.getTrackId()] }), zR = _R(), QR = Dg({ argsMap: (e2) => [e2.getTrackId()] }), ZR = _R(), $R = Dg({ argsMap: (e2) => [e2.getTrackId()] }), eI = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), tI = Dg({ argsMap: (e2) => [e2.getTrackId()] }), ag((iI = class extends Vg {
        get _source() {
          return this._trackSource;
        }
        set _source(e2) {
          this._trackSource = e2;
        }
        get processorContext() {
          return this._processorContext;
        }
        set processorContext(e2) {
          this._processorContext = e2;
        }
        get processorDestination() {
          return this._processorDestination;
        }
        set processorDestination(e2) {
          this._processorDestination = e2;
        }
        get isPlaying() {
          return this._useAudioElement ? pR.isPlaying(this.getTrackId()) : this._source.isPlayed;
        }
        get __className__() {
          return "LocalAudioTrack";
        }
        constructor(e2, t2, i2, n2, r2) {
          super(e2, i2), _p(this, "trackMediaType", "audio"), _p(this, "_encoderConfig", void 0), _p(this, "_trackSource", void 0), _p(this, "_enabled", true), _p(this, "_volume", 100), _p(this, "_useAudioElement", false), _p(this, "_bypassWebAudio", false), _p(this, "processor", void 0), _p(this, "_processorContext", void 0), _p(this, "_processorDestination", void 0), _p(this, "_getOriginVolumeLevel", void 0), this._encoderConfig = t2, this._getOriginVolumeLevel = !!n2;
          const o2 = () => {
            this.processorContext = new NR(this._source.context, this.getTrackId(), "local"), this.processorDestination = new OR(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(Lf.UPDATE_SOURCE, () => {
              this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: this.processorContext });
            });
          }, s2 = r2 && Hh() && !Kg();
          if (GE("DISABLE_WEBAUDIO") ? (this._source = new bR(), this._useAudioElement = true, this._bypassWebAudio = true) : s2 ? this._source = new bR() : (this._source = new Qg(e2, false, this._getOriginVolumeLevel ? e2 : void 0), GE("LOCAL_AUDIO_TRACK_USES_WEB_AUDIO") || (this._useAudioElement = true)), o2(), !GE("DISABLE_WEBAUDIO") && s2) {
            (PR || (PR = new LR()), PR).enqueue("INIT_WEBAUDIO", () => {
              this._source = new Qg(e2, false, this._getOriginVolumeLevel ? e2 : void 0), GE("LOCAL_AUDIO_TRACK_USES_WEB_AUDIO") || (this._useAudioElement = true), o2(), this.emit(DR.UPDATE_TRACK_SOURCE);
            });
          }
        }
        setVolume(e2) {
          qm(e2, "volume", 0, 1e3), this._volume = e2, this._source.setVolume(e2 / 100), this._useAudioElement && pR.setVolume(this.getTrackId(), e2);
          try {
            if (this._bypassWebAudio)
              return void OE.debug("[".concat(this.getTrackId(), "] setVolume returned because no pass through WebAudio."));
            const e3 = this._source.createOutputTrack();
            this._mediaStreamTrack !== e3 && (this._mediaStreamTrack = e3, rC(this, uS.NEED_REPLACE_TRACK, this).then(() => {
              OE.debug("[".concat(this.getTrackId(), "] replace web audio track success"));
            }).catch((e4) => {
              OE.warning("[".concat(this.getTrackId(), "] replace web audio track failed"), e4);
            }));
          } catch (e3) {
          }
        }
        getVolumeLevel() {
          return this._muted && this.enabled && this._getOriginVolumeLevel ? this._source.getOriginVolumeLevel() : this._source.getAccurateVolumeLevel();
        }
        async setPlaybackDevice(e2) {
          if (!this._useAudioElement)
            throw new SE(fE.NOT_SUPPORTED, "your browser does not support setting the audio output device");
          await pR.setSinkID(this.getTrackId(), e2);
        }
        async setEnabled(e2, t2, i2) {
          return this._setEnabled(e2, t2, i2);
        }
        async _setEnabled(e2, t2, i2) {
          if (!i2) {
            if (e2 === this._enabled)
              return;
            this.stateCheck("enabled", e2);
          }
          if (OE.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), e2) {
            this._originMediaStreamTrack.enabled = true;
            try {
              i2 || (this._enabled = true), await rC(this, uS.NEED_ENABLE_TRACK, this), OE.info("[".concat(this.getTrackId(), "] setEnabled to ").concat(e2, " success"));
            } catch (e3) {
              throw i2 || (this._enabled = false), OE.error("[".concat(this.getTrackId(), "] setEnabled to true error"), e3.toString()), e3;
            }
          } else {
            this._originMediaStreamTrack.enabled = false, i2 || (this._enabled = false);
            try {
              await rC(this, uS.NEED_DISABLE_TRACK, this);
            } catch (e3) {
              throw i2 || (this._enabled = true), OE.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e3.toString()), e3;
            }
          }
        }
        async setMuted(e2) {
          e2 !== this._muted && (this.stateCheck("muted", e2), this._muted = e2, this._originMediaStreamTrack.enabled = !e2, OE.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e2)), e2 ? await rC(this, uS.NEED_MUTE_TRACK, this) : await rC(this, uS.NEED_UNMUTE_TRACK, this));
        }
        getStats() {
          hC(() => {
            OE.warning("[deprecated] LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead");
          }, "localAudioTrackGetStatsWarning");
          const e2 = oC(this, uS.GET_STATS);
          return e2 || vI({}, jf);
        }
        setAudioFrameCallback(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;
          if (!e2)
            return this._source.removeAllListeners(Lf.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
          this._source.startGetAudioBuffer(t2), this._source.removeAllListeners(Lf.ON_AUDIO_BUFFER), this._source.on(Lf.ON_AUDIO_BUFFER, (t3) => e2(t3));
        }
        play() {
          OE.debug("[".concat(this.getTrackId(), "] start audio playback")), this._useAudioElement ? (OE.debug("[".concat(this.getTrackId(), "] start audio playback in element")), pR.play(this._mediaStreamTrack, this.getTrackId(), this._volume)) : this._source.play();
        }
        stop() {
          OE.debug("[".concat(this.getTrackId(), "] stop audio playback")), this._useAudioElement ? pR.stop(this.getTrackId()) : this._source.stop();
        }
        close() {
          super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe(), this._source.destroy();
        }
        _updatePlayerSource() {
          let e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
          OE.debug("[".concat(this.getTrackId(), "] update player source track")), e2 && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && pR.updateTrack(this.getTrackId(), this._mediaStreamTrack);
        }
        async _updateOriginMediaStreamTrack(e2, t2) {
          this._originMediaStreamTrack !== e2 && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), e2.addEventListener("ended", this._handleTrackEnded), t2 && this._originMediaStreamTrack.stop(), this._originMediaStreamTrack = e2, this._muted && (this._originMediaStreamTrack.enabled = false), this.processor && this.processor.updateInput({ track: e2, context: this.processorContext }), this._mediaStreamTrack !== this._source.outputTrack ? (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await rC(this, uS.NEED_REPLACE_TRACK, this)) : this._source.updateTrack(this._originMediaStreamTrack), this._getOriginVolumeLevel && this._source.updateOriginTrack(e2));
        }
        renewMediaStreamTrack(e2) {
          return Sl.resolve(void 0);
        }
        pipe(e2) {
          if (this._bypassWebAudio)
            throw new SE(fE.INVALID_OPERATION, "Can not process AudioTrack when bypassWebAudio set to true.");
          if (this.processor === e2)
            return e2;
          if (e2._source)
            throw new SE(fE.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), e2;
        }
        unpipe() {
          var e2;
          if (!this.processor)
            return;
          const t2 = this.processor;
          null === (e2 = this._source.processSourceNode) || void 0 === e2 || e2.disconnect(), this.processor._source = false, this.processor = void 0, t2.reset();
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(kS.ON_TRACK, async (e2) => {
            e2 ? e2 !== this._mediaStreamTrack && (this._mediaStreamTrack = e2, this._updatePlayerSource(false), this._source.processedNode = this._source.createMediaStreamSourceNode(e2), await rC(this, uS.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await rC(this, uS.NEED_REPLACE_TRACK, this));
          }), this.processorDestination.on(kS.ON_NODE, (e2) => {
            this._source.processedNode = e2;
          });
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(kS.ON_TRACK), this.processorDestination.removeAllListeners(kS.ON_NODE);
        }
        unbindProcessorContextEvents() {
          this.processorContext.removeAllListeners(MS.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(MS.REQUEST_CONSTRAINTS);
        }
      }).prototype, "_source", [MR], Object.getOwnPropertyDescriptor(iI.prototype, "_source"), iI.prototype), ag(iI.prototype, "processorContext", [UR], Object.getOwnPropertyDescriptor(iI.prototype, "processorContext"), iI.prototype), ag(iI.prototype, "processorDestination", [xR], Object.getOwnPropertyDescriptor(iI.prototype, "processorDestination"), iI.prototype), ag(iI.prototype, "setVolume", [VR], Object.getOwnPropertyDescriptor(iI.prototype, "setVolume"), iI.prototype), ag(iI.prototype, "setPlaybackDevice", [jR, FR], Object.getOwnPropertyDescriptor(iI.prototype, "setPlaybackDevice"), iI.prototype), ag(iI.prototype, "setEnabled", [BR, GR, WR], Object.getOwnPropertyDescriptor(iI.prototype, "setEnabled"), iI.prototype), ag(iI.prototype, "setMuted", [HR, KR, YR], Object.getOwnPropertyDescriptor(iI.prototype, "setMuted"), iI.prototype), ag(iI.prototype, "getStats", [qR], Object.getOwnPropertyDescriptor(iI.prototype, "getStats"), iI.prototype), ag(iI.prototype, "setAudioFrameCallback", [JR], Object.getOwnPropertyDescriptor(iI.prototype, "setAudioFrameCallback"), iI.prototype), ag(iI.prototype, "play", [XR, zR], Object.getOwnPropertyDescriptor(iI.prototype, "play"), iI.prototype), ag(iI.prototype, "stop", [QR, ZR], Object.getOwnPropertyDescriptor(iI.prototype, "stop"), iI.prototype), ag(iI.prototype, "close", [$R], Object.getOwnPropertyDescriptor(iI.prototype, "close"), iI.prototype), ag(iI.prototype, "pipe", [eI], Object.getOwnPropertyDescriptor(iI.prototype, "pipe"), iI.prototype), ag(iI.prototype, "unpipe", [tI], Object.getOwnPropertyDescriptor(iI.prototype, "unpipe"), iI.prototype), iI), AI = (nI = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), rI = _R(), oI = xg("MicrophoneAudioTrack", "_enabledMutex"), sI = Dg({ argsMap: (e2, t2, i2) => [e2.getTrackId(), t2, i2] }), aI = _R(), cI = Dg({ argsMap: (e2) => [e2.getTrackId()] }), ag((dI = class extends yI {
        get __className__() {
          return "MicrophoneAudioTrack";
        }
        constructor(e2, t2, i2, n2) {
          super(e2, t2.encoderConfig ? FE(t2.encoderConfig) : {}, n2, GE("GET_VOLUME_OF_MUTED_AUDIO_TRACK"), true), _p(this, "_config", void 0), _p(this, "_deviceName", "default"), _p(this, "_constraints", void 0), _p(this, "_originalConstraints", void 0), _p(this, "_enabled", true), this._config = t2, this._constraints = i2, this._originalConstraints = i2, this._deviceName = e2.label, "boolean" == typeof t2.bypassWebAudio && (this._bypassWebAudio = t2.bypassWebAudio), (Zh() || $h()) && Gg.bindInterruptDetectorTrack(this), this.on(DR.UPDATE_TRACK_SOURCE, () => {
            this.bindProcessorContextEvents();
          }), Kg() && this.bindProcessorContextEvents();
        }
        async setDevice(e2) {
          if (OE.info("[".concat(this.getTrackId(), "] start set device to ").concat(e2)), this._enabled)
            try {
              const t2 = await lR.getDeviceById(e2), i2 = {};
              i2.audio = vI({}, this._constraints), i2.audio.deviceId = { exact: e2 }, this._originMediaStreamTrack.stop();
              let n2 = null;
              try {
                n2 = await aR(i2, this.getTrackId());
              } catch (e3) {
                throw OE.error("[".concat(this.getTrackId(), "] setDevice failed"), e3.toString()), n2 = await aR({ audio: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(n2.getAudioTracks()[0], false), e3;
              }
              await this._updateOriginMediaStreamTrack(n2.getAudioTracks()[0], false), this._deviceName = t2.label, this._config.microphoneId = e2, this._constraints.deviceId = { exact: e2 };
            } catch (e3) {
              throw OE.error("[".concat(this.getTrackId(), "] setDevice error"), e3.toString()), e3;
            }
          else
            try {
              const t2 = await lR.getDeviceById(e2);
              this._deviceName = t2.label, this._config.microphoneId = e2, this._constraints.deviceId = { exact: e2 };
            } catch (e3) {
              throw OE.error("[".concat(this.getTrackId(), "] setDevice error"), e3.toString()), e3;
            }
          OE.info("[".concat(this.getTrackId(), "] set device to ").concat(e2, " success"));
        }
        async setEnabled(e2, t2, i2) {
          if (t2)
            return OE.debug("[".concat(this.getTrackId(), "] setEnabled false (do not close microphone)")), await super._setEnabled(e2);
          if (!i2) {
            if (e2 === this._enabled)
              return;
            this.stateCheck("enabled", e2);
          }
          if (OE.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), !e2) {
            var n2;
            this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop(), null === (n2 = this._source.clonedTrack) || void 0 === n2 || n2.stop(), i2 || (this._enabled = false);
            try {
              await rC(this, uS.NEED_DISABLE_TRACK, this);
            } catch (e3) {
              throw OE.error("[".concat(this.getTrackId(), "] setEnabled false failed"), e3.toString()), e3;
            }
            return;
          }
          const r2 = vI({}, this._constraints), o2 = lR.searchDeviceIdByName(this._deviceName);
          o2 && !r2.deviceId && (r2.deviceId = o2);
          try {
            i2 || (this._enabled = true);
            const e3 = await aR({ audio: this._constraints }, this.getTrackId());
            await this._updateOriginMediaStreamTrack(e3.getAudioTracks()[0], false), await rC(this, uS.NEED_ENABLE_TRACK, this);
          } catch (e3) {
            throw i2 || (this._enabled = false), OE.error("[".concat(this.getTrackId(), "] setEnabled true failed"), e3.toString()), e3;
          }
          OE.info("[".concat(this.getTrackId(), "] setEnabled success"));
        }
        close() {
          super.close(), (Zh() || $h()) && Gg.unbindInterruptDetectorTrack(this);
        }
        onTrackEnded() {
          if ((Yh() || tp()) && this._enabled && !this._isClosed && Gg.duringInterruption) {
            const e2 = async () => {
              Gg.off(kg.IOS_INTERRUPTION_END, e2), this._enabled && !this._isClosed && (OE.debug("[".concat(this.getTrackId(), "] try capture microphone media device for interrupted iOS device.")), await this.setEnabled(false), await this.setEnabled(true));
            };
            Gg.on(kg.IOS_INTERRUPTION_END, e2);
          } else
            OE.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(mS.TRACK_ENDED);
        }
        async renewMediaStreamTrack(e2) {
          const t2 = e2 || this._constraints, i2 = lR.searchDeviceIdByName(this._deviceName);
          if (i2 && !t2.deviceId && (t2.deviceId = i2), this._constraints = t2, this._enabled) {
            this._originMediaStreamTrack.stop();
            const e3 = await aR({ audio: this._constraints }, this.getTrackId());
            await this._updateOriginMediaStreamTrack(e3.getAudioTracks()[0], true);
          }
        }
        bindProcessorContextEvents() {
          this.processorContext.on(MS.REQUEST_UPDATE_CONSTRAINTS, async (e2, t2, i2) => {
            try {
              const i3 = Object.assign({}, this._originalConstraints, ...e2);
              await this.renewMediaStreamTrack(i3), t2();
            } catch (e3) {
              i2(e3);
            }
          }), this.processorContext.on(MS.REQUEST_CONSTRAINTS, async (e2) => {
            e2(this._originMediaStreamTrack.getSettings());
          });
        }
      }).prototype, "setDevice", [nI, rI], Object.getOwnPropertyDescriptor(dI.prototype, "setDevice"), dI.prototype), ag(dI.prototype, "setEnabled", [oI, sI, aI], Object.getOwnPropertyDescriptor(dI.prototype, "setEnabled"), dI.prototype), ag(dI.prototype, "close", [cI], Object.getOwnPropertyDescriptor(dI.prototype, "close"), dI.prototype), dI), OI = (uI = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2, e2.duration] }), lI = _R(), hI = Dg({ argsMap: (e2) => [e2.getTrackId()] }), pI = _R(), _I = Dg({ argsMap: (e2) => [e2.getTrackId()] }), EI = _R(), mI = Dg({ argsMap: (e2) => [e2.getTrackId()] }), fI = _R(), SI = Dg({ argsMap: (e2) => [e2.getTrackId()] }), TI = _R(), gI = Dg({ argsMap: (e2) => [e2.getTrackId()] }), RI = _R(), ag((II = class extends yI {
        get __className__() {
          return "BufferSourceAudioTrack";
        }
        constructor(e2, t2, i2, n2) {
          super(t2.createOutputTrack(), i2, n2), _p(this, "source", void 0), _p(this, "_bufferSource", void 0), this.source = e2, this._bufferSource = t2, this._bufferSource.on(Lf.AUDIO_SOURCE_STATE_CHANGE, (e3) => {
            this.safeEmit(mS.SOURCE_STATE_CHANGE, e3);
          });
          try {
            this._mediaStreamTrack = this._source.createOutputTrack();
          } catch (e3) {
          }
        }
        get currentState() {
          return this._bufferSource.currentState;
        }
        get duration() {
          return this._bufferSource.duration;
        }
        get playbackSpeed() {
          return this._bufferSource.playbackSpeed;
        }
        getCurrentTime() {
          return this._bufferSource.currentTime;
        }
        startProcessAudioBuffer(e2) {
          e2 && this._bufferSource.updateOptions(e2), this._bufferSource.startProcessAudioBuffer();
        }
        pauseProcessAudioBuffer() {
          this._bufferSource.pauseProcessAudioBuffer();
        }
        seekAudioBuffer(e2) {
          this._bufferSource.seekAudioBuffer(e2);
        }
        resumeProcessAudioBuffer() {
          this._bufferSource.resumeProcessAudioBuffer();
        }
        stopProcessAudioBuffer() {
          this._bufferSource.stopProcessAudioBuffer();
        }
        setAudioBufferPlaybackSpeed(e2) {
          qm(e2, "speed", 0), this._bufferSource.setAudioBufferPlaybackSpeed(e2);
        }
      }).prototype, "startProcessAudioBuffer", [uI, lI], Object.getOwnPropertyDescriptor(II.prototype, "startProcessAudioBuffer"), II.prototype), ag(II.prototype, "pauseProcessAudioBuffer", [hI, pI], Object.getOwnPropertyDescriptor(II.prototype, "pauseProcessAudioBuffer"), II.prototype), ag(II.prototype, "seekAudioBuffer", [_I, EI], Object.getOwnPropertyDescriptor(II.prototype, "seekAudioBuffer"), II.prototype), ag(II.prototype, "resumeProcessAudioBuffer", [mI, fI], Object.getOwnPropertyDescriptor(II.prototype, "resumeProcessAudioBuffer"), II.prototype), ag(II.prototype, "stopProcessAudioBuffer", [SI, TI], Object.getOwnPropertyDescriptor(II.prototype, "stopProcessAudioBuffer"), II.prototype), ag(II.prototype, "setAudioBufferPlaybackSpeed", [gI, RI], Object.getOwnPropertyDescriptor(II.prototype, "setAudioBufferPlaybackSpeed"), II.prototype), II);
      class NI extends yI {
        get __className__() {
          return "MixingAudioTrack";
        }
        get isActive() {
          for (const e2 of this.trackList)
            if (e2._enabled && !e2._isClosed && !e2.muted)
              return true;
          return false;
        }
        constructor() {
          const e2 = Hg().createMediaStreamDestination();
          super(e2.stream.getAudioTracks()[0], void 0, ZI(8, "track-mix-")), _p(this, "trackList", void 0), _p(this, "destNode", void 0);
          try {
            this._mediaStreamTrack = this._source.createOutputTrack();
          } catch (e3) {
          }
          this.destNode = e2, this.trackList = [];
        }
        hasAudioTrack(e2) {
          return -1 !== this.trackList.indexOf(e2);
        }
        addAudioTrack(e2) {
          -1 === this.trackList.indexOf(e2) ? (OE.debug("add ".concat(e2.getTrackId(), " to mixing track")), e2._source.outputNode.connect(this.destNode), this.trackList.push(e2), this.updateEncoderConfig()) : OE.debug("track ".concat(e2.getTrackId(), " is already added"));
        }
        removeAudioTrack(e2) {
          if (-1 !== this.trackList.indexOf(e2)) {
            OE.debug("remove ".concat(e2.getTrackId(), " from mixing track"));
            try {
              e2._source.outputNode.disconnect(this.destNode);
            } catch (e3) {
            }
            aC(this.trackList, e2), this.updateEncoderConfig();
          }
        }
        updateEncoderConfig() {
          const e2 = {};
          this.trackList.forEach((t2) => {
            t2._encoderConfig && ((t2._encoderConfig.bitrate || 0) > (e2.bitrate || 0) && (e2.bitrate = t2._encoderConfig.bitrate), (t2._encoderConfig.sampleRate || 0) > (e2.sampleRate || 0) && (e2.sampleRate = t2._encoderConfig.sampleRate), (t2._encoderConfig.sampleSize || 0) > (e2.sampleSize || 0) && (e2.sampleSize = t2._encoderConfig.sampleSize), t2._encoderConfig.stereo && (e2.stereo = true));
          }), this._encoderConfig = e2;
        }
        _updateRtpTransceiver(e2) {
          this._rtpTransceiver !== e2 && (this._rtpTransceiver = e2, this.trackList.forEach((t2) => {
            t2 instanceof NI ? t2.emit(ES.TRANSCEIVER_UPDATED, e2) : t2._updateRtpTransceiver(e2);
          }));
        }
      }
      class bI extends EE {
        constructor() {
          super(...arguments), _p(this, "resultStorage", /* @__PURE__ */ new Map());
        }
        setLocalAudioStats(e2, t2, i2) {
          this.record("AUDIO_INPUT_LEVEL_TOO_LOW", e2, this.checkAudioInputLevel(i2, t2)), this.record("SEND_AUDIO_BITRATE_TOO_LOW", e2, this.checkSendAudioBitrate(i2, t2));
        }
        setLocalVideoStats(e2, t2, i2) {
          this.record("SEND_VIDEO_BITRATE_TOO_LOW", e2, this.checkSendVideoBitrate(i2, t2)), this.record("FRAMERATE_INPUT_TOO_LOW", e2, this.checkFramerateInput(i2, t2)), this.record("FRAMERATE_SENT_TOO_LOW", e2, this.checkFramerateSent(i2));
        }
        setRemoteAudioStats(e2, t2) {
          const i2 = e2.getUserId();
          this.record("AUDIO_OUTPUT_LEVEL_TOO_LOW", i2, this.checkAudioOutputLevel(t2));
        }
        setRemoteVideoStats(e2, t2) {
          const i2 = e2.getUserId();
          this.record("RECV_VIDEO_DECODE_FAILED", i2, this.checkVideoDecode(t2));
        }
        record(e2, t2, i2) {
          if (GE("STATS_UPDATE_INTERVAL") > 500)
            return;
          this.resultStorage.has(e2) || this.resultStorage.set(e2, { result: [], isPrevNormal: true });
          const n2 = this.resultStorage.get(e2);
          if (n2 && (n2.result.push(i2), n2.result.length >= 5)) {
            const i3 = n2.result.includes(true);
            n2.isPrevNormal && !i3 && this.emit("exception", wI[e2], e2, t2), !n2.isPrevNormal && i3 && this.emit("exception", wI[e2] + 2e3, e2 + "_RECOVER", t2), n2.isPrevNormal = i3, n2.result = [];
          }
        }
        checkAudioOutputLevel(e2) {
          return !(e2.receiveBitrate > 0 && 0 === e2.receiveLevel);
        }
        checkAudioInputLevel(e2, t2) {
          return t2 instanceof NI && !t2.isActive || (!!t2.muted || 0 !== e2.sendVolumeLevel);
        }
        checkFramerateInput(e2, t2) {
          let i2 = null;
          t2._encoderConfig && t2._encoderConfig.frameRate && (i2 = FI(t2._encoderConfig.frameRate));
          const n2 = e2.captureFrameRate;
          return !i2 || !n2 || !(i2 > 10 && n2 < 5 || i2 < 10 && i2 >= 5 && n2 <= 1);
        }
        checkFramerateSent(e2) {
          return !(e2.captureFrameRate && e2.sendFrameRate && e2.captureFrameRate > 5 && e2.sendFrameRate <= 1);
        }
        checkSendVideoBitrate(e2, t2) {
          return !!t2.muted || 0 !== e2.sendBitrate;
        }
        checkSendAudioBitrate(e2, t2) {
          return t2 instanceof NI && !t2.isActive || (!!t2.muted || 0 !== e2.sendBitrate);
        }
        checkVideoDecode(e2) {
          return 0 === e2.receiveBitrate || 0 !== e2.decodeFrameRate;
        }
      }
      const wI = { FRAMERATE_INPUT_TOO_LOW: 1001, FRAMERATE_SENT_TOO_LOW: 1002, SEND_VIDEO_BITRATE_TOO_LOW: 1003, RECV_VIDEO_DECODE_FAILED: 1005, AUDIO_INPUT_LEVEL_TOO_LOW: 2001, AUDIO_OUTPUT_LEVEL_TOO_LOW: 2002, SEND_AUDIO_BITRATE_TOO_LOW: 2003 };
      const DI = new class {
        markSubscribeStart(e2, t2) {
          performance.mark("agora-web-sdk/".concat(e2, "/subscribe-").concat(t2));
        }
        markPublishStart(e2, t2) {
          performance.mark("agora-web-sdk/".concat(e2, "/publish-").concat(t2));
        }
        measureFromSubscribeStart(e2, t2) {
          const i2 = performance.getEntriesByName("agora-web-sdk/".concat(e2, "/subscribe-").concat(t2));
          if (i2.length > 0) {
            const e3 = i2[i2.length - 1];
            return Math.round(performance.now() - e3.startTime);
          }
          return 0;
        }
        measureFromPublishStart(e2, t2) {
          const i2 = performance.getEntriesByName("agora-web-sdk/".concat(e2, "/publish-").concat(t2));
          if (i2.length > 0) {
            const e3 = i2[i2.length - 1];
            return Math.round(performance.now() - e3.startTime);
          }
          return 0;
        }
      }();
      function PI(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function LI(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? PI(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : PI(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class kI {
        constructor(e2) {
          _p(this, "store", void 0), _p(this, "onStatsException", void 0), _p(this, "onUploadPublishDuration", void 0), _p(this, "onStatsChanged", void 0), _p(this, "localStats", /* @__PURE__ */ new Map()), _p(this, "remoteStats", /* @__PURE__ */ new Map()), _p(this, "updateStatsInterval", void 0), _p(this, "trafficStats", void 0), _p(this, "trafficStatsPeerList", []), _p(this, "uplinkStats", void 0), _p(this, "exceptionMonitor", void 0), _p(this, "p2pChannel", void 0), _p(this, "scalabilityMode", Lh.L1T1), _p(this, "updateStats", () => {
            this.p2pChannel && (this.updateRemoteStats(this.p2pChannel), this.updateLocalStats(this.p2pChannel));
          }), this.store = e2, this.updateStatsInterval = window.setInterval(this.updateStats, 1e3), this.exceptionMonitor = new bI(), this.exceptionMonitor.on("exception", (e3, t2, i2) => {
            this.onStatsException && this.onStatsException(e3, t2, i2);
          });
        }
        reset() {
          this.localStats = /* @__PURE__ */ new Map(), this.remoteStats = /* @__PURE__ */ new Map(), this.trafficStats = void 0, this.trafficStatsPeerList = [], this.uplinkStats = void 0;
        }
        getLocalAudioTrackStats() {
          return this.localStats.get(bS.LocalAudioTrack) || LI({}, jf);
        }
        getLocalVideoTrackStats() {
          return this.localStats.get(bS.LocalVideoTrack) || LI({}, Ff);
        }
        getRemoteAudioTrackStats(e2) {
          const t2 = (e3, t3) => {
            if (!this.trafficStats)
              return t3;
            const i3 = this.trafficStats.peer_delay.find((t4) => t4.peer_uid === e3);
            return i3 && (t3.publishDuration = i3.B_ppad + (Date.now() - this.trafficStats.timestamp)), t3;
          }, i2 = {};
          if (e2) {
            var n2;
            const r2 = null === (n2 = this.remoteStats.get(e2)) || void 0 === n2 ? void 0 : n2.audioStats;
            r2 && (i2[e2] = t2(e2, r2));
          } else
            Array.from(this.remoteStats.entries()).forEach((e3) => {
              let [n3, { audioStats: r2 }] = e3;
              r2 && (i2[n3] = t2(n3, r2));
            });
          return i2;
        }
        getRemoteNetworkQualityStats(e2) {
          const t2 = {};
          if (e2) {
            var i2;
            const n2 = null === (i2 = this.remoteStats.get(e2)) || void 0 === i2 ? void 0 : i2.networkStats;
            n2 && (t2[e2] = n2);
          } else
            Array.from(this.remoteStats.entries()).forEach((e3) => {
              let [i3, { networkStats: n2 }] = e3;
              n2 && (t2[i3] = n2);
            });
          return t2;
        }
        getRemoteVideoTrackStats(e2) {
          const t2 = (e3, t3) => {
            if (!this.trafficStats)
              return t3;
            const i3 = this.trafficStats.peer_delay.find((t4) => t4.peer_uid === e3);
            return i3 && (t3.publishDuration = i3.B_ppvd + (Date.now() - this.trafficStats.timestamp)), t3;
          }, i2 = {};
          if (e2) {
            var n2;
            const r2 = null === (n2 = this.remoteStats.get(e2)) || void 0 === n2 ? void 0 : n2.videoStats;
            r2 && (i2[e2] = t2(e2, r2));
          } else
            Array.from(this.remoteStats.entries()).forEach((e3) => {
              let [n3, { videoStats: r2 }] = e3;
              r2 && (i2[n3] = t2(n3, r2));
            });
          return i2;
        }
        getRTCStats() {
          let e2 = 0, t2 = 0, i2 = 0, n2 = 0;
          const r2 = this.localStats.get(bS.LocalAudioTrack);
          r2 && (e2 += r2.sendBytes, t2 += r2.sendBitrate);
          const o2 = this.localStats.get(bS.LocalVideoTrack);
          o2 && (e2 += o2.sendBytes, t2 += o2.sendBitrate);
          const s2 = this.localStats.get(bS.LocalVideoLowTrack);
          s2 && (e2 += s2.sendBytes, t2 += s2.sendBitrate), this.remoteStats.forEach((e3) => {
            let { audioStats: t3, videoStats: r3 } = e3;
            t3 && (i2 += t3.receiveBytes, n2 += t3.receiveBitrate), r3 && (i2 += r3.receiveBytes, n2 += r3.receiveBitrate);
          });
          let a2 = 1;
          return this.trafficStats && (a2 += this.trafficStats.peer_delay.length), { Duration: 0, UserCount: a2, SendBitrate: t2, SendBytes: e2, RecvBytes: i2, RecvBitrate: n2, OutgoingAvailableBandwidth: this.uplinkStats ? this.uplinkStats.B_uab / 1e3 : 0, RTT: this.trafficStats ? 2 * this.trafficStats.B_acd : 0 };
        }
        addLocalStats(e2) {
          this.localStats.set(e2, void 0);
        }
        removeLocalStats(e2) {
          e2 ? this.localStats.delete(e2) : this.localStats.clear();
        }
        addRemoteStats(e2) {
          this.remoteStats.set(e2, {});
        }
        removeRemoteStats(e2) {
          e2 ? this.remoteStats.delete(e2) : this.remoteStats.clear();
        }
        addP2PChannel(e2) {
          this.p2pChannel = e2;
        }
        updateTrafficStats(e2) {
          e2.peer_delay = e2.peer_delay.filter((e3) => void 0 !== e3.B_ppad || void 0 !== e3.B_ppvd);
          e2.peer_delay.filter((e3) => -1 === this.trafficStatsPeerList.indexOf(e3.peer_uid)).forEach((e3) => {
            var t2;
            const i2 = null === (t2 = this.p2pChannel) || void 0 === t2 ? void 0 : t2.getRemoteMedia(e3.peer_uid), n2 = null != i2 && i2.videoSSRC ? DI.measureFromSubscribeStart(this.store.clientId, i2.videoSSRC) : 0, r2 = null != i2 && i2.audioSSRC ? DI.measureFromSubscribeStart(this.store.clientId, i2.audioSSRC) : 0;
            void 0 !== e3.B_ppad && void 0 !== e3.B_ppvd && (this.onUploadPublishDuration && this.onUploadPublishDuration(e3.peer_uid, e3.B_ppad, e3.B_ppvd, n2 > r2 ? n2 : r2), this.trafficStatsPeerList.push(e3.peer_uid));
          }), this.trafficStats = e2;
        }
        updateUplinkStats(e2) {
          this.uplinkStats && this.uplinkStats.B_fir !== e2.B_fir && OE.debug("[".concat(this.store.clientId, "]: Period fir changes to ").concat(e2.B_fir)), this.uplinkStats = e2;
        }
        static isRemoteVideoFreeze(e2, t2, i2) {
          if (!e2)
            return false;
          const n2 = !!i2 && t2.framesDecodeFreezeTime > i2.framesDecodeFreezeTime, r2 = !i2 || t2.framesDecodeCount > i2.framesDecodeCount;
          return n2 || !r2;
        }
        static isRemoteAudioFreeze(e2) {
          return !!e2 && e2._isFreeze();
        }
        isLocalVideoFreeze(e2) {
          return !(!e2.inputFrame || !e2.sentFrame) && (e2.inputFrame.frameRate > 5 && e2.sentFrame.frameRate < 3);
        }
        updateLocalStats(e2) {
          Array.from(this.localStats.entries()).forEach((t2) => {
            let [i2, n2] = t2;
            switch (i2) {
              case bS.LocalVideoTrack:
              case bS.LocalVideoLowTrack: {
                const t3 = n2, o2 = LI({}, Ff), s2 = e2.getStats(), a2 = e2.getLocalMedia(i2);
                if (s2) {
                  const i3 = s2.videoSend.find((e3) => e3.ssrc === (null == a2 ? void 0 : a2.ssrcs[0].ssrcId));
                  if (i3) {
                    const n3 = e2.getLocalVideoSize(), r3 = e2.getEncoderConfig(bS.LocalVideoTrack);
                    "H264" !== i3.codec && "H265" !== i3.codec && "VP8" !== i3.codec && "VP9" !== i3.codec && "AV1X" !== i3.codec && "AV1" !== i3.codec || (o2.codecType = i3.codec), o2.sendBytes = i3.bytes, o2.sendBitrate = t3 ? 8 * Math.max(0, o2.sendBytes - t3.sendBytes) : 0, i3.inputFrame ? (o2.captureFrameRate = i3.inputFrame.frameRate, o2.captureResolutionHeight = i3.inputFrame.height, o2.captureResolutionWidth = i3.inputFrame.width) : n3 && (o2.captureResolutionWidth = n3.width, o2.captureResolutionHeight = n3.height), i3.sentFrame ? (o2.sendFrameRate = i3.sentFrame.frameRate, o2.sendResolutionHeight = i3.sentFrame.height, o2.sendResolutionWidth = i3.sentFrame.width) : n3 && (o2.sendResolutionWidth = n3.width, o2.sendResolutionHeight = n3.height), i3.avgEncodeMs && (o2.encodeDelay = i3.avgEncodeMs), r3 && r3.bitrateMax && (o2.targetSendBitrate = 1e3 * r3.bitrateMax), o2.sendPackets = i3.packets, o2.sendPacketsLost = i3.packetsLost, o2.totalDuration = t3 ? t3.totalDuration + 1 : 1, o2.totalFreezeTime = t3 ? t3.totalFreezeTime : 0, this.isLocalVideoFreeze(i3) && (o2.totalFreezeTime += 1), i3.scalabilityMode && this.scalabilityMode !== i3.scalabilityMode && (OE.debug("[".concat(this.store.clientId, "]: The scalabilityMode of the video sending stream is ").concat(i3.scalabilityMode)), this.scalabilityMode = i3.scalabilityMode);
                  }
                  this.trafficStats && (o2.sendPacketsLost = this.trafficStats.B_pvlr4 / 100);
                }
                var r2;
                if (this.localStats.set(i2, o2), (null == t3 ? void 0 : t3.sendResolutionWidth) !== o2.sendResolutionWidth || (null == t3 ? void 0 : t3.sendResolutionHeight) !== o2.sendResolutionHeight)
                  null === (r2 = this.onStatsChanged) || void 0 === r2 || r2.call(this, "resolution", { width: o2.sendResolutionWidth, height: o2.sendResolutionHeight });
                o2 && a2 && this.exceptionMonitor.setLocalVideoStats(this.store.uid, a2.track, o2);
                break;
              }
              case bS.LocalAudioTrack: {
                const t3 = n2, r3 = LI({}, jf), o2 = e2.getStats(), s2 = e2.getLocalMedia(i2);
                if (o2) {
                  const i3 = o2.audioSend.find((e3) => e3.ssrc === (null == s2 ? void 0 : s2.ssrcs[0].ssrcId));
                  if (i3) {
                    if ("opus" !== i3.codec && "aac" !== i3.codec && "PCMU" !== i3.codec && "PCMA" !== i3.codec && "G722" !== i3.codec || (r3.codecType = i3.codec), i3.inputLevel)
                      r3.sendVolumeLevel = Math.round(32767 * i3.inputLevel);
                    else {
                      const t4 = e2.getLocalAudioVolume();
                      t4 && (r3.sendVolumeLevel = Math.round(32767 * t4));
                    }
                    r3.sendBytes = i3.bytes, r3.sendPackets = i3.packets, r3.sendPacketsLost = i3.packetsLost, r3.sendBitrate = t3 ? 8 * Math.max(0, r3.sendBytes - t3.sendBytes) : 0;
                  }
                }
                this.trafficStats && (r3.sendPacketsLost = this.trafficStats.B_pvlr4 / 100), this.localStats.set(bS.LocalAudioTrack, r3), r3 && s2 && this.exceptionMonitor.setLocalAudioStats(this.store.uid, s2.track, r3);
                break;
              }
            }
          });
        }
        updateRemoteStats(e2) {
          Array.from(this.remoteStats.entries()).forEach((t2) => {
            let [i2, { videoStats: n2, audioStats: r2, videoPcStats: o2 }] = t2;
            const s2 = r2, a2 = n2, c2 = o2, d2 = LI({}, Bf), u2 = LI({}, Wf), l2 = LI({}, Gf), { audioTrack: h2, videoTrack: p2, audioSSRC: _2, videoSSRC: E2 } = e2.getRemoteMedia(i2), m2 = e2.getStats(), f2 = null == m2 ? void 0 : m2.audioRecv.find((e3) => e3.ssrc === _2), S2 = null == m2 ? void 0 : m2.videoRecv.find((e3) => e3.ssrc === E2), T2 = this.trafficStats && this.trafficStats.peer_delay.find((e3) => e3.peer_uid === i2);
            if (f2 && ("opus" !== f2.codec && "aac" !== f2.codec && "PCMU" !== f2.codec && "PCMA" !== f2.codec && "G722" !== f2.codec || (d2.codecType = f2.codec), f2.outputLevel ? d2.receiveLevel = Math.round(32767 * f2.outputLevel) : h2 && (d2.receiveLevel = Math.round(32767 * h2.getVolumeLevel())), d2.receiveBytes = f2.bytes, d2.receivePackets = f2.packets, d2.receivePacketsLost = f2.packetsLost, d2.packetLossRate = d2.receivePacketsLost / (d2.receivePackets + d2.receivePacketsLost), d2.receiveBitrate = s2 ? 8 * Math.max(0, d2.receiveBytes - s2.receiveBytes) : 0, d2.totalDuration = s2 ? s2.totalDuration + 1 : 1, d2.totalFreezeTime = s2 ? s2.totalFreezeTime : 0, d2.freezeRate = d2.totalFreezeTime / d2.totalDuration, d2.receiveDelay = f2.jitterBufferMs, d2.totalDuration > 10 && kI.isRemoteAudioFreeze(h2) && (d2.totalFreezeTime += 1)), S2) {
              "H264" !== S2.codec && "H265" !== S2.codec && "VP8" !== S2.codec && "VP9" !== S2.codec && "AV1X" !== S2.codec && "AV1" !== S2.codec || (u2.codecType = S2.codec), u2.receiveBytes = S2.bytes, u2.receiveBitrate = a2 ? 8 * Math.max(0, u2.receiveBytes - a2.receiveBytes) : 0, u2.decodeFrameRate = S2.decodeFrameRate < 0 ? 0 : S2.decodeFrameRate, u2.renderFrameRate = S2.decodeFrameRate < 0 ? 0 : S2.decodeFrameRate, S2.outputFrame && (u2.renderFrameRate = S2.outputFrame.frameRate), S2.receivedFrame ? (u2.receiveFrameRate = S2.receivedFrame.frameRate, u2.receiveResolutionHeight = S2.receivedFrame.height, u2.receiveResolutionWidth = S2.receivedFrame.width) : p2 && (u2.receiveResolutionHeight = p2._videoHeight || 0, u2.receiveResolutionWidth = p2._videoWidth || 0), void 0 !== S2.framesRateFirefox && (u2.receiveFrameRate = Math.round(S2.framesRateFirefox)), u2.receivePackets = S2.packets, u2.receivePacketsLost = S2.packetsLost, u2.packetLossRate = u2.receivePacketsLost / (u2.receivePackets + u2.receivePacketsLost), u2.totalDuration = a2 ? a2.totalDuration + 1 : 1, u2.totalFreezeTime = a2 ? a2.totalFreezeTime : 0, u2.receiveDelay = S2.jitterBufferMs || 0;
              const t3 = !!E2 && e2.getRemoteVideoIsReady(E2);
              p2 && t3 && kI.isRemoteVideoFreeze(p2, S2, c2) && (u2.totalFreezeTime += 1), u2.freezeRate = u2.totalFreezeTime / u2.totalDuration;
            }
            T2 && (d2.end2EndDelay = T2.B_ad, u2.end2EndDelay = T2.B_vd, d2.transportDelay = T2.B_ed, u2.transportDelay = T2.B_ed, d2.currentPacketLossRate = T2.B_ealr4 / 100, u2.currentPacketLossRate = T2.B_evlr4 / 100, l2.uplinkNetworkQuality = T2.B_punq ? T2.B_punq : 0, l2.downlinkNetworkQuality = T2.B_pdnq ? T2.B_pdnq : 0), this.remoteStats.set(i2, { audioStats: d2, videoStats: u2, videoPcStats: S2, networkStats: l2 }), h2 && this.exceptionMonitor.setRemoteAudioStats(h2, d2), p2 && this.exceptionMonitor.setRemoteVideoStats(p2, u2);
          });
        }
      }
      const MI = new class extends EE {
        get visibility() {
          return document.visibilityState;
        }
        get lastHiddenTime() {
          return this._lastHiddenTime;
        }
        get lastVisibleTime() {
          return this._lastVisibleTime;
        }
        constructor() {
          super(), _p(this, "_lastHiddenTime", 0), _p(this, "_lastVisibleTime", 0), document.addEventListener("visibilitychange", () => {
            "hidden" === document.visibilityState ? this._lastHiddenTime = performance.now() : this._lastVisibleTime = performance.now(), OE.debug("document visibility went ".concat(document.visibilityState)), this.emit("VISIBILITY_CHANGE", document.visibilityState);
          });
        }
      }();
      function UI(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function xI(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? UI(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : UI(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      function VI(e2) {
        return e2.match(/^[\.\:\d]+$/) ? "".concat(e2.replace(/[^\d]/g, "-"), ".").concat(GE("TURN_DOMAIN")) : (OE.info("Cannot recognized as IP address ".concat(e2, ". Used As Host instead")), e2);
      }
      function jI(e2, t2) {
        var i2, n2;
        const r2 = GE("GATEWAY_DOMAINS");
        let o2 = r2[1] && -1 !== t2.indexOf(r2[1]) ? 1 : 0;
        e2.addresses = e2.addresses || [];
        const s2 = e2.addresses.map((e3) => e3.domain_prefix ? { address: "".concat(e3.domain_prefix, ".").concat(r2[o2++ % r2.length], ":").concat(e3.port) } : e3.ip.match(/^[\.\:\d]+$/) ? { ip: e3.ip, port: e3.port, address: "".concat(e3.ip.replace(/[^\d]/g, "-"), ".").concat(r2[o2++ % r2.length], ":").concat(e3.port) } : (OE.info("Cannot recognized as IP address ".concat(e3.ip, ". Used As Host instead")), { ip: e3.ip, port: e3.port, address: "".concat(e3.ip, ":").concat(e3.port) }));
        if (null !== (i2 = e2.detail) && void 0 !== i2 && i2[18] && "string" == typeof (null === (n2 = e2.detail) || void 0 === n2 ? void 0 : n2[18])) {
          const t3 = e2.detail[18], i3 = null == t3 ? void 0 : t3.split(";");
          for (let e3 = 0; e3 < i3.length; e3++) {
            var a2;
            const t4 = mh(a2 = i3[e3]).call(a2);
            s2[e3] && t4 && (s2[e3].ip6 = t4);
          }
        }
        return { gatewayAddrs: s2, uid: e2.uid, cid: e2.cid, cert: e2.cert, vid: e2.detail && e2.detail[8], uni_lbs_ip: e2.detail && e2.detail[1], res: e2, csIp: e2.detail && e2.detail[502] };
      }
      function FI(e2) {
        return "number" == typeof e2 ? e2 : e2.exact || e2.ideal || e2.max || e2.min || 0;
      }
      function BI(e2) {
        const t2 = e2._encoderConfig;
        if (!t2)
          return {};
        const i2 = { resolution: t2.width && t2.height ? "".concat(FI(t2.width), "x").concat(FI(t2.height)) : void 0, maxVideoBW: t2.bitrateMax, minVideoBW: t2.bitrateMin };
        return "number" == typeof t2.frameRate ? (i2.maxFrameRate = t2.frameRate, i2.minFrameRate = t2.frameRate) : t2.frameRate && (i2.maxFrameRate = t2.frameRate.max || t2.frameRate.ideal || t2.frameRate.exact || t2.frameRate.min, i2.minFrameRate = t2.frameRate.min || t2.frameRate.ideal || t2.frameRate.exact || t2.frameRate.max), i2;
      }
      function GI(e2) {
        return e2 >= 0 && e2 < 0.17 ? 1 : e2 >= 0.17 && e2 < 0.36 ? 2 : e2 >= 0.36 && e2 < 0.59 ? 3 : e2 >= 0.59 && e2 <= 1 ? 4 : e2 > 1 ? 5 : 0;
      }
      function WI(e2, t2) {
        let i2, n2, r2 = void 0;
        switch (t2) {
          case XS.CHOOSE_SERVER:
            i2 = 4096, n2 = "choose server";
            break;
          case XS.CLOUD_PROXY:
            i2 = 1048576, n2 = "proxy";
            break;
          case XS.CLOUD_PROXY_5:
            i2 = 4194304, n2 = "proxy5";
            break;
          case XS.CLOUD_PROXY_FALLBACK:
            i2 = 4194310, n2 = "proxy fallback";
            break;
          default:
            throw new SE(fE.UNEXPECTED_ERROR, "multi unlibs response transformer get unknown service id", { csIp: e2.detail && e2.detail[502], retry: false });
        }
        if (e2.response_body.forEach((t3) => {
          t3.buffer && t3.buffer.flag === i2 && (r2 = { code: t3.buffer.code, addresses: (t3.buffer.edges_services || []).map((e3) => xI(xI({}, e3), {}, { ticket: t3.buffer.cert })), server_ts: e2.enter_ts, uid: t3.buffer.uid, cid: t3.buffer.cid, cname: t3.buffer.cname, detail: xI(xI({}, t3.buffer.detail), e2.detail), flag: t3.buffer.flag, opid: e2.opid, cert: t3.buffer.cert });
        }), !r2)
          throw new SE(fE.MULTI_UNILBS_RESPONSE_ERROR, "cannot parse response ".concat(n2, " from multi unilbs response"), { csIp: e2.detail && e2.detail[502] });
        return r2;
      }
      async function HI(e2, t2) {
        return await Sl.all(e2.addresses.map(async (e3) => ({ address: VI(e3.ip), tcpport: e3.port, udpport: e3.port, username: t2 && GE("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? t2.toString() : PE.username, password: t2 && GE("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? await Ng(t2.toString()) : PE.password })));
      }
      function KI(e2, t2) {
        const i2 = t2._videoWidth || t2.getMediaStreamTrack(true).getSettings().width;
        return i2 || OE.warning("cannot get original video track's width, default scale down 4 times for low stream"), i2 ? i2 / FI(e2.width) : 4;
      }
      function YI(e2) {
        let { candidateType: t2, relayProtocol: i2, type: n2, address: r2, port: o2, protocol: s2 } = e2;
        return "local-candidate" === n2 ? { candidateType: t2, relayProtocol: i2, protocol: s2 } : { candidateType: t2, relayProtocol: i2, address: r2, port: o2, protocol: s2 };
      }
      function qI(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function JI(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? qI(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : qI(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      function XI(e2) {
        return window.TextEncoder ? new TextEncoder().encode(e2).length : e2.length;
      }
      function zI(e2) {
        return new Sl((t2) => {
          window.setTimeout(t2, e2);
        });
      }
      function QI(e2) {
        const t2 = new SE(fE.TIMEOUT, "timeout");
        return new Sl((i2, n2) => {
          window.setTimeout(() => n2(t2), e2);
        });
      }
      function ZI() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 7, t2 = arguments.length > 1 ? arguments[1] : void 0;
        const i2 = Math.random().toString(16).substr(2, e2).toLowerCase();
        return i2.length === e2 ? "".concat(t2).concat(i2) : "".concat(t2).concat(i2) + ZI(e2 - i2.length, "");
      }
      function $I() {
        return ZI(32, "").toUpperCase();
      }
      const eC = () => {
      };
      function tC(e2) {
        return new Sl((t2, i2) => {
          let n2 = false;
          const r2 = document.createElement("video");
          r2.setAttribute("autoplay", ""), r2.setAttribute("muted", ""), r2.muted = true, r2.autoplay = true, r2.setAttribute("playsinline", ""), r2.setAttribute("style", "position: fixed; top: 0; left: 0; width: 1px; height: 1px"), document.body.appendChild(r2);
          const o2 = Yh() ? "canplay" : "playing";
          r2.addEventListener(o2, () => {
            const e3 = r2.videoWidth, i3 = r2.videoHeight;
            !e3 && Kh() || (n2 = true, r2.srcObject = null, r2.remove(), t2([e3, i3]));
          }), r2.srcObject = new MediaStream([e2]), r2.play().catch(eC), setTimeout(() => {
            n2 || (r2.srcObject = null, r2.remove(), t2([r2.videoWidth, r2.videoHeight]));
          }, 4e3);
        });
      }
      function iC(e2) {
        return Sl.all(e2.map((e3) => e3.then((e4) => {
          throw e4;
        }, (e4) => e4))).then((e3) => {
          throw e3;
        }, (e3) => e3);
      }
      function nC(e2, t2) {
        for (var i2 = arguments.length, n2 = new Array(i2 > 2 ? i2 - 2 : 0), r2 = 2; r2 < i2; r2++)
          n2[r2 - 2] = arguments[r2];
        return 0 === e2.getListeners(t2).length ? Sl.reject(new SE(fE.UNEXPECTED_ERROR, "can not emit promise")) : new Sl((i3, r3) => {
          e2.emit(t2, ...n2, i3, r3);
        });
      }
      function rC(e2, t2) {
        if (0 === e2.getListeners(t2).length)
          return Sl.resolve();
        for (var i2 = arguments.length, n2 = new Array(i2 > 2 ? i2 - 2 : 0), r2 = 2; r2 < i2; r2++)
          n2[r2 - 2] = arguments[r2];
        return nC(e2, t2, ...n2);
      }
      function oC(e2, t2) {
        if (0 === e2.getListeners(t2).length)
          return null;
        for (var i2 = arguments.length, n2 = new Array(i2 > 2 ? i2 - 2 : 0), r2 = 2; r2 < i2; r2++)
          n2[r2 - 2] = arguments[r2];
        return sC(e2, t2, ...n2);
      }
      function sC(e2, t2) {
        let i2 = null, n2 = null;
        for (var r2 = arguments.length, o2 = new Array(r2 > 2 ? r2 - 2 : 0), s2 = 2; s2 < r2; s2++)
          o2[s2 - 2] = arguments[s2];
        if (e2.emit(t2, ...o2, (e3) => {
          i2 = e3;
        }, (e3) => {
          n2 = e3;
        }), null !== n2)
          throw n2;
        if (null === i2)
          throw new SE(fE.UNEXPECTED_ERROR, "handler is not sync");
        return i2;
      }
      function aC(e2, t2) {
        const i2 = e2.indexOf(t2);
        -1 !== i2 && e2.splice(i2, 1);
      }
      function cC(e2) {
        const t2 = [];
        return e2.forEach((e3) => {
          -1 === t2.indexOf(e3) && t2.push(e3);
        }), t2;
      }
      function dC(e2) {
        Sl.resolve().then(e2);
      }
      function uC(e2) {
        return JSON.parse(JSON.stringify(e2));
      }
      const lC = {};
      function hC(e2, t2) {
        lC[t2] || (lC[t2] = true, e2());
      }
      function pC(e2) {
        const t2 = window.atob(e2), i2 = new Uint8Array(new ArrayBuffer(t2.length));
        for (let e3 = 0; e3 < t2.length; e3 += 1)
          i2[e3] = t2.charCodeAt(e3);
        return i2;
      }
      function _C(e2) {
        let t2 = "";
        for (let i2 = 0; i2 < e2.length; i2 += 1)
          t2 += String.fromCharCode(e2[i2]);
        return window.btoa(t2);
      }
      const EC = new class {
        constructor() {
          _p(this, "fnMap", /* @__PURE__ */ new Map());
        }
        throttleByKey(e2, t2, i2, n2) {
          for (var r2 = arguments.length, o2 = new Array(r2 > 4 ? r2 - 4 : 0), s2 = 4; s2 < r2; s2++)
            o2[s2 - 4] = arguments[s2];
          if (this.fnMap.has(t2)) {
            const r3 = this.fnMap.get(t2);
            if (r3.threshold !== i2) {
              r3.fn(...r3.args), clearTimeout(r3.timer);
              const s3 = window.setTimeout(() => {
                const e3 = this.fnMap.get(t2);
                e3 && e3.fn(...e3.args), this.fnMap.delete(t2);
              }, i2);
              this.fnMap.set(t2, { fn: e2, threshold: i2, timer: s3, args: o2, skipFn: n2 });
            } else
              r3.skipFn && r3.skipFn(...r3.args), this.fnMap.set(t2, JI(JI({}, r3), {}, { fn: e2, args: o2, skipFn: n2 }));
          } else {
            const r3 = window.setTimeout(() => {
              const e3 = this.fnMap.get(t2);
              e3 && e3.fn(...e3.args), this.fnMap.delete(t2);
            }, i2);
            this.fnMap.set(t2, { fn: e2, threshold: i2, timer: r3, args: o2, skipFn: n2 });
          }
        }
      }(), mC = EC.throttleByKey.bind(EC), fC = async (e2) => {
        let { fragementLength: t2, referenceList: i2, asyncMapHandler: n2, allFailedhandler: r2, promisesCollector: o2 } = e2, s2 = 0;
        const a2 = t2;
        let c2, d2 = 0;
        const u2 = async () => {
          const e3 = (() => {
            const e4 = s2 * a2, t3 = e4 + a2;
            return i2.slice(e4, t3).map(n2);
          })();
          o2 && o2.push(...e3);
          try {
            c2 = await iC(e3);
          } catch (e4) {
            if (d2 += a2, s2++, !(d2 >= i2.length))
              return void await u2();
            r2(e4);
          }
          e3.forEach((e4) => e4.cancel());
        };
        return await u2(), c2;
      };
      function SC(e2) {
        return "object" == typeof e2 && null !== e2 && !(e2 instanceof RegExp);
      }
      const TC = { [Sf.ACCESS_POINT]: { [Rf.NO_FLAG_SET]: { desc: "flag is zero", retry: false }, [Rf.FLAG_SET_BUT_EMPTY]: { desc: "flag is empty", retry: false }, [Rf.INVALID_FALG_SET]: { desc: "invalid flag", retry: false }, [Rf.FLAG_SET_BUT_NO_RE]: { desc: "flag set unilbs but no request", retry: false }, [Rf.INVALID_SERVICE_ID]: { desc: "invalid service id", retry: false }, [Rf.NO_SERVICE_AVAILABLE]: { desc: "no service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_P2P]: { desc: "no unilbs p2p service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_VOET]: { desc: "no unilbs voice service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_WEBRTC]: { desc: "no unilbs webrtc service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_CDS]: { desc: "no cds service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_CDN]: { desc: "no cdn dispatcher service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_TDS]: { desc: "no tds service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_REPORT]: { desc: "no unilbs report service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_APP_CENTER]: { desc: "no app center service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_ENV0]: { desc: "no unilbs sig env0 service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_VOET]: { desc: "no unilbs voet service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_STRING_UID]: { desc: "no string uid service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS]: { desc: "no webrtc unilbs service available", retry: true } }, [Sf.UNILBS]: { [gf.INVALID_VENDOR_KEY]: { desc: "invalid vendor key, can not find appid", retry: false }, [gf.INVALID_CHANNEL_NAME]: { desc: "invalid channel name", retry: false }, [gf.INTERNAL_ERROR]: { desc: "unilbs internal error", retry: false }, [gf.NO_AUTHORIZED]: { desc: "invalid token, authorized failed", retry: false }, [gf.DYNAMIC_KEY_TIMEOUT]: { desc: "dynamic key or token timeout", retry: false }, [gf.NO_ACTIVE_STATUS]: { desc: "no active status", retry: false }, [gf.DYNAMIC_KEY_EXPIRED]: { desc: "dynamic key expired", retry: false }, [gf.STATIC_USE_DYNAMIC_KEY]: { desc: "static use dynamic key", retry: false }, [gf.DYNAMIC_USE_STATIC_KEY]: { desc: "dynamic use static key", retry: false }, [gf.USER_OVERLOAD]: { desc: "amount of users over load", retry: false }, [gf.FORBIDDEN_REGION]: { desc: "the request is forbidden in this area", retry: false }, [gf.CANNOT_MEET_AREA_DEMAND]: { desc: "unable to allocate services in this area", retry: false } }, [Sf.STRING_UID_ALLOCATOR]: { [Tf.IIIEGAL_APPID]: { desc: "invalid appid", retry: false }, [Tf.IIIEGAL_UID]: { desc: "invalid string uid", retry: false }, [Tf.INTERNAL_ERROR]: { desc: "string uid allocator internal error", retry: true } } };
      function gC(e2) {
        const t2 = TC[Math.floor(e2 / 1e4)];
        if (!t2)
          return { desc: "unkonw error", retry: false };
        const i2 = t2[e2 % 1e4];
        if (!i2) {
          if (Math.floor(e2 / 1e4) === Sf.ACCESS_POINT) {
            const t3 = e2 % 1e4;
            if ("1" === t3.toString()[0])
              return { desc: e2.toString(), retry: false };
            if ("2" === t3.toString()[0])
              return { desc: e2.toString(), retry: true };
          }
          return { desc: "unkonw error", retry: false };
        }
        return i2;
      }
      const RC = { [If.K_TIMESTAMP_EXPIRED]: { desc: "K_TIMESTAMP_EXPIRED", action: "failed" }, [If.K_CHANNEL_PERMISSION_INVALID]: { desc: "K_CHANNEL_PERMISSION_INVALID", action: "failed" }, [If.K_CERTIFICATE_INVALID]: { desc: "K_CERTIFICATE_INVALID", action: "failed" }, [If.K_CHANNEL_NAME_EMPTY]: { desc: "K_CHANNEL_NAME_EMPTY", action: "failed" }, [If.K_CHANNEL_NOT_FOUND]: { desc: "K_CHANNEL_NOT_FOUND", action: "failed" }, [If.K_TICKET_INVALID]: { desc: "K_TICKET_INVALID", action: "failed" }, [If.K_CHANNEL_CONFLICTED]: { desc: "K_CHANNEL_CONFLICTED", action: "failed" }, [If.K_SERVICE_NOT_READY]: { desc: "K_SERVICE_NOT_READY", action: "tryNext" }, [If.K_SERVICE_TOO_HEAVY]: { desc: "K_SERVICE_TOO_HEAVY", action: "tryNext" }, [If.K_UID_BANNED]: { desc: "K_UID_BANNED", action: "failed" }, [If.K_IP_BANNED]: { desc: "K_IP_BANNED", action: "failed" }, [If.ERR_INVALID_VENDOR_KEY]: { desc: "ERR_INVALID_VENDOR_KEY", action: "failed" }, [If.ERR_INVALID_CHANNEL_NAME]: { desc: "ERR_INVALID_CHANNEL_NAME", action: "failed" }, [If.WARN_NO_AVAILABLE_CHANNEL]: { desc: "WARN_NO_AVAILABLE_CHANNEL", action: "failed" }, [If.WARN_LOOKUP_CHANNEL_TIMEOUT]: { desc: "WARN_LOOKUP_CHANNEL_TIMEOUT", action: "tryNext" }, [If.WARN_LOOKUP_CHANNEL_REJECTED]: { desc: "WARN_LOOKUP_CHANNEL_REJECTED", action: "failed" }, [If.WARN_OPEN_CHANNEL_TIMEOUT]: { desc: "WARN_OPEN_CHANNEL_TIMEOUT", action: "tryNext" }, [If.WARN_OPEN_CHANNEL_REJECTED]: { desc: "WARN_OPEN_CHANNEL_REJECTED", action: "failed" }, [If.WARN_REQUEST_DEFERRED]: { desc: "WARN_REQUEST_DEFERRED", action: "failed" }, [If.ERR_DYNAMIC_KEY_TIMEOUT]: { desc: "ERR_DYNAMIC_KEY_TIMEOUT", action: "failed" }, [If.ERR_NO_AUTHORIZED]: { desc: "ERR_NO_AUTHORIZED", action: "failed" }, [If.ERR_VOM_SERVICE_UNAVAILABLE]: { desc: "ERR_VOM_SERVICE_UNAVAILABLE", action: "tryNext" }, [If.ERR_NO_CHANNEL_AVAILABLE_CODE]: { desc: "ERR_NO_CHANNEL_AVAILABLE_CODE", action: "failed" }, [If.ERR_MASTER_VOCS_UNAVAILABLE]: { desc: "ERR_MASTER_VOCS_UNAVAILABLE", action: "tryNext" }, [If.ERR_INTERNAL_ERROR]: { desc: "ERR_INTERNAL_ERROR", action: "tryNext" }, [If.ERR_NO_ACTIVE_STATUS]: { desc: "ERR_NO_ACTIVE_STATUS", action: "failed" }, [If.ERR_INVALID_UID]: { desc: "ERR_INVALID_UID", action: "failed" }, [If.ERR_DYNAMIC_KEY_EXPIRED]: { desc: "ERR_DYNAMIC_KEY_EXPIRED", action: "failed" }, [If.ERR_STATIC_USE_DYANMIC_KE]: { desc: "ERR_STATIC_USE_DYANMIC_KE", action: "failed" }, [If.ERR_DYNAMIC_USE_STATIC_KE]: { desc: "ERR_DYNAMIC_USE_STATIC_KE", action: "failed" }, [If.ERR_NO_VOCS_AVAILABLE]: { desc: "ERR_NO_VOCS_AVAILABLE", action: "tryNext" }, [If.ERR_NO_VOS_AVAILABLE]: { desc: "ERR_NO_VOS_AVAILABLE", action: "tryNext" }, [If.ERR_JOIN_CHANNEL_TIMEOUT]: { desc: "ERR_JOIN_CHANNEL_TIMEOUT", action: "tryNext" }, [If.ERR_JOIN_BY_MULTI_IP]: { desc: "ERR_JOIN_BY_MULTI_IP", action: "recover" }, [If.ERR_NOT_JOINED]: { desc: "ERR_NOT_JOINED", action: "failed" }, [If.ERR_REPEAT_JOIN_REQUEST]: { desc: "ERR_REPEAT_JOIN_REQUEST", action: "quit" }, [If.ERR_REPEAT_JOIN_CHANNEL]: { desc: "ERR_REPEAT_JOIN_CHANNEL", action: "quit" }, [If.ERR_INVALID_VENDOR_KEY]: { desc: "ERR_INVALID_VENDOR_KEY", action: "failed" }, [If.ERR_INVALID_CHANNEL_NAME]: { desc: "ERR_INVALID_CHANNEL_NAME", action: "failed" }, [If.ERR_INVALID_STRINGUID]: { desc: "ERR_INVALID_STRINGUID", action: "failed" }, [If.ERR_TOO_MANY_USERS]: { desc: "ERR_TOO_MANY_USERS", action: "tryNext" }, [If.ERR_SET_CLIENT_ROLE_TIMEOUT]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [If.ERR_SET_CLIENT_ROLE_NO_PERMISSION]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [If.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE]: { desc: "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", action: "success" }, [If.ERR_PUBLISH_REQUEST_INVALID]: { desc: "ERR_PUBLISH_REQUEST_INVALID", action: "failed" }, [If.ERR_SUBSCRIBE_REQUEST_INVALID]: { desc: "ERR_SUBSCRIBE_REQUEST_INVALID", action: "failed" }, [If.ERR_NOT_SUPPORTED_MESSAGE]: { desc: "ERR_NOT_SUPPORTED_MESSAGE", action: "failed" }, [If.ERR_ILLEAGAL_PLUGIN]: { desc: "ERR_ILLEAGAL_PLUGIN", action: "failed" }, [If.ILLEGAL_CLIENT_ROLE_LEVEL]: { desc: "ILLEGAL_CLIENT_ROLE_LEVEL", action: "failed" }, [If.ERR_REJOIN_TOKEN_INVALID]: { desc: "ERR_REJOIN_TOKEN_INVALID", action: "failed" }, [If.ERR_REJOIN_USER_NOT_JOINED]: { desc: "ERR_REJOIN_NOT_JOINED", action: "failed" }, [If.ERR_INVALID_OPTIONAL_INFO]: { desc: "ERR_INVALID_OPTIONAL_INFO", action: "quit" }, [If.ERR_TEST_RECOVER]: { desc: "ERR_TEST_RECOVER", action: "recover" }, [If.ERR_TEST_TRYNEXT]: { desc: "ERR_TEST_TRYNEXT", action: "recover" }, [If.ERR_TEST_RETRY]: { desc: "ERR_TEST_RETRY", action: "recover" }, [If.ILLEGAL_AES_PASSWORD]: { desc: "ERR_TEST_RETRY", action: "failed" }, [If.ERR_TOO_MANY_BROADCASTERS]: { desc: "ERR_TOO_MANY_BROADCASTERS", action: "failed" }, [If.ERR_TOO_MANY_SUBSCRIBERS]: { desc: "ERR_TOO_MANY_SUBSCRIBERS", action: "failed" }, [If.ERR_LICENSE_ILLEGAL]: { desc: "ERR_LICENSE_ILLEGAL", action: "quit" }, [If.ERR_LICENSE_MISSING]: { desc: "ERR_LICENSE_MISSING", action: "quit" }, [If.ERR_LICENSE_EXPIRED]: { desc: "ERR_LICENSE_EXPIRED", action: "quit" }, [If.ERR_LICENSE_MINUTES_EXCEEDED]: { desc: "ERR_LICENSE_MINUTES_EXCEEDED", action: "quit" }, [If.ERR_LICENSE_PERIOD_INVALID]: { desc: "ERR_LICENSE_PERIOD_INVALID", action: "quit" }, [If.ERR_LICENSE_MULTIPLE_SDK_SERVICE]: { desc: "ERR_LICENSE_MULTIPLE_SDK_SERVICE", action: "quit" } };
      function IC(e2) {
        const t2 = RC[e2];
        return t2 || { desc: "UNKNOW_ERROR_".concat(e2), action: "failed" };
      }
      function CC(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      class vC extends EE {
        get url() {
          return this.websocket ? this.websocket.url : null;
        }
        get reconnectMode() {
          return this._reconnectMode;
        }
        set reconnectMode(e2) {
          ["tryNext", "recover"].includes(e2) && this.resetReconnectCount(e2), this._reconnectMode = e2;
        }
        get state() {
          return this._state;
        }
        set state(e2) {
          e2 !== this._state && (this._state = e2, "reconnecting" === this._state ? this.emit(Hf.RECONNECTING, this.reconnectReason) : "connected" === this._state ? this.emit(Hf.CONNECTED) : "closed" === this._state ? this.emit(Hf.CLOSED) : "failed" === this._state && this.emit(Hf.FAILED));
        }
        resetReconnectCount(e2) {
          OE.debug("websocket reset reconnect count, reason: " + e2), this.reconnectCount = 0;
        }
        constructor(e2, t2) {
          let i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], r2 = arguments.length > 4 ? arguments[4] : void 0;
          super(), _p(this, "connectionID", 0), _p(this, "currentURLIndex", 0), _p(this, "urls", void 0), _p(this, "_reconnectMode", "tryNext"), _p(this, "reconnectReason", void 0), _p(this, "_initMutex", new Ug("websocket")), _p(this, "name", void 0), _p(this, "_state", "closed"), _p(this, "reconnectInterrupter", void 0), _p(this, "websocket", void 0), _p(this, "retryConfig", void 0), _p(this, "reconnectCount", 0), _p(this, "forceCloseTimeout", 5e3), _p(this, "onlineReconnectListener", void 0), _p(this, "useCompress", void 0), _p(this, "tryDoubleDomain", false), _p(this, "wsInflateLength", 0), _p(this, "wsDeflateLength", 0), _p(this, "closeEstablishingWs", () => {
          }), _p(this, "store", void 0), _p(this, "joinChannelServiceRecordIndex", void 0), this.store = r2, this.name = e2, this.retryConfig = function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var i3 = null != arguments[t3] ? arguments[t3] : {};
              t3 % 2 ? CC(Object(i3), true).forEach(function(t4) {
                _p(e3, t4, i3[t4]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : CC(Object(i3)).forEach(function(t4) {
                Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
              });
            }
            return e3;
          }({}, t2), this.useCompress = i2, this.tryDoubleDomain = n2;
          const { timeout: o2, timeoutFactor: s2 } = t2, a2 = Math.max(300, Math.floor(3 * o2 / 5)), c2 = Math.max(1.2, Math.floor(8 * s2) / 10);
          PS.ONLINE && (this.retryConfig.timeout = a2, this.retryConfig.timeoutFactor = c2), Ig.on(LS.NETWORK_STATE_CHANGE, (e3, t3) => {
            e3 !== t3 && (this.resetReconnectCount("network state change: ".concat(t3, " -> ").concat(e3)), e3 === PS.ONLINE ? (this.retryConfig.timeout = a2, this.retryConfig.timeoutFactor = c2) : (this.retryConfig.timeout = o2, this.retryConfig.timeoutFactor = s2));
          });
        }
        getConnection() {
          return this.websocket || void 0;
        }
        init(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
          this.forceCloseTimeout = t2;
          const i2 = (t3, i3) => {
            this.urls = e2;
            const n2 = this.urls[this.currentURLIndex];
            this.state = "connecting", this.createWebSocketConnection(n2).then(t3).catch(i3), this.once(Hf.CLOSED, () => i3(new SE(fE.WS_DISCONNECT))), this.once(Hf.CONNECTED, () => t3());
          };
          return this._initMutex.lock().then((e3) => new Sl((e4, t3) => {
            i2(e4, t3);
          }).then(() => {
            e3();
          }).catch(() => {
            e3();
          }));
        }
        close(e2, t2) {
          if (this.currentURLIndex = 0, this.resetReconnectCount("close"), this.reconnectInterrupter && this.reconnectInterrupter(), this.websocket) {
            this.websocket.onclose = null, this.websocket.onopen = null, this.websocket.onmessage = null;
            const e3 = this.websocket;
            t2 ? setTimeout(() => e3.close(), 500) : e3.close(), this.websocket = void 0;
          }
          this.state = e2 ? "failed" : "closed", this.closeEstablishingWs && this.closeEstablishingWs();
        }
        reconnect(e2, t2) {
          if (!this.websocket)
            return void OE.warning("[".concat(this.name, "] can not reconnect, no websocket"));
          var i2;
          (void 0 !== e2 && (this.reconnectMode = e2), OE.debug("[".concat(this.name, "] reconnect is triggered initiative")), "number" == typeof this.joinChannelServiceRecordIndex) && (null === (i2 = this.store) || void 0 === i2 || i2.recordJoinChannelService({ status: "error", errors: [new Error(t2)] }, this.joinChannelServiceRecordIndex));
          const n2 = this.websocket.onclose;
          this.websocket.onclose = null, this.websocket.close(), n2 && n2.bind(this.websocket)({ code: 9999, reason: t2 });
        }
        sendMessage(e2) {
          let t2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN)
            throw new SE(fE.WS_ABORT, "websocket is not ready");
          try {
            t2 || (e2 = JSON.stringify(e2)), this.websocket.send(e2);
          } catch (e3) {
            throw new SE(fE.WS_ERR, "send websocket message error" + e3.toString());
          }
        }
        setWsInflateData(e2) {
          this.wsDeflateLength = this.wsDeflateLength + e2.originLength, this.wsInflateLength = this.wsInflateLength + e2.compressedLength;
        }
        getWsInflateData() {
          const e2 = this.wsInflateLength, t2 = this.wsDeflateLength;
          return this.clearWsInflateData(), { wsInflateLength: e2, wsDeflateLength: t2 };
        }
        clearWsInflateData() {
          this.wsInflateLength = 0, this.wsDeflateLength = 0;
        }
        async createWebSocketConnection(e2, t2) {
          return this.connectionID += 1, this.connectionID, this.joinChannelServiceRecordIndex = void 0, new Sl((i2, n2) => {
            var r2;
            const o2 = (e3) => {
              var t3;
              null === (t3 = this.store) || void 0 === t3 || t3.signalChannelOpen(), OE.debug("[".concat(this.name, "] websocket opened:"), e3), this.reconnectMode = "retry", this.state = "connected", this.resetReconnectCount("opened"), i2();
            }, s2 = async (e3) => {
              if (OE.debug("[".concat(this.name, "] websocket close ").concat(this.websocket && this.websocket.url, ", code: ").concat(e3.code, ", reason: ").concat(e3.reason, ", current mode: ").concat(this.reconnectMode)), this.reconnectCount < this.retryConfig.maxRetryCount) {
                "connected" === this.state && (this.reconnectReason = e3.reason, this.state = "reconnecting");
                const t3 = oC(this, Hf.WILL_RECONNECT, this.reconnectMode) || this.reconnectMode, r3 = await this.reconnectWithAction(t3);
                if ("closed" === this.state)
                  return void OE.debug("[".concat(this.connectionID, "] ws is closed, no need to reconnect"));
                if (!r3)
                  return n2(new SE(fE.WS_DISCONNECT, "websocket reconnect failed: ".concat(e3.code))), void this.close(true);
                i2();
              } else
                n2(new SE(fE.WS_DISCONNECT, "websocket close: ".concat(e3.code))), this.close();
            }, a2 = (e3) => {
              this.emit(Hf.ON_MESSAGE, e3);
            };
            this.websocket && (this.websocket.onclose = null, this.websocket.close()), GE("GATEWAY_WSS_ADDRESS") && this.name.startsWith("gateway") && (e2 = GE("GATEWAY_WSS_ADDRESS")), OE.debug("[".concat(this.name, "] start connect, url: ").concat(e2));
            const c2 = null === (r2 = this.store) || void 0 === r2 ? void 0 : r2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "gateway" });
            this.chooseBestWebsocketConnection(e2, !!t2, c2).then((e3) => {
              var t3;
              this.websocket = e3, o2 && o2(e3.url), e3.onclose = s2, e3.onmessage = a2, null === (t3 = this.store) || void 0 === t3 || t3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, c2), this.joinChannelServiceRecordIndex = c2;
            }).catch((e3) => {
              var t3;
              if (null === (t3 = this.store) || void 0 === t3 || t3.recordJoinChannelService({ endTs: Date.now(), status: e3 instanceof SE && e3.code === fE.WS_ABORT ? "aborted" : "error", errors: [e3] }, c2), "closed" !== this.state) {
                if (e3 instanceof SE && e3.code === fE.WS_ERR) {
                  const t4 = new SE(fE.WS_ERR, "init websocket failed! Error: ".concat(e3.toString()));
                  return OE.error("[".concat(this.name, "]").concat(t4)), void n2(t4);
                }
                s2 && s2(e3);
              } else
                n2(new SE(fE.WS_DISCONNECT, "websocket is closed: ".concat(e3.toString())));
            });
          });
        }
        async reconnectWithAction(e2) {
          let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (this.reconnectCount >= this.retryConfig.maxRetryCount)
            return false;
          if (!this.urls)
            return false;
          if ("closed" === this.state)
            return false;
          this.onlineReconnectListener || Ig.networkState !== PS.OFFLINE || (this.onlineReconnectListener = Ig.onlineWaiter && Ig.onlineWaiter.then(() => {
            this.onlineReconnectListener = void 0;
          }));
          let i2 = true;
          if (this.reconnectInterrupter = () => {
            i2 = false;
          }, t2) {
            const t3 = gE(this.reconnectCount, this.retryConfig);
            OE.debug("[".concat(this.name, "] wait ").concat(t3, "ms to reconnect websocket, mode: ").concat(e2)), await Sl.race([zI(t3), this.onlineReconnectListener || new Sl(() => {
            })]);
          }
          if ("closed" === this.state || !i2)
            return false;
          this.reconnectCount += 1;
          const n2 = async (e3, t3) => {
            this.emit(Hf.RECONNECT_CREATE_CONNECTION, t3), await this.createWebSocketConnection(e3);
          };
          try {
            if ("retry" === e2) {
              const t3 = this.urls[this.currentURLIndex];
              this.emit(Hf.RECONNECT_WAITTING_FINISH, e2), await n2(t3, e2);
            } else if ("tryNext" === e2) {
              if (this.currentURLIndex += 1, this.currentURLIndex >= this.urls.length)
                return await this.reconnectWithAction("recover", false);
              OE.debug("[".concat(this.name, "] websocket url length: ").concat(this.urls.length, " current index: ").concat(this.currentURLIndex));
              const t3 = this.urls[this.currentURLIndex];
              this.emit(Hf.RECONNECT_WAITTING_FINISH, e2), await n2(t3, e2);
            } else if ("recover" === e2) {
              OE.debug("[".concat(this.name, "] request new urls")), this.resetReconnectCount("recover mode"), this.emit(Hf.RECONNECT_WAITTING_FINISH, e2), this.urls = await nC(this, Hf.REQUEST_NEW_URLS), this.currentURLIndex = 0;
              const t3 = this.urls[this.currentURLIndex];
              await n2(t3, e2);
            }
            return true;
          } catch (i3) {
            var r2;
            return OE.error("[".concat(this.name, "] reconnect failed"), i3.toString()), null != i3 && null !== (r2 = i3.data) && void 0 !== r2 && r2.desc && Array.isArray(i3.data.desc) && i3.data.desc.length && i3.data.desc.includes("dynamic key expired") ? (this.emit(Hf.ON_TOKEN_PRIVILEGE_DID_EXPIRE), false) : await this.reconnectWithAction(e2, t2);
          }
        }
        async chooseBestWebsocketConnection(e2, t2, i2) {
          return new Sl((n2, r2) => {
            let o2 = false;
            const s2 = [];
            this.closeEstablishingWs = () => {
              OE.debug("[choose-best-ws] close establishing websockets"), s2.forEach((e3) => {
                e3.onclose = null, e3.onopen = null, e3.onmessage = null, e3.close();
              }), r2(new SE(fE.WS_ABORT, "choose best websocket aborted"));
            };
            const a2 = GE("GATEWAY_DOMAINS");
            let c2;
            const d2 = e2.indexOf("?h="), u2 = a2.find((t3) => -1 !== d2 ? e2.includes(t3, d2) : e2.includes(t3));
            OE.debug("[choose-best-ws] currentDomain: ", u2, ", domains: ", a2);
            let l2 = !this.tryDoubleDomain || t2 || !u2;
            if (!l2 && u2) {
              var h2;
              const t3 = Date.now();
              try {
                a2.forEach((t4) => {
                  const i3 = -1 === d2 ? e2.replace(u2, t4) : e2.substr(0, d2) + e2.substr(d2).replace(u2, t4), n3 = new WebSocket(i3);
                  n3.binaryType = "arraybuffer", s2.push(n3), OE.debug("[choose-best-ws] ws is connecting:", n3.url);
                });
              } catch (e3) {
                for (OE.debug("[choose-best-ws] ws create failed, fallback to single url"), s2.forEach((e4) => e4.close()); s2.length; )
                  s2.pop();
                l2 = true;
              }
              null === (h2 = this.store) || void 0 === h2 || h2.recordJoinChannelService({ urls: s2.map((e3) => e3.url), service: "gateway" }, i2), s2.forEach((e3) => {
                e3.onopen = () => {
                  if (o2)
                    return;
                  const i3 = Date.now() - t3;
                  OE.debug("[choose-best-ws] ws open cost ".concat(i3, "ms")), s2.filter((t4) => t4 !== e3).forEach((e4) => {
                    OE.debug("[choose-best-ws]close backup websocket: ".concat(e4.url)), e4.close();
                  }), o2 = true, n2(e3);
                }, e3.onclose = (e4) => {
                  if (c2 = e4, o2)
                    return;
                  s2.find((e5) => !(e5.readyState === WebSocket.CLOSED || e5.readyState === WebSocket.CLOSING)) || (OE.debug("[choose-best-ws] all websocket is closed"), o2 = true, r2(c2));
                }, e3.onmessage = (t4) => {
                  OE.debug("[choose-best-ws]".concat(e3.url, " onmessage: ").concat(t4.data));
                };
              }), zI(this.forceCloseTimeout).then(() => {
                s2.forEach((e3) => {
                  e3.readyState !== WebSocket.OPEN && e3.close();
                });
              });
            }
            if (l2) {
              var p2;
              let t3;
              OE.debug("[choose-best-ws] use single url: ", e2), null === (p2 = this.store) || void 0 === p2 || p2.recordJoinChannelService({ urls: [e2], service: "gateway" }, i2);
              try {
                t3 = new WebSocket(e2), s2.push(t3), t3.binaryType = "arraybuffer";
              } catch (e3) {
                const t4 = new SE(fE.WS_ERR, "init websocket failed! Error: ".concat(e3.toString()));
                return OE.error("[".concat(this.name, "]").concat(t4)), void r2(t4);
              }
              t3.onopen = () => {
                n2(t3);
              }, t3.onclose = (e3) => {
                r2(e3);
              }, t3.onmessage = (e3) => {
                OE.debug("[choose-best-ws]".concat(t3.url, " onmessage: ").concat(e3.data));
              }, zI(this.forceCloseTimeout).then(() => {
                t3 && t3.readyState !== WebSocket.OPEN && t3.close();
              });
            }
          }).then((e3) => (this.closeEstablishingWs = void 0, e3)).catch((e3) => {
            throw this.closeEstablishingWs = void 0, e3;
          });
        }
      }
      class yC {
        constructor(e2) {
          _p(this, "input", []), _p(this, "size", void 0), this.size = e2;
        }
        add(e2) {
          this.input.push(e2), this.input.length > this.size && this.input.splice(0, 1);
        }
        mean() {
          var e2;
          return 0 === this.input.length ? 0 : zi(e2 = this.input).call(e2, (e3, t2) => e3 + t2) / this.input.length;
        }
      }
      class AC extends EE {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          e2 !== this._connectionState && (this._connectionState = e2, e2 === Of.CONNECTED ? this.emit(Nf.WS_CONNECTED) : e2 === Of.RECONNECTING ? this.emit(Nf.WS_RECONNECTING, this._websocketReconnectReason) : e2 === Of.CLOSED && this.emit(Nf.WS_CLOSED, this._disconnectedReason));
        }
        get currentURLIndex() {
          return this.websocket.currentURLIndex;
        }
        get url() {
          return this.websocket ? this.websocket.url : null;
        }
        get rtt() {
          return this.rttRolling.mean();
        }
        constructor(e2, t2) {
          super(), _p(this, "_disconnectedReason", void 0), _p(this, "_websocketReconnectReason", void 0), _p(this, "_connectionState", Of.CLOSED), _p(this, "reconnectToken", void 0), _p(this, "websocket", void 0), _p(this, "openConnectionTime", void 0), _p(this, "clientId", void 0), _p(this, "lastMsgTime", Date.now()), _p(this, "uploadCache", []), _p(this, "uploadCacheInterval", void 0), _p(this, "rttRolling", new yC(5)), _p(this, "pingpongTimer", void 0), _p(this, "wsInflateDataTimer", void 0), _p(this, "pingpongTimeoutCount", 0), _p(this, "joinResponse", void 0), _p(this, "multiIpOption", void 0), _p(this, "initError", void 0), _p(this, "spec", void 0), _p(this, "store", void 0), _p(this, "onWebsocketMessage", (e3) => {
            if (e3.data instanceof ArrayBuffer)
              return void this.emit(Nf.ON_BINARY_DATA, e3.data);
            const t3 = JSON.parse(e3.data);
            if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t3, "_id")) {
              const e4 = "res-@".concat(t3._id);
              this.emit(e4, t3._result, t3._message);
            } else if (Object.prototype.hasOwnProperty.call(t3, "_type")) {
              if (this.emit(t3._type, t3._message), t3._type === Df.ON_NOTIFICATION && this.handleNotification(t3._message), t3._type === Df.ON_USER_BANNED)
                switch (t3._message.error_code) {
                  case 14:
                    this.close(vf.UID_BANNED);
                    break;
                  case 15:
                    this.close(vf.IP_BANNED);
                    break;
                  case 16:
                    this.close(vf.CHANNEL_BANNED);
                }
              if (t3._type === Df.ON_USER_LICENSE_BANNED)
                switch (t3._message.error_code) {
                  case If.ERR_LICENSE_MISSING:
                    this.close(vf.LICENSE_MISSING);
                    break;
                  case If.ERR_LICENSE_EXPIRED:
                    this.close(vf.LICENSE_EXPIRED);
                    break;
                  case If.ERR_LICENSE_MINUTES_EXCEEDED:
                    this.close(vf.LICENSE_MINUTES_EXCEEDED);
                    break;
                  case If.ERR_LICENSE_PERIOD_INVALID:
                    this.close(vf.LICENSE_PERIOD_INVALID);
                    break;
                  case If.ERR_LICENSE_MULTIPLE_SDK_SERVICE:
                    this.close(vf.LICENSE_MULTIPLE_SDK_SERVICE);
                    break;
                  case If.ERR_LICENSE_ILLEGAL:
                    this.close(vf.LICENSE_ILLEGAL);
                    break;
                  default:
                    this.close();
                }
            }
          }), this.clientId = e2.clientId, this.spec = e2, this.store = t2, this.websocket = new vC("gateway-".concat(this.clientId), this.spec.retryConfig, true, true, t2), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
            this.connectionState === Of.CONNECTED && this.reconnect("retry", Af.OFFLINE);
          });
        }
        async request(e2, t2, i2, n2) {
          const r2 = ZI(6, ""), o2 = { _id: r2, _type: e2, _message: t2 }, s2 = this.websocket.connectionID, a2 = () => new Sl((t3, i3) => {
            if (this.connectionState === Of.CONNECTED)
              return t3();
            const n3 = () => {
              this.off(Nf.WS_CLOSED, r3), t3();
            }, r3 = () => {
              this.off(Nf.WS_CONNECTED, n3), i3(new SE(fE.WS_ABORT));
            };
            this.once(Nf.WS_CONNECTED, n3), this.once(Nf.WS_CLOSED, r3), e2 !== bf.PUBLISH && e2 !== bf.SUBSCRIBE && e2 !== bf.UNSUBSCRIBE && e2 !== bf.UNPUBLISH && e2 !== bf.CONTROL && e2 !== bf.RESTART_ICE || this.once(Nf.DISCONNECT_P2P, () => {
              i3(new SE(fE.DISCONNECT_P2P));
            }), e2 !== bf.PUBLISH && e2 !== bf.RESTART_ICE || this.once(Nf.ABORT_P2P_EXECUTION, () => {
              i3(new SE(fE.DISCONNECT_P2P));
            });
          });
          if (this.connectionState !== Of.CONNECTING && this.connectionState !== Of.RECONNECTING || e2 === bf.JOIN || e2 === bf.REJOIN || await a2(), this.websocket.sendMessage(o2, true), n2)
            return;
          const c2 = new Sl((i3, n3) => {
            let o3 = false;
            const a3 = (n4, r3) => {
              o3 = true, i3({ isSuccess: "success" === n4, message: r3 || {} }), this.off(Nf.WS_CLOSED, c3), this.off(Nf.WS_RECONNECTING, c3), this.emit(Nf.REQUEST_SUCCESS, e2, t2);
            };
            this.once("res-@".concat(r2), a3);
            const c3 = () => {
              n3(new SE(fE.WS_ABORT, "type: ".concat(e2))), this.off(Nf.WS_CLOSED, c3), this.off(Nf.WS_RECONNECTING, c3), this.off("res-@".concat(r2), a3);
            };
            this.once(Nf.WS_CLOSED, c3), this.once(Nf.WS_RECONNECTING, c3), zI(GE("SIGNAL_REQUEST_TIMEOUT")).then(() => {
              this.websocket.connectionID !== s2 || o3 || (OE.warning("[".concat(this.clientId, "] ws request timeout, type: ").concat(e2)), this.emit(Nf.REQUEST_TIMEOUT, e2, t2));
            });
          });
          let d2 = null;
          try {
            d2 = await c2;
          } catch (n3) {
            if (this.connectionState === Of.CLOSED || e2 === bf.LEAVE)
              throw new SE(fE.WS_ABORT);
            return !this.spec.forceWaitGatewayResponse || i2 ? n3.throw() : e2 === bf.JOIN || e2 === bf.REJOIN ? null : (await a2(), await this.request(e2, t2));
          }
          if (d2.isSuccess)
            return d2.message;
          const u2 = Number(d2.message.error_code || d2.message.code), l2 = IC(u2), h2 = new SE(fE.UNEXPECTED_RESPONSE, "".concat(l2.desc, ": ").concat(d2.message.error_str), { code: u2, data: d2.message });
          return "success" === l2.action ? d2.message : (OE.warning("[".concat(this.clientId, "] [").concat(this.websocket.connectionID, "] unexpected response from type ").concat(e2, ", error_code: ").concat(u2, ", message: ").concat(l2.desc, ", action: ").concat(l2.action)), u2 === If.ERR_TOO_MANY_BROADCASTERS ? e2 === bf.JOIN || e2 === bf.REJOIN ? (this.initError = h2, this.close(), h2.throw()) : h2.throw() : "failed" === l2.action ? h2.throw() : "quit" === l2.action ? (this.initError = h2, this.close(), h2.throw()) : (u2 === If.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d2.message.option, OE.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", Af.MULTI_IP)) : this.reconnect(l2.action, Af.SERVER_ERROR), e2 === bf.JOIN || e2 === bf.REJOIN ? null : await this.request(e2, t2)));
        }
        waitMessage(e2, t2) {
          return new Sl((i2) => {
            const n2 = (r2) => {
              (!t2 || t2(r2)) && (this.off(e2, n2), i2(r2));
            };
            this.on(e2, n2);
          });
        }
        upload(e2, t2) {
          const i2 = { _type: e2, _message: t2 };
          try {
            this.websocket.sendMessage(i2);
          } catch (e3) {
            const t3 = GE("MAX_UPLOAD_CACHE") || 50;
            this.uploadCache.push(i2), this.uploadCache.length > t3 && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
              if (this.connectionState !== Of.CONNECTED)
                return;
              const e4 = this.uploadCache.splice(0, 1)[0];
              0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e4._type, e4._message);
            }, GE("UPLOAD_CACHE_INTERVAL") || 2e3));
          }
        }
        send(e2, t2) {
          const i2 = { _type: e2, _message: t2 };
          this.websocket.sendMessage(i2);
        }
        init(e2, t2) {
          return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new Sl((i2, n2) => {
            this.once(Nf.WS_CONNECTED, () => i2(this.joinResponse)), this.once(Nf.WS_CLOSED, () => n2(this.initError || new SE(fE.WS_ABORT))), this.connectionState = Of.CONNECTING, this.websocket.init(e2).catch(n2), this.wsInflateDataTimer && window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = window.setInterval(() => {
              this.handleWsInflateData();
            }, 2e4), setTimeout(() => {
              t2 && void 0 === this.openConnectionTime && (OE.debug("[".concat(this.clientId, "] init websocket timeout while join with fallback to proxy")), n2(new SE(fE.INIT_WEBSOCKET_TIMEOUT)));
            }, GE("JOIN_WITH_FALLBACK_PROXY_PENDING_DURATION"));
          });
        }
        close(e2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.wsInflateDataTimer && (this.handleWsInflateData(), window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e2 || vf.LEAVE, this.connectionState = Of.CLOSED, OE.debug("[".concat(this.clientId, "] ") + "will close websocket in signal"), this.websocket.close(), e2 === vf.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new vC("gateway-".concat(this.clientId), this.spec.retryConfig, true, true, this.store), this.handleWebsocketEvents());
        }
        async join() {
          if (!this.joinResponse) {
            this.emit(Nf.ABORT_P2P_EXECUTION);
            const e2 = await nC(this, Nf.REQUEST_JOIN_INFO), t2 = await this.request(bf.JOIN, e2);
            if (!t2)
              return this.emit(Nf.REPORT_JOIN_GATEWAY, fE.TIMEOUT, this.url || ""), false;
            this.joinResponse = t2, this.emit(Nf.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
          }
          return this.connectionState = Of.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true;
        }
        async rejoin() {
          if (!this.reconnectToken)
            throw new SE(fE.UNEXPECTED_ERROR, "can not rejoin, no rejoin token");
          const e2 = sC(this, Nf.REQUEST_REJOIN_INFO);
          e2.token = this.reconnectToken;
          const t2 = await this.request(bf.REJOIN, e2);
          return !!t2 && (this.connectionState = Of.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t2.peers && t2.peers.forEach((e3) => {
            this.emit(Df.ON_USER_ONLINE, { uid: e3.uid }), e3.audio && this.emit(Df.ON_ADD_AUDIO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, audio: true, ssrcId: e3.audio_ssrc }), e3.video && this.emit(Df.ON_ADD_VIDEO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, video: true, ssrcId: e3.video_ssrc }), e3.audio_mute ? this.emit(Df.MUTE_AUDIO, { uid: e3.uid }) : this.emit(Df.UNMUTE_AUDIO, { uid: e3.uid }), e3.video_mute ? this.emit(Df.MUTE_VIDEO, { uid: e3.uid }) : this.emit(Df.UNMUTE_VIDEO, { uid: e3.uid }), e3.audio_enable_local ? this.emit(Df.ENABLE_LOCAL_AUDIO, { uid: e3.uid }) : this.emit(Df.DISABLE_LOCAL_AUDIO, { uid: e3.uid }), e3.video_enable_local ? this.emit(Df.ENABLE_LOCAL_VIDEO, { uid: e3.uid }) : this.emit(Df.DISABLE_LOCAL_VIDEO, { uid: e3.uid }), e3.audio || e3.video || this.emit(Df.ON_REMOVE_STREAM, { uid: e3.uid, uint_id: e3.uint_id });
          }), true);
        }
        reconnect(e2, t2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e2, t2);
        }
        handleNotification(e2) {
          OE.debug("[".concat(this.clientId, "] receive notification: "), e2);
          const t2 = IC(e2.code);
          if ("success" !== t2.action) {
            if ("failed" !== t2.action)
              return "quit" === t2.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t2.desc && this.close(vf.UID_BANNED), void this.close()) : void this.reconnect(t2.action, Af.SERVER_ERROR);
            OE.error("[".concat(this.clientId, "] ignore error: "), t2.desc);
          }
        }
        handlePingPong() {
          if (!this.websocket || "connected" !== this.websocket.state)
            return;
          this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
          const e2 = GE("PING_PONG_TIME_OUT"), t2 = Date.now();
          this.pingpongTimeoutCount >= e2 && (OE.warning("[".concat(this.clientId, "] PINGPONG Timeout. Last Socket Message: ").concat(t2 - this.lastMsgTime, "ms")), t2 - this.lastMsgTime > GE("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", Af.TIMEOUT) : this.request(bf.PING, void 0, true).then(() => {
            this.pingpongTimeoutCount = 0;
            const e3 = Date.now() - t2;
            this.rttRolling.add(e3), GE("REPORT_STATS") && this.send(bf.PING_BACK, { pingpongElapse: e3 });
          }).catch((e3) => {
          });
        }
        handleWsInflateData() {
          const { wsInflateLength: e2, wsDeflateLength: t2 } = this.websocket.getWsInflateData();
          0 !== e2 && 0 !== t2 && this.upload(wf.WS_INFLATE_DATA_LENGTH, { ws_deflate_length: t2, ws_inflate_length: e2 });
        }
        handleWebsocketEvents() {
          this.websocket.on(Hf.RECONNECT_WAITTING_FINISH, (e2) => {
            this.emit(Nf.WS_RECONNECT_WAITTING_FINISH, e2);
          }), this.websocket.on(Hf.RECONNECT_CREATE_CONNECTION, (e2) => {
            this.emit(Nf.WS_RECONNECT_CREATE_CONNECTION, e2);
          }), this.websocket.on(Hf.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(Hf.CLOSED, () => {
            this.connectionState = Of.CLOSED;
          }), this.websocket.on(Hf.FAILED, () => {
            this._disconnectedReason = vf.NETWORK_ERROR, this.connectionState = Of.CLOSED;
          }), this.websocket.on(Hf.RECONNECTING, (e2) => {
            this._websocketReconnectReason = e2, this.joinResponse = void 0, this.connectionState === Of.CONNECTED ? this.connectionState = Of.RECONNECTING : this.connectionState = Of.CONNECTING;
          }), this.websocket.on(Hf.WILL_RECONNECT, (e2, t2) => {
            if (sC(this, Nf.IS_P2P_DISCONNECTED) && "retry" === e2)
              return OE.debug("".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), this.reconnectToken = void 0, this.emit(Nf.NEED_RENEW_SESSION), this.emit(Nf.DISCONNECT_P2P), t2("tryNext");
            "retry" !== e2 && (OE.debug("".concat(this.clientId, " websockt will_connect event, renewSession reconnectMode is ").concat(e2)), this.reconnectToken = void 0, this.emit(Nf.NEED_RENEW_SESSION), this.emit(Nf.DISCONNECT_P2P)), t2(e2);
          }), this.websocket.on(Hf.CONNECTED, () => {
            this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch((e2) => {
              OE.warning("[".concat(this.clientId, "] rejoin failed ").concat(e2)), this.reconnect("tryNext", Af.SERVER_ERROR);
            }) : this.join().catch((e2) => {
              if (this.emit(Nf.REPORT_JOIN_GATEWAY, e2.message || e2.code, this.url || ""), e2 instanceof SE && e2.code === fE.UNEXPECTED_RESPONSE && e2.data.code === If.ERR_NO_AUTHORIZED)
                return OE.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), void this.reconnect("recover", Af.SERVER_ERROR);
              OE.error("[".concat(this.clientId, "] join gateway request failed"), e2.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", Af.SERVER_ERROR) : (this.initError = e2, this.close());
            });
          }), this.websocket.on(Hf.REQUEST_NEW_URLS, (e2, t2) => {
            nC(this, Nf.REQUEST_RECOVER, this.multiIpOption).then(e2).catch(t2);
          }), this.websocket.on(Hf.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
            this.emit(Df.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
          });
        }
      }
      function OC(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      class NC extends EE {
        get url() {
          return this._url ? this._url : null;
        }
        get reconnectMode() {
          return this._reconnectMode;
        }
        set reconnectMode(e2) {
          ["tryNext", "recover"].includes(e2) && this.resetReconnectCount(e2), this._reconnectMode = e2;
        }
        get state() {
          return this._state;
        }
        set state(e2) {
          e2 !== this._state && (this._state = e2, "reconnecting" === this._state ? this.emit(FS.RECONNECTING, this.reconnectReason) : "connected" === this._state ? this.emit(FS.CONNECTED) : "closed" === this._state ? this.emit(FS.CLOSED) : "failed" === this._state && this.emit(FS.FAILED));
        }
        constructor(e2, t2, i2, n2) {
          super(), _p(this, "connectionID", 0), _p(this, "currentURLIndex", 0), _p(this, "reconnectReason", void 0), _p(this, "_reconnectMode", "tryNext"), _p(this, "_initMutex", void 0), _p(this, "_name", void 0), _p(this, "_state", "closed"), _p(this, "_reconnectInterrupter", void 0), _p(this, "_url", void 0), _p(this, "_retryConfig", void 0), _p(this, "_reconnectCount", 0), _p(this, "_forceCloseTimeout", 5e3), _p(this, "_onlineReconnectListener", void 0), _p(this, "_closeEstablishingTransmitter", () => {
          }), _p(this, "_store", void 0), _p(this, "_joinChannelServiceRecordIndex", void 0), _p(this, "_transmitter", void 0), _p(this, "_useCompress", void 0), _p(this, "_inflateLength", 0), _p(this, "_deflateLength", 0), this._store = n2, this._name = e2, this._retryConfig = function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var i3 = null != arguments[t3] ? arguments[t3] : {};
              t3 % 2 ? OC(Object(i3), true).forEach(function(t4) {
                _p(e3, t4, i3[t4]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : OC(Object(i3)).forEach(function(t4) {
                Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
              });
            }
            return e3;
          }({}, t2), this._useCompress = i2;
        }
        resetReconnectCount(e2) {
          OE.debug("".concat(this._name, " reset reconnect count, reason: ").concat(e2)), this._reconnectCount = 0;
        }
        close(e2, t2) {
          if (this.currentURLIndex = 0, this.resetReconnectCount("close"), this._reconnectInterrupter && this._reconnectInterrupter(), this._transmitter) {
            this._transmitter.onclose = null, this._transmitter.onopen = null, this._transmitter.onmessage = null;
            const e3 = this._transmitter;
            t2 ? setTimeout(() => e3.close(), 500) : e3.close(), this._transmitter = void 0;
          }
          this.state = e2 ? "failed" : "closed", this._closeEstablishingTransmitter && this._closeEstablishingTransmitter();
        }
        reconnect(e2, t2) {
          if (!this._transmitter)
            return void OE.warning("[".concat(this._name, "] can not reconnect, no websocket"));
          var i2;
          (void 0 !== e2 && (this.reconnectMode = e2), OE.debug("[".concat(this._name, "] reconnect is triggered initiative")), "number" == typeof this._joinChannelServiceRecordIndex) && (null === (i2 = this._store) || void 0 === i2 || i2.recordJoinChannelService({ status: "error", errors: [new Error(t2)] }, this._joinChannelServiceRecordIndex));
          const n2 = this._transmitter.onclose;
          this._transmitter.onclose = null, this._transmitter.close(), n2 && n2.bind(this._transmitter)({ code: 9999, reason: t2 });
        }
        getInflateData() {
          const e2 = this._inflateLength, t2 = this._deflateLength;
          return this.clearInflateData(), { inflateLength: e2, deflateLength: t2 };
        }
        setInflateData(e2) {
          this._deflateLength = this._deflateLength + e2.originLength, this._inflateLength = this._inflateLength + e2.compressedLength;
        }
        clearInflateData() {
          this._inflateLength = 0, this._deflateLength = 0;
        }
      }
      function bC(e2, t2, i2) {
        if ("getBigUint64" in DataView.prototype)
          return e2.getBigUint64(t2, i2);
        const n2 = e2.getUint32(t2, i2), r2 = e2.getUint32(t2 + 4, i2), o2 = Number(!!i2), s2 = Number(!i2);
        return BigInt(n2 * s2 + r2 * o2) << BigInt(32) | BigInt(n2 * o2 + r2 * s2);
      }
      function wC(e2, t2, i2, n2) {
        if ("setBigUint64" in DataView.prototype)
          return e2.setBigUint64(t2, i2, n2);
        const r2 = Number(i2 >> BigInt(32)), o2 = Number(i2 & BigInt(4294967295));
        n2 ? (e2.setUint32(t2 + 4, r2, n2), e2.setUint32(t2, o2, n2)) : (e2.setUint32(t2, r2, n2), e2.setUint32(t2 + 4, o2, n2));
      }
      let DC;
      !function(e2) {
        e2[e2.Default = 0] = "Default", e2[e2.Ack = 1] = "Ack";
      }(DC || (DC = {}));
      class PC {
        constructor(e2, t2, i2) {
          _p(this, "version", 1), _p(this, "initialRTO", void 0), _p(this, "maxBatchAckCount", void 0), _p(this, "maxRTO", void 0), _p(this, "initialRTT", void 0), _p(this, "ID", void 0), _p(this, "rtt", void 0), _p(this, "packetNumber", 1), _p(this, "rtoRatioMap", /* @__PURE__ */ new Map()), _p(this, "timeoutMap", /* @__PURE__ */ new Map()), _p(this, "unorderedPacketQueue", []), _p(this, "batchAckPacketQueue", []), _p(this, "lastOrderedPacketNumber", 0), _p(this, "batchAckTimer", void 0), _p(this, "sendImpl", void 0), _p(this, "receiveImpl", void 0), this.sendImpl = e2, this.receiveImpl = t2, this.ID = ZI(7, "transmitter-"), this.initialRTO = void 0 !== (null == i2 ? void 0 : i2.initialRTO) ? i2.initialRTO : GE("TRANSMITTER_INITIAL_RTO"), this.initialRTT = void 0 !== (null == i2 ? void 0 : i2.initialRTT) ? i2.initialRTT : GE("TRANSMITTER_INITIAL_RTT"), this.rtt = void 0 !== (null == i2 ? void 0 : i2.initialRTT) ? i2.initialRTT : GE("TRANSMITTER_INITIAL_RTT"), this.maxBatchAckCount = void 0 !== (null == i2 ? void 0 : i2.maxBatchAckCount) ? i2.maxBatchAckCount : GE("TRANSMITTER_MAX_BATCH_ACK_COUNT"), this.maxRTO = void 0 !== (null == i2 ? void 0 : i2.maxRTO) ? i2.maxRTO : GE("TRANSMITTER_MAX_RTO");
        }
        packetize(e2, t2) {
          return { type: DC.Default, version: this.version, packetNumber: t2, payload: e2 };
        }
        serialize(e2) {
          switch (e2.type) {
            case DC.Default: {
              let t2;
              if ("string" == typeof e2.payload) {
                t2 = new TextEncoder().encode(e2.payload);
              } else
                t2 = e2.payload;
              const i2 = new ArrayBuffer(t2.length + 15), n2 = new DataView(i2);
              n2.setUint16(0, e2.version), n2.setUint8(2, e2.type), n2.setUint32(3, e2.packetNumber), wC(n2, 7, BigInt(e2.sendTs));
              return new Uint8Array(n2.buffer).set(t2, 15), i2;
            }
            case DC.Ack: {
              const t2 = new ArrayBuffer(16), i2 = new DataView(t2);
              return i2.setUint16(0, e2.version), i2.setUint8(2, e2.type), i2.setUint32(3, e2.maxAckPacketNumber), i2.setUint8(7, e2.shift), wC(i2, 8, BigInt(e2.ackSendTs)), t2;
            }
          }
        }
        deserialize(e2) {
          const t2 = new DataView(e2), i2 = t2.getUint16(0), n2 = t2.getUint8(2);
          switch (n2) {
            case DC.Default: {
              const r2 = t2.getUint32(3), o2 = bC(t2, 7), s2 = e2.slice(15), a2 = new TextDecoder().decode(s2);
              return { version: i2, type: n2, packetNumber: r2, sendTs: Number(o2), payload: a2 };
            }
            case DC.Ack: {
              const e3 = t2.getUint32(3), r2 = t2.getUint8(7), o2 = bC(t2, 8);
              return { version: i2, type: n2, maxAckPacketNumber: e3, shift: r2, ackSendTs: Number(o2) };
            }
            default:
              throw OE.error("[".concat(this.ID, "] Unrecognized packet type ").concat(n2)), new Error("Unrecognized packet type ".concat(n2));
          }
        }
        sendMessage(e2) {
          const t2 = this.packetize(e2, this.packetNumber);
          this.packetNumber = 4294967295 === this.packetNumber ? 1 : this.packetNumber + 1;
          const i2 = this.calculateRTO(t2), n2 = window.setTimeout(() => {
            this.resendMessage(t2);
          }, i2);
          this.timeoutMap.set(t2.packetNumber, n2), this.sendPacket(t2);
        }
        onData(e2) {
          const t2 = this.deserialize(e2);
          t2.type === DC.Default ? this.ack(t2) : t2.type === DC.Ack && (this.updateRTT(t2, Math.round(performance.now())), this.clearRTO(t2));
        }
        close() {
          this.rtt = this.initialRTT, this.packetNumber = 1, Array.from(this.timeoutMap.entries()).forEach((e2) => {
            let [t2, i2] = e2;
            window.clearTimeout(i2);
          }), this.timeoutMap = /* @__PURE__ */ new Map(), this.rtoRatioMap = /* @__PURE__ */ new Map(), this.unorderedPacketQueue = [], this.batchAckPacketQueue = [], this.lastOrderedPacketNumber = 0, void 0 !== this.batchAckTimer && window.clearTimeout(this.batchAckTimer);
        }
        resendMessage(e2) {
          const t2 = this.calculateRTO(e2), i2 = window.setTimeout(() => {
            this.resendMessage(e2);
          }, t2);
          this.timeoutMap.set(e2.packetNumber, i2), this.sendPacket(e2);
        }
        calculateRTO(e2) {
          const t2 = this.rtoRatioMap.get(e2.packetNumber);
          if (void 0 === t2)
            return this.rtoRatioMap.set(e2.packetNumber, 1), this.initialRTO;
          {
            const i2 = 9 * this.rtt / 8 * t2;
            return this.rtoRatioMap.set(e2.packetNumber, t2 + 1), i2 > this.maxRTO ? this.maxRTO : i2;
          }
        }
        updateRTT(e2, t2) {
          const i2 = e2.ackSendTs;
          this.rtt = this.rtt * (7 / 8) + (t2 - i2 - this.rtt) / 8;
        }
        ack(e2) {
          if (e2.packetNumber === this.lastOrderedPacketNumber + 1)
            for (this.batchAckPacketQueue.length >= this.maxBatchAckCount && this.batchAck(), this.batchAckTimer ? this.batchAckPacketQueue.push(e2) : (this.batchAckPacketQueue.push(e2), this.batchAckTimer = window.setTimeout(() => {
              this.batchAck();
            }, this.rtt / 8)), this.lastOrderedPacketNumber += 1, this.receiveImpl(e2.payload); ; ) {
              const e3 = this.unorderedPacketQueue[0];
              if (!e3) {
                this.unorderedPacketQueue.shift();
                break;
              }
              this.batchAckTimer && this.batchAck(), this.receiveImpl(e3.payload), this.unorderedPacketQueue.shift(), this.lastOrderedPacketNumber += 1;
            }
          else if (e2.packetNumber <= this.lastOrderedPacketNumber) {
            const t2 = { ackSendTs: e2.sendTs, maxAckPacketNumber: e2.packetNumber, shift: 0, type: DC.Ack, version: this.version };
            this.sendPacket(t2);
          } else if (e2.packetNumber > this.lastOrderedPacketNumber) {
            this.unorderedPacketQueue[e2.packetNumber - this.lastOrderedPacketNumber - 2] = e2;
            const t2 = { ackSendTs: e2.sendTs, maxAckPacketNumber: e2.packetNumber, shift: 0, type: DC.Ack, version: this.version };
            this.sendPacket(t2);
          }
        }
        batchAck() {
          window.clearTimeout(this.batchAckTimer), this.batchAckTimer = void 0;
          const e2 = { ackSendTs: this.batchAckPacketQueue[this.batchAckPacketQueue.length - 1].sendTs, maxAckPacketNumber: this.batchAckPacketQueue[this.batchAckPacketQueue.length - 1].packetNumber, shift: this.batchAckPacketQueue.length - 1, type: DC.Ack, version: this.version };
          this.sendPacket(e2), this.batchAckPacketQueue = [];
        }
        sendPacket(e2) {
          e2.type === DC.Default && (e2.sendTs = Math.round(performance.now()));
          const t2 = this.serialize(e2);
          this.sendImpl(t2);
        }
        clearRTO(e2) {
          for (let t2 = e2.maxAckPacketNumber - e2.shift; t2 <= e2.maxAckPacketNumber; t2++) {
            const e3 = this.timeoutMap.get(t2);
            void 0 !== e3 && window.clearTimeout(e3), this.timeoutMap.delete(t2), this.rtoRatioMap.delete(t2);
          }
        }
      }
      class LC extends NC {
        constructor(e2, t2) {
          super(e2, t2, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 ? arguments[3] : void 0), _p(this, "_initMutex", void 0), _p(this, "_reconnectInterrupter", void 0), _p(this, "_url", void 0), _p(this, "_transmitter", void 0), _p(this, "_addresses", void 0), _p(this, "_reliableTransmission", void 0), this._initMutex = new Ug("datachannel");
          const { timeout: i2, timeoutFactor: n2 } = t2, r2 = Math.max(300, Math.floor(3 * i2 / 5)), o2 = Math.max(1.2, Math.floor(8 * n2) / 10);
          PS.ONLINE && (this._retryConfig.timeout = r2, this._retryConfig.timeoutFactor = o2), Ig.on(LS.NETWORK_STATE_CHANGE, (e3, t3) => {
            e3 !== t3 && (this.resetReconnectCount("network state change: ".concat(t3, " -> ").concat(e3)), e3 === PS.ONLINE ? (this._retryConfig.timeout = r2, this._retryConfig.timeoutFactor = o2) : (this._retryConfig.timeout = i2, this._retryConfig.timeoutFactor = n2));
          });
        }
        getConnection() {
          if (this._reliableTransmission)
            return this._reliableTransmission;
        }
        async init(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
          this._forceCloseTimeout = t2;
          const i2 = (t3, i3) => {
            this._addresses = e2, this.currentURLIndex = this._addresses.findIndex((e3) => e3.fingerprint || GE("FINGERPRINT"));
            const n2 = this._addresses[this.currentURLIndex];
            this.state = "connecting", this.createTransmitterConnection(n2).then(t3).catch(i3), this.once(FS.CLOSED, () => i3(new SE(fE.WS_DISCONNECT))), this.once(FS.CONNECTED, () => t3());
          };
          return this._initMutex.lock().then((e3) => new Sl((e4, t3) => {
            i2(e4, t3);
          }).then(() => {
            e3();
          }).catch(() => {
            e3();
          }));
        }
        sendMessage(e2) {
          let t2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          if (!this._transmitter || !this._reliableTransmission)
            throw new SE(fE.WS_ABORT, "datachannel is not ready");
          try {
            t2 || (e2 = JSON.stringify(e2)), this._reliableTransmission.sendMessage(e2);
          } catch (e3) {
            throw new SE(fE.WS_ERR, "send datachannel signal message error" + e3.toString());
          }
        }
        unbindDcCloseEventListener() {
          this._transmitter && (this._transmitter.onclose = null);
        }
        sendMessageWithJSON(e2) {
          const t2 = JSON.stringify(e2);
          return { compressed: t2, compressedLength: t2.length, origin: e2 };
        }
        sendMessageWithUint8Array(e2) {
          return { compressed: e2, compressedLength: e2.byteLength, origin: e2 };
        }
        createTransmitterConnection(e2) {
          return this.connectionID += 1, this._joinChannelServiceRecordIndex = void 0, this._url = "dc://".concat(e2.ip, ":").concat(e2.port), new Sl((t2, i2) => {
            var n2;
            const r2 = () => {
              OE.debug("[".concat(this._name, "] datachannel opened:"), this._url), this.reconnectMode = "retry", this.state = "connected", this.resetReconnectCount("opened"), t2();
            }, o2 = async (e3) => {
              var n3;
              if (null === (n3 = this._closeEstablishingTransmitter) || void 0 === n3 || n3.call(this), OE.debug("[".concat(this._name, "] datachannel close ").concat(this._url, ", code: ").concat(e3.code, ", reason: ").concat(e3.reason, ", current mode: ").concat(this.reconnectMode)), this._reconnectCount < this._retryConfig.maxRetryCount) {
                "connected" === this.state && (this.reconnectReason = e3.reason, this.state = "reconnecting");
                const n4 = oC(this, FS.WILL_RECONNECT, this.reconnectMode) || this.reconnectMode, r3 = await this.reconnectWithAction(n4);
                if ("closed" === this.state)
                  return void OE.debug("[".concat(this.connectionID, "] dc is closed, no need to reconnect"));
                if (!r3)
                  return i2(new SE(fE.WS_DISCONNECT, "datachannel reconnect failed: ".concat(e3.code))), void this.close(true);
                t2();
              } else
                i2(new SE(fE.WS_DISCONNECT, "datachannel close: ".concat(e3.code))), this.close();
            }, s2 = (e3) => {
              var t3;
              null === (t3 = this._reliableTransmission) || void 0 === t3 || t3.onData(e3.data);
            };
            this._transmitter && (this._transmitter.onclose = null, this._transmitter.close()), this._reliableTransmission && (this._reliableTransmission.close(), this._reliableTransmission = void 0), OE.debug("[".concat(this._name, "] start connect, address: ").concat(JSON.stringify(e2)));
            const a2 = null === (n2 = this._store) || void 0 === n2 ? void 0 : n2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "gateway" }), c2 = Date.now();
            nC(this, FS.TO_CONNECT_DATACHANNEL, e2).then((e3) => {
              var t3, i3;
              if (!e3)
                throw new Error("transmissonInfo not exist yet");
              const { transmitter: n3, close: d2 } = e3;
              this._transmitter = n3, null === (t3 = this._store) || void 0 === t3 || t3.signalChannelOpen();
              const u2 = Date.now() - c2;
              OE.debug("[choose dc] dc open cost ".concat(u2, "ms"));
              this._reliableTransmission = new PC((e4) => {
                var t4;
                this._transmitter && "open" === this._transmitter.readyState && (null === (t4 = this._transmitter) || void 0 === t4 || t4.send(e4));
              }, (e4) => {
                "string" == typeof e4 && this.emit(FS.ON_MESSAGE, e4);
              }), this._closeEstablishingTransmitter = () => {
                var e4;
                null === (e4 = this._reliableTransmission) || void 0 === e4 || e4.close(), this._reliableTransmission = void 0, d2();
              }, r2 && r2(), n3.onclose = o2, n3.onmessage = s2, null === (i3 = this._store) || void 0 === i3 || i3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a2), this._joinChannelServiceRecordIndex = a2;
            }).catch((e3) => {
              var t3;
              if (null === (t3 = this._store) || void 0 === t3 || t3.recordJoinChannelService({ endTs: Date.now(), status: e3 instanceof SE && e3.code === fE.WS_ABORT ? "aborted" : "error", errors: [e3] }, a2), "closed" !== this.state) {
                if (e3 instanceof SE && e3.code === fE.WS_ERR) {
                  const t4 = new SE(fE.WS_ERR, "init datachannel failed! Error: ".concat(e3.toString()));
                  return OE.error("[".concat(this._name, "]").concat(t4)), void i2(t4);
                }
                o2 && o2(e3);
              } else
                i2(new SE(fE.WS_DISCONNECT, "datachannel is closed: ".concat(e3.toString())));
            });
          });
        }
        async reconnectWithAction(e2) {
          let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (this._reconnectCount >= this._retryConfig.maxRetryCount)
            return false;
          if (!this._addresses)
            return false;
          if ("closed" === this.state)
            return false;
          this._onlineReconnectListener || Ig.networkState !== PS.OFFLINE || (this._onlineReconnectListener = Ig.onlineWaiter && Ig.onlineWaiter.then(() => {
            this._onlineReconnectListener = void 0;
          }));
          let i2 = true;
          if (this._reconnectInterrupter = () => {
            i2 = false;
          }, t2) {
            const t3 = gE(this._reconnectCount, this._retryConfig);
            OE.debug("[".concat(this._name, "] wait ").concat(t3, "ms to reconnect datachannel, mode: ").concat(e2)), await Sl.race([zI(t3), this._onlineReconnectListener || new Sl(() => {
            })]);
          }
          if ("closed" === this.state || !i2)
            return false;
          this._reconnectCount += 1;
          const n2 = async (e3, t3) => {
            this.emit(FS.RECONNECT_CREATE_CONNECTION, t3), await this.createTransmitterConnection(e3);
          };
          try {
            if ("retry" === e2) {
              const t3 = this._addresses[this.currentURLIndex];
              this.emit(FS.RECONNECT_WAITTING_FINISH, e2), await n2(t3, e2);
            } else if ("tryNext" === e2) {
              this.currentURLIndex += 1;
              for (let e3 = this.currentURLIndex; e3 < this._addresses.length; e3++) {
                if (this._addresses[e3].fingerprint || GE("FINGERPRINT")) {
                  this.currentURLIndex = e3;
                  break;
                }
                this.currentURLIndex += 1;
              }
              if (this.currentURLIndex >= this._addresses.length)
                return OE.debug("[".concat(this._name, "] the available addresses are exhausted, change to recover")), await this.reconnectWithAction("recover", false);
              OE.debug("[".concat(this._name, "] datachannel url length: ").concat(this._addresses.length, " current index: ").concat(this.currentURLIndex));
              const t3 = this._addresses[this.currentURLIndex];
              this.emit(FS.RECONNECT_WAITTING_FINISH, e2), await n2(t3, e2);
            } else
              "recover" === e2 && (OE.debug("[".concat(this._name, "] start to failback to websocket")), this.resetReconnectCount("recover mode"), this.emit(FS.RECONNECT_WAITTING_FINISH, e2), this.emit(FS.FAILBACK));
            return true;
          } catch (i3) {
            var r2;
            return OE.error("[".concat(this._name, "] reconnect failed"), i3.toString()), null != i3 && null !== (r2 = i3.data) && void 0 !== r2 && r2.desc && Array.isArray(i3.data.desc) && i3.data.desc.length && i3.data.desc.includes("dynamic key expired") ? (this.emit(FS.ON_TOKEN_PRIVILEGE_DID_EXPIRE), false) : await this.reconnectWithAction(e2, t2);
          }
        }
      }
      class kC extends EE {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          e2 !== this._connectionState && (this._connectionState = e2, e2 === Of.CONNECTED ? this.emit(Nf.WS_CONNECTED) : e2 === Of.RECONNECTING ? this.emit(Nf.WS_RECONNECTING, this._websocketReconnectReason) : e2 === Of.CLOSED && this.emit(Nf.WS_CLOSED, this._disconnectedReason));
        }
        get currentURLIndex() {
          return this.websocket.currentURLIndex;
        }
        get url() {
          return this.websocket ? this.websocket.url : null;
        }
        get rtt() {
          return this.rttRolling.mean();
        }
        constructor(e2, t2) {
          super(), _p(this, "_disconnectedReason", void 0), _p(this, "_websocketReconnectReason", void 0), _p(this, "_connectionState", Of.CLOSED), _p(this, "reconnectToken", void 0), _p(this, "websocket", void 0), _p(this, "openConnectionTime", void 0), _p(this, "clientId", void 0), _p(this, "lastMsgTime", Date.now()), _p(this, "uploadCache", []), _p(this, "uploadCacheInterval", void 0), _p(this, "rttRolling", new yC(5)), _p(this, "pingpongTimer", void 0), _p(this, "inflateDataTimer", void 0), _p(this, "pingpongTimeoutCount", 0), _p(this, "joinResponse", void 0), _p(this, "multiIpOption", void 0), _p(this, "initError", void 0), _p(this, "spec", void 0), _p(this, "store", void 0), _p(this, "onWebsocketMessage", (e3) => {
            if (e3 instanceof ArrayBuffer)
              return void this.emit(Nf.ON_BINARY_DATA, e3);
            const t3 = JSON.parse(e3);
            if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t3, "_id")) {
              const e4 = "res-@".concat(t3._id);
              this.emit(e4, t3._result, t3._message);
            } else if (Object.prototype.hasOwnProperty.call(t3, "_type") && (this.emit(t3._type, t3._message), t3._type === Df.ON_NOTIFICATION && this.handleNotification(t3._message), t3._type === Df.ON_USER_BANNED))
              switch (t3._message.error_code) {
                case 14:
                  this.close(vf.UID_BANNED);
                  break;
                case 15:
                  this.close(vf.IP_BANNED);
                  break;
                case 16:
                  this.close(vf.CHANNEL_BANNED);
              }
          }), this.clientId = e2.clientId, this.spec = e2, this.store = t2, this.websocket = new LC("gateway-".concat(this.clientId), this.spec.retryConfig, true, t2), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
            this.connectionState === Of.CONNECTED && this.reconnect("retry", jS.OFFLINE);
          });
        }
        async request(e2, t2, i2, n2) {
          const r2 = ZI(6, ""), o2 = { _id: r2, _type: e2, _message: t2 }, s2 = this.websocket.connectionID, a2 = () => new Sl((t3, i3) => {
            if (this.connectionState === Of.CONNECTED)
              return t3();
            const n3 = () => {
              this.off(Nf.WS_CLOSED, r3), t3();
            }, r3 = () => {
              this.off(Nf.WS_CONNECTED, n3), i3(new SE(fE.WS_ABORT));
            };
            this.once(Nf.WS_CONNECTED, n3), this.once(Nf.WS_CLOSED, r3), e2 !== bf.PUBLISH && e2 !== bf.SUBSCRIBE && e2 !== bf.UNSUBSCRIBE && e2 !== bf.UNPUBLISH && e2 !== bf.CONTROL && e2 !== bf.RESTART_ICE || this.once(Nf.DISCONNECT_P2P, () => {
              i3(new SE(fE.DISCONNECT_P2P));
            }), e2 !== bf.PUBLISH && e2 !== bf.RESTART_ICE || this.once(Nf.ABORT_P2P_EXECUTION, () => {
              i3(new SE(fE.DISCONNECT_P2P));
            });
          });
          if (this.connectionState !== Of.CONNECTING && this.connectionState !== Of.RECONNECTING || e2 === bf.JOIN || e2 === bf.REJOIN || await a2(), e2 === bf.LEAVE && (this.websocket.unbindDcCloseEventListener(), n2 = true), this.websocket.sendMessage(o2, true, false), n2)
            return;
          const c2 = new Sl((i3, n3) => {
            let o3 = false;
            const a3 = (n4, r3) => {
              o3 = true, i3({ isSuccess: "success" === n4, message: r3 || {} }), this.off(Nf.WS_CLOSED, c3), this.off(Nf.WS_RECONNECTING, c3), this.emit(Nf.REQUEST_SUCCESS, e2, t2);
            };
            this.once("res-@".concat(r2), a3);
            const c3 = () => {
              n3(new SE(fE.WS_ABORT, "type: ".concat(e2))), this.off(Nf.WS_CLOSED, c3), this.off(Nf.WS_RECONNECTING, c3), this.off("res-@".concat(r2), a3);
            };
            this.once(Nf.WS_CLOSED, c3), this.once(Nf.WS_RECONNECTING, c3), zI(GE("SIGNAL_REQUEST_TIMEOUT")).then(() => {
              this.websocket.connectionID !== s2 || o3 || (OE.warning("dc request timeout, type: ".concat(e2)), this.emit(Nf.REQUEST_TIMEOUT, e2, t2));
            });
          });
          let d2 = null;
          try {
            d2 = await c2;
          } catch (n3) {
            if (this.connectionState === Of.CLOSED || e2 === bf.LEAVE)
              throw new SE(fE.WS_ABORT);
            return !this.spec.forceWaitGatewayResponse || i2 ? n3.throw() : e2 === bf.JOIN || e2 === bf.REJOIN ? null : (await a2(), await this.request(e2, t2));
          }
          if (d2.isSuccess)
            return d2.message;
          const u2 = Number(d2.message.error_code || d2.message.code), l2 = IC(u2), h2 = new SE(fE.UNEXPECTED_RESPONSE, "".concat(l2.desc, ": ").concat(d2.message.error_str), { code: u2, data: d2.message });
          return "success" === l2.action ? d2.message : (OE.warning("[".concat(this.websocket.connectionID, "] unexpected response from type ").concat(e2, ", error_code: ").concat(u2, ", message: ").concat(l2.desc, ", action: ").concat(l2.action)), u2 === If.ERR_TOO_MANY_BROADCASTERS ? e2 === bf.JOIN || e2 === bf.REJOIN ? (this.initError = h2, this.close(), h2.throw()) : h2.throw() : "failed" === l2.action ? h2.throw() : "quit" === l2.action ? (this.initError = h2, this.close(), h2.throw()) : (u2 === If.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d2.message.option, OE.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", jS.MULTI_IP)) : this.reconnect(l2.action, jS.SERVER_ERROR), e2 === bf.JOIN || e2 === bf.REJOIN ? null : await this.request(e2, t2)));
        }
        waitMessage(e2, t2) {
          return new Sl((i2) => {
            const n2 = (r2) => {
              (!t2 || t2(r2)) && (this.off(e2, n2), i2(r2));
            };
            this.on(e2, n2);
          });
        }
        upload(e2, t2) {
          const i2 = { _type: e2, _message: t2 };
          try {
            this.websocket.sendMessage(i2);
          } catch (e3) {
            const t3 = GE("MAX_UPLOAD_CACHE") || 50;
            this.uploadCache.push(i2), this.uploadCache.length > t3 && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
              if (this.connectionState !== Of.CONNECTED)
                return;
              const e4 = this.uploadCache.splice(0, 1)[0];
              0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e4._type, e4._message);
            }, GE("UPLOAD_CACHE_INTERVAL") || 2e3));
          }
        }
        send(e2, t2) {
          const i2 = { _type: e2, _message: t2 };
          this.websocket.sendMessage(i2);
        }
        init(e2, t2) {
          return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new Sl((i2, n2) => {
            this.once(Nf.WS_CONNECTED, () => i2(this.joinResponse)), this.once(Nf.WS_CLOSED, () => n2(this.initError || new SE(fE.WS_ABORT))), this.connectionState = Of.CONNECTING, this.websocket.init(e2).catch(n2), this.websocket.once(FS.FAILBACK, () => {
              void 0 === this.openConnectionTime && n2(new SE(fE.INIT_DATACHANNEL_TIMEOUT));
            }), this.inflateDataTimer && window.clearInterval(this.inflateDataTimer), this.inflateDataTimer = window.setInterval(() => {
              this.handleInflateData();
            }, 2e4), setTimeout(() => {
              t2 && void 0 === this.openConnectionTime && (OE.debug("[".concat(this.clientId, "] init datachannel timeout while join with failback to websocket")), n2(new SE(fE.INIT_DATACHANNEL_TIMEOUT)));
            }, GE("DC_JOIN_WITH_FAILBACK"));
          });
        }
        close(e2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.inflateDataTimer && (this.handleInflateData(), window.clearInterval(this.inflateDataTimer), this.inflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e2 || vf.LEAVE, this.connectionState = Of.CLOSED, OE.debug("[".concat(this.clientId, "] ") + "will close datachannel in signal"), this.websocket.close(), e2 === vf.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new LC("gateway-".concat(this.clientId), this.spec.retryConfig, true, this.store), this.handleWebsocketEvents());
        }
        async join() {
          if (!this.joinResponse) {
            this.emit(Nf.ABORT_P2P_EXECUTION);
            const e2 = await nC(this, Nf.DATACHANNEL_CONNECTING), t2 = await this.request(bf.JOIN, e2);
            if (!t2)
              return this.emit(Nf.REPORT_JOIN_GATEWAY, fE.TIMEOUT, this.url || ""), false;
            this.joinResponse = t2, this.emit(Nf.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
          }
          return this.connectionState = Of.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true;
        }
        async rejoin() {
          if (!this.reconnectToken)
            throw new SE(fE.UNEXPECTED_ERROR, "can not rejoin, no rejoin token");
          const e2 = sC(this, Nf.REQUEST_REJOIN_INFO);
          e2.token = this.reconnectToken;
          const t2 = await this.request(bf.REJOIN, e2);
          return !!t2 && (this.connectionState = Of.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t2.peers && t2.peers.forEach((e3) => {
            this.emit(Df.ON_USER_ONLINE, { uid: e3.uid }), e3.audio && this.emit(Df.ON_ADD_AUDIO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, audio: true, ssrcId: e3.audio_ssrc }), e3.video && this.emit(Df.ON_ADD_VIDEO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, video: true, ssrcId: e3.video_ssrc }), e3.audio_mute ? this.emit(Df.MUTE_AUDIO, { uid: e3.uid }) : this.emit(Df.UNMUTE_AUDIO, { uid: e3.uid }), e3.video_mute ? this.emit(Df.MUTE_VIDEO, { uid: e3.uid }) : this.emit(Df.UNMUTE_VIDEO, { uid: e3.uid }), e3.audio_enable_local ? this.emit(Df.ENABLE_LOCAL_AUDIO, { uid: e3.uid }) : this.emit(Df.DISABLE_LOCAL_AUDIO, { uid: e3.uid }), e3.video_enable_local ? this.emit(Df.ENABLE_LOCAL_VIDEO, { uid: e3.uid }) : this.emit(Df.DISABLE_LOCAL_VIDEO, { uid: e3.uid }), e3.audio || e3.video || this.emit(Df.ON_REMOVE_STREAM, { uid: e3.uid, uint_id: e3.uint_id });
          }), true);
        }
        reconnect(e2, t2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e2, t2);
        }
        handleNotification(e2) {
          OE.debug("[".concat(this.clientId, "] receive notification: "), e2);
          const t2 = IC(e2.code);
          if ("success" !== t2.action) {
            if ("failed" !== t2.action)
              return "quit" === t2.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t2.desc && this.close(vf.UID_BANNED), void this.close()) : void this.reconnect(t2.action, jS.SERVER_ERROR);
            OE.error("[".concat(this.clientId, "] ignore error: "), t2.desc);
          }
        }
        handlePingPong() {
          if (!this.websocket || "connected" !== this.websocket.state)
            return;
          this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
          const e2 = GE("PING_PONG_TIME_OUT"), t2 = Date.now();
          this.pingpongTimeoutCount >= e2 && (OE.warning("PINGPONG Timeout. Last Socket Message: ".concat(t2 - this.lastMsgTime, "ms")), t2 - this.lastMsgTime > GE("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", jS.TIMEOUT) : this.request(bf.PING, void 0, true).then(() => {
            this.pingpongTimeoutCount = 0;
            const e3 = Date.now() - t2;
            this.rttRolling.add(e3), GE("REPORT_STATS") && this.send(bf.PING_BACK, { pingpongElapse: e3 });
          }).catch((e3) => {
          });
        }
        handleInflateData() {
          const { inflateLength: e2, deflateLength: t2 } = this.websocket.getInflateData();
          0 !== e2 && 0 !== t2 && this.upload(wf.WS_INFLATE_DATA_LENGTH, { ws_deflate_length: t2, ws_inflate_length: e2 });
        }
        handleWebsocketEvents() {
          this.websocket.on(FS.RECONNECT_WAITTING_FINISH, (e2) => {
            this.emit(Nf.WS_RECONNECT_WAITTING_FINISH, e2);
          }), this.websocket.on(FS.RECONNECT_CREATE_CONNECTION, (e2) => {
            this.emit(Nf.WS_RECONNECT_CREATE_CONNECTION, e2);
          }), this.websocket.on(FS.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(FS.CLOSED, () => {
            this.connectionState = Of.CLOSED;
          }), this.websocket.on(FS.FAILED, () => {
            this._disconnectedReason = vf.NETWORK_ERROR, this.connectionState = Of.CLOSED;
          }), this.websocket.on(FS.RECONNECTING, (e2) => {
            this._websocketReconnectReason = e2, this.joinResponse = void 0, this.connectionState === Of.CONNECTED ? this.connectionState = Of.RECONNECTING : this.connectionState = Of.CONNECTING;
          }), this.websocket.on(FS.WILL_RECONNECT, (e2, t2) => {
            if (sC(this, Nf.IS_P2P_DISCONNECTED) && "retry" === e2)
              return OE.debug("".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), this.reconnectToken = void 0, this.emit(Nf.NEED_RENEW_SESSION), this.emit(Nf.DISCONNECT_P2P), t2("tryNext");
            "retry" !== e2 && (OE.debug("".concat(this.clientId, " websockt will_connect event, renewSession reconnectMode is ").concat(e2)), this.reconnectToken = void 0, this.emit(Nf.NEED_RENEW_SESSION), this.emit(Nf.DISCONNECT_P2P)), t2(e2);
          }), this.websocket.on(FS.CONNECTED, () => {
            this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch((e2) => {
              OE.warning("[".concat(this.clientId, "] rejoin failed ").concat(e2)), this.reconnect("tryNext", jS.SERVER_ERROR);
            }) : this.join().catch((e2) => {
              if (this.emit(Nf.REPORT_JOIN_GATEWAY, e2.message || e2.code, this.url || ""), e2 instanceof SE && e2.code === fE.UNEXPECTED_RESPONSE && e2.data.code === If.ERR_NO_AUTHORIZED)
                return OE.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), void this.reconnect("recover", jS.SERVER_ERROR);
              OE.error("[".concat(this.clientId, "] join gateway request failed"), e2.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", jS.SERVER_ERROR) : (this.initError = e2, this.close());
            });
          }), this.websocket.on(FS.REQUEST_NEW_URLS, (e2, t2) => {
            nC(this, Nf.REQUEST_RECOVER, this.multiIpOption).then(e2).catch(t2);
          }), this.websocket.on(FS.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
            this.emit(Df.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
          }), this.websocket.on(FS.TO_CONNECT_DATACHANNEL, async (e2, t2, i2) => nC(this, Nf.DATACHANNEL_PRECONNECT, e2).then(t2).catch(i2)), this.websocket.on(FS.FAILBACK, () => {
            void 0 !== this.openConnectionTime && this.emit(Nf.DATACHANNEL_FAILBACK);
          });
        }
      }
      function MC(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function UC(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? MC(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : MC(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      const xC = /* @__PURE__ */ new Map();
      class VC extends EE {
        get state() {
          return this._state;
        }
        set state(e2) {
          if (e2 === this._state)
            return;
          const t2 = this._state;
          this._state = e2, "DISCONNECTED" === e2 && this._disconnectedReason ? this.emit(aS.CONNECTION_STATE_CHANGE, e2, t2, this._disconnectedReason) : this.emit(aS.CONNECTION_STATE_CHANGE, e2, t2);
        }
        get joinGatewayStartTime() {
          return this._joinGatewayStartTime;
        }
        set joinGatewayStartTime(e2) {
          OE.debug("[".concat(this.store.clientId, "] set joinGatewayStartTime at ").concat(e2)), this._joinGatewayStartTime = e2;
        }
        constructor(e2, t2) {
          super(), _p(this, "store", void 0), _p(this, "joinInfo", void 0), _p(this, "key", void 0), _p(this, "signal", void 0), _p(this, "role", void 0), _p(this, "inChannelInfo", { joinAt: null, duration: 0 }), _p(this, "spec", void 0), _p(this, "_state", "DISCONNECTED"), _p(this, "_statsCollector", void 0), _p(this, "_disconnectedReason", void 0), _p(this, "isSignalRecover", false), _p(this, "hasChangeBGPAddress", false), _p(this, "trafficStatsInterval", void 0), _p(this, "networkQualityInterval", void 0), _p(this, "_joinGatewayStartTime", 0), _p(this, "_signalTimeout", false), _p(this, "_clientRoleOptions", void 0), _p(this, "_isProactiveJoin", false), this.store = e2, this.spec = t2, this.signal = this.store.useDataChannel ? new kC(UC(UC({}, t2), {}, { retryConfig: t2.websocketRetryConfig }), e2) : new AC(UC(UC({}, t2), {}, { retryConfig: t2.websocketRetryConfig }), e2), this._statsCollector = t2.statsCollector, this.role = t2.role || "audience", this._clientRoleOptions = t2.clientRoleOptions, this.handleSignalEvents();
        }
        async join(e2, t2, i2) {
          if (this.signal instanceof kC) {
            let t3 = false;
            "disabled" !== e2.cloudProxyServer ? (OE.debug("[".concat(this.store.clientId, "] Dc is not supported, because cloudProxyServer are not supported (").concat(e2.cloudProxyServer, ")")), t3 = true) : "".concat(e2.apResponse.cid, "_").concat(e2.apResponse.cert).length > 255 || "".concat(e2.apResponse.cid, "_").concat(e2.apResponse.cert).length < 22 ? (OE.debug("[".concat(this.store.clientId, "] Dc is not supported, because ticket length is incorrect, it has to be between 22 and 255")), t3 = true) : e2.apResponse.addresses.some((e3) => e3.fingerprint) || GE("FINGERPRINT") || (OE.debug("[".concat(this.store.clientId, "] Dc is not supported, because fingerprint does not exist")), t3 = true), t3 && this.resetSignal();
          }
          this.store.joinGatewayStart(), "disabled" !== e2.cloudProxyServer && (this.hasChangeBGPAddress = true);
          const n2 = Date.now();
          let r2 = xC.get(e2.cname);
          if (r2 || (r2 = /* @__PURE__ */ new Map(), xC.set(e2.cname, r2)), this._isProactiveJoin = true, r2.has(e2.uid)) {
            const t3 = new SE(fE.UID_CONFLICT);
            throw Pg.joinGateway(e2.sid, { lts: n2, succ: false, ec: t3.message, addr: null, uid: e2.uid, cid: e2.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!e2.proxyServer, signalChannel: this.signal instanceof kC ? "1" : "0" }), this._isProactiveJoin = false, t3;
          }
          r2.set(e2.uid, true), this.joinInfo = e2, this.key = t2;
          let o2 = 0;
          this.joinGatewayStartTime = n2;
          const s2 = e2.proxyServer;
          try {
            let t3;
            if (OE.debug("[".concat(this.store.clientId, "] use ").concat(this.signal instanceof kC ? "datachannel" : "websocket", " join uid ").concat(o2)), this.signal instanceof kC)
              t3 = await this.signal.init(e2.apResponse.addresses, i2);
            else {
              const n3 = e2.proxyServer, r3 = n3 ? e2.gatewayAddrs.map((e3) => {
                const t4 = e3.address.split(":");
                return "wss://".concat(n3, "/ws/?h=").concat(t4[0], "&p=").concat(t4[1]);
              }) : e2.gatewayAddrs.map((e3) => "wss://".concat(e3.address));
              t3 = await this.signal.init(r3, i2);
            }
            o2 = t3.uid, OE.debug("[".concat(this.store.clientId, "] ").concat(this.signal instanceof kC ? "datachannel" : "websocket", " join uid ").concat(o2, " cost ").concat(Date.now() - this.joinGatewayStartTime));
          } catch (t3) {
            if (t3 && t3.code === fE.INIT_WEBSOCKET_TIMEOUT)
              throw OE.warning("[".concat(this.store.clientId, "] User join failed"), t3.toString()), t3;
            if (t3 && t3.code === fE.INIT_DATACHANNEL_TIMEOUT)
              throw OE.warning("[".concat(this.store.clientId, "] User join datachannel failed"), t3.toString()), this.resetSignal(), t3;
            throw OE.error("[".concat(this.store.clientId, "] User join failed"), t3.toString()), Pg.joinGateway(e2.sid, { lts: n2, succ: false, ec: t3.message, addr: this.signal.url, uid: e2.uid, cid: e2.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!s2, signalChannel: this.signal instanceof kC ? "1" : "0" }), this._isProactiveJoin = false, r2.delete(e2.uid), this.signal.close(), t3;
          }
          return this.state = "CONNECTED", this.inChannelInfo.joinAt = Date.now(), OE.debug("[".concat(this.store.clientId, "] Connected to gateway server")), this.trafficStatsInterval = window.setInterval(() => {
            this.updateTrafficStats().catch((e3) => {
              OE.warning("[".concat(this.store.clientId, "] get traffic stats error"), e3.toString());
            });
          }, 3e3), this.networkQualityInterval = window.setInterval(() => {
            navigator && void 0 !== navigator.onLine && !navigator.onLine ? this.emit(aS.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 }) : this._signalTimeout ? this.emit(aS.NETWORK_QUALITY, { downlinkNetworkQuality: 5, uplinkNetworkQuality: 5 }) : "CONNECTED" === this.state && this._statsCollector.trafficStats ? this.emit(aS.NETWORK_QUALITY, { uplinkNetworkQuality: GI(this._statsCollector.trafficStats.B_unq), downlinkNetworkQuality: GI(this._statsCollector.trafficStats.B_dnq) }) : this.emit(aS.NETWORK_QUALITY, { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 });
          }, 2e3), this.store.joinGatewayEnd(), o2;
        }
        async leave() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t2 = arguments.length > 1 ? arguments[1] : void 0;
          if ("DISCONNECTED" !== this.state) {
            t2 !== vf.FALLBACK && (this.state = "DISCONNECTING");
            try {
              e2 || this.signal.connectionState !== Of.CONNECTED || await function(e3, t3) {
                return t3 === 1 / 0 ? e3 : Sl.race([e3, QI(t3)]);
              }(this.signal.request(bf.LEAVE, void 0, true), 3e3);
            } catch (e3) {
              OE.warning("[".concat(this.store.clientId, "] leave request failed, ignore"), e3);
            }
            this.signal.close(t2), t2 !== vf.FALLBACK && (this.state = "DISCONNECTED"), this.reset();
          }
        }
        async publish(e2, t2, i2) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
            throw new SE(fE.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
          const n2 = { state: "offer", p2p_id: this.store.p2pId, ortc: t2, mode: this.spec.mode, extend: GE("PUB_EXTEND"), twcc: !!GE("PUBLISH_TWCC"), rtx: !!GE("USE_PUB_RTX") };
          try {
            return (await this.signal.request(bf.PUBLISH, n2, true))._message;
          } catch (n3) {
            if (i2 && n3.data && n3.data.code === If.ERR_PUBLISH_REQUEST_INVALID)
              return OE.warning("[".concat(this.store.clientId, "] receive publish error code, retry"), n3.toString()), await this.tryUnpubBeforeRepub(e2, t2), this.publish(e2, t2, false);
            throw n3;
          }
        }
        async unpublish(e2, t2) {
          try {
            if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
              throw new SE(fE.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
            await this.signal.request(bf.UNPUBLISH, { stream_id: t2, ortc: e2 }, true);
          } catch (e3) {
            OE.warning("[".concat(this.store.clientId, "] unpublish warning: "), e3);
          }
        }
        async subscribe(e2, t2, i2) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
            throw new SE(fE.INVALID_OPERATION, "can not subscribe when connection state is ".concat(this.state));
          const n2 = { stream_id: e2, stream_type: t2.stream_type, mode: this.spec.mode, codec: this.spec.codec, p2p_id: this.store.p2pId, twcc: !!GE("SUBSCRIBE_TWCC"), rtx: !!GE("USE_SUB_RTX"), extend: GE("SUB_EXTEND"), ssrcId: t2.ssrcId, svc: Array.isArray(GE("SVC")) && 0 !== GE("SVC").length ? GE("SVC") : void 0 };
          try {
            return (await this.signal.request(bf.SUBSCRIBE, n2, true))._message;
          } catch (n3) {
            if (i2 && n3.data && n3.data.code === If.ERR_SUBSCRIBE_REQUEST_INVALID)
              return OE.warning("[".concat(this.store.clientId, "] receiver subscribe error code, retry"), n3.toString()), await this.tryUnsubBeforeResub(e2, t2), await this.subscribe(e2, t2, false);
            throw n3;
          }
        }
        async subscribeAll(e2, t2) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
            throw new SE(fE.INVALID_OPERATION, "can not massSubscribe when connection state is ".concat(this.state));
          const i2 = { p2p_id: this.store.p2pId, users: e2, dtx: false, rtx: !!GE("USE_SUB_RTX") };
          try {
            return await this.signal.request(bf.SUBSCRIBE_STREAMS, i2, true);
          } catch (i3) {
            if (t2 && i3.data && i3.data.code === If.ERR_SUBSCRIBE_REQUEST_INVALID)
              return OE.warning("[".concat(this.store.clientId, "] receiver massSubscribe error code, retry"), i3.toString()), await this.tryMassUnsubBeforeResub(e2), await this.subscribeAll(e2, false);
            throw i3;
          }
        }
        async setVideoProfile(e2) {
          const t2 = function(e3) {
            if (!(e3.bitrateMax && e3.bitrateMin && e3.frameRate && e3.height && e3.width))
              return;
            let t3 = e3.frameRate, i2 = e3.width, n2 = e3.height, r2 = true;
            return "number" != typeof t3 && (t3 = t3.exact || t3.ideal || t3.max || t3.min || 0, t3 || (r2 = false)), "number" != typeof i2 && (i2 = i2.exact || i2.ideal || i2.max || i2.min || 0, i2 || (r2 = false)), "number" != typeof n2 && (n2 = n2.exact || n2.ideal || n2.max || n2.min || 0, t3 || (r2 = false)), r2 ? { stream_type: 0, width: i2, height: n2, fps: t3, start_bps: 1e3 * e3.bitrateMax, min_bps: 1e3 * e3.bitrateMin, target_bps: 1e3 * e3.bitrateMax } : void 0;
          }(e2);
          if (t2)
            return this.signal.request(bf.SET_VIDEO_PROFILE, t2);
          OE.debug("[".concat(this.store.clientId, "] encoder config is not complete, do not report to gateway"));
        }
        async unsubscribe(e2, t2) {
          try {
            await this.signal.request(bf.UNSUBSCRIBE, { p2p_id: this.store.p2pId, ortc: e2, stream_id: t2 }, true);
          } catch (e3) {
            OE.warning("[".concat(this.store.clientId, "] unsubscribe warning: "), e3);
          }
        }
        async massUnsubscribe(e2) {
          try {
            await this.signal.request(bf.UNSUBSCRIBE_STREAMS, e2, true);
          } catch (e3) {
            OE.warning("[".concat(this.store.clientId, "] massUnsubscribeAll warning: "), e3);
          }
        }
        async reconnectPC(e2) {
          const { iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 } = e2;
          return { gatewayEstablishParams: await this.signal.request(bf.CONNECT_PC, { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: { iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 } }, true), gatewayAddress: this.getCurrentGatewayAddress() };
        }
        getGatewayInfo() {
          return this.signal.request(bf.GATEWAY_INFO);
        }
        async renewToken(e2) {
          await this.signal.request(bf.RENEW_TOKEN, e2), this.key = e2.token;
        }
        async setClientRole(e2, t2) {
          if (t2 && (this._clientRoleOptions = Object.assign({}, t2)), "CONNECTED" !== this.state)
            return void (this.role = e2);
          let i2 = void 0;
          i2 = "audience" === e2 ? this._clientRoleOptions && this._clientRoleOptions.level ? this._clientRoleOptions.level : 2 : 0, await this.signal.request(bf.SET_CLIENT_ROLE, { role: e2, level: i2, client_ts: Date.now() }), this.role = e2;
        }
        async setRemoteVideoStreamType(e2, t2) {
          await this.signal.request(bf.SWITCH_VIDEO_STREAM, { stream_id: e2, stream_type: t2 });
        }
        async setDefaultRemoteVideoStreamType(e2) {
          await this.signal.request(bf.DEFAULT_VIDEO_STREAM, { stream_type: e2 });
        }
        async setStreamFallbackOption(e2, t2) {
          await this.signal.request(bf.SET_FALLBACK_OPTION, { stream_id: e2, fallback_type: t2 });
        }
        async pickSVCLayer(e2, t2) {
          await this.signal.request(bf.PICK_SVC_LAYER, { stream_id: e2, spatial_layer: t2.spatialLayer, temporal_layer: t2.temporalLayer });
        }
        getInChannelInfo() {
          return this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt), UC({}, this.inChannelInfo);
        }
        async getGatewayVersion() {
          return (await this.signal.request(bf.GATEWAY_INFO)).version;
        }
        reset() {
          if (this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt, this.inChannelInfo.joinAt = null), this.trafficStatsInterval && (window.clearInterval(this.trafficStatsInterval), this.trafficStatsInterval = void 0), this.joinInfo) {
            const e2 = xC.get(this.joinInfo.cname);
            e2 && e2.delete(this.joinInfo.uid);
          }
          this.joinInfo = void 0, this.key = void 0, this.networkQualityInterval && (window.clearInterval(this.networkQualityInterval), this.networkQualityInterval = void 0);
        }
        updateTurnConfigFromSignal() {
          if (!this.joinInfo)
            return;
          const e2 = function(e3) {
            let t2;
            return t2 = e3.startsWith("dc") ? e3.match(/(dc\:\/\/)?([^:]+):(\d+)/) : e3.match(/(wss\:\/\/)?([^:]+):(\d+)/), t2 ? { username: PE.username, password: PE.password, turnServerURL: t2[2], tcpport: parseInt(t2[3]) + 30, udpport: parseInt(t2[3]) + 30, forceturn: false } : null;
          }(("disabled" === this.joinInfo.cloudProxyServer ? this.signal.url : this.joinInfo.gatewayAddrs[this.signal.currentURLIndex].address) || "");
          this.joinInfo.turnServer.serversFromGateway = [], e2 && "off" !== this.joinInfo.turnServer.mode && "disabled" === this.joinInfo.cloudProxyServer && this.joinInfo.turnServer.serversFromGateway.push(UC(UC({}, PE), {}, { turnServerURL: e2.turnServerURL, tcpport: e2.tcpport, udpport: e2.udpport, username: this.joinInfo.uid.toString(), password: this.joinInfo.token }));
        }
        async updateTrafficStats() {
          if ("CONNECTED" !== this.state)
            return;
          const e2 = await this.signal.request(bf.TRAFFIC_STATS, void 0, true);
          e2.timestamp = Date.now(), e2.peer_delay.forEach((e3) => {
            const t2 = this._statsCollector.trafficStats && this._statsCollector.trafficStats.peer_delay.find((t3) => t3.peer_uid === e3.peer_uid);
            t2 && t2.B_st !== e3.B_st && dC(() => {
              this.emit(aS.STREAM_TYPE_CHANGE, e3.peer_uid, e3.B_st);
            });
          }), this._statsCollector.updateTrafficStats(e2);
        }
        getJoinMessage(e2) {
          if (!this.joinInfo || !this.key)
            throw new SE(fE.UNEXPECTED_ERROR, "can not generate join message, no join info");
          const t2 = Object.assign({}, this.joinInfo.apResponse);
          let i2 = GE("REPORT_APP_SCENARIO");
          if ("string" != typeof i2)
            try {
              i2 = JSON.stringify(i2);
            } catch (e3) {
              i2 = void 0;
            }
          i2 && i2.length > 128 && (i2 = void 0);
          const n2 = UC({ license: this.joinInfo.license, p2p_id: this.store.p2pId, session_id: this.joinInfo.sid, app_id: this.joinInfo.appId, channel_key: this.key, channel_name: this.joinInfo.cname, sdk_version: bE, browser: navigator.userAgent, process_id: GE("PROCESS_ID"), mode: this.spec.mode, codec: this.spec.codec, role: this.role, has_changed_gateway: this.hasChangeBGPAddress, ap_response: t2, extend: GE("JOIN_EXTEND"), details: { 6: this.joinInfo.stringUid, cservice_map: "proxy3" === this.joinInfo.cloudProxyServer ? "1" : "proxy5" === this.joinInfo.cloudProxyServer ? "2" : void 0 }, features: { rejoin: true }, optionalInfo: this.joinInfo.optionalInfo, appScenario: i2, attributes: { userAttributes: { enablePublishedUserList: GE("ENABLE_PUBLISHED_USER_LIST"), maxSubscription: GE("MAX_SUBSCRIPTION"), subscribeAudioFilterTopN: "number" == typeof GE("SUBSCRIBE_AUDIO_FILTER_TOPN") ? GE("SUBSCRIBE_AUDIO_FILTER_TOPN") : void 0, enablePublishAudioFilter: "boolean" == typeof GE("ENABLE_PUBLISH_AUDIO_FILTER") ? GE("ENABLE_PUBLISH_AUDIO_FILTER") : void 0, enableUserLicenseCheck: "boolean" == typeof GE("ENABLE_USER_LICENSE_CHECK") ? GE("ENABLE_USER_LICENSE_CHECK") : void 0, enableRTX: true === GE("USE_PUB_RTX") || true === GE("USE_SUB_RTX") || void 0 } }, join_ts: this.joinGatewayStartTime }, e2);
          return this.joinInfo.stringUid && (n2.string_uid = this.joinInfo.stringUid), this.joinInfo.aesmode && this.joinInfo.aespassword && (n2.aes_mode = this.joinInfo.aesmode, GE("ENCRYPT_AES") ? (n2.aes_secret = this.joinInfo.aespassword, n2.aes_encrypt = true) : n2.aes_secret = this.joinInfo.aespassword, this.joinInfo.aessalt && (n2.aes_salt = this.joinInfo.aessalt)), t2.addresses[this.signal.websocket.currentURLIndex] && (n2.ap_response.ticket = t2.addresses[this.signal.websocket.currentURLIndex].ticket, delete t2.addresses), void 0 !== this.joinInfo.defaultVideoStream && (n2.default_video_stream = this.joinInfo.defaultVideoStream), n2;
        }
        getRejoinMessage() {
          if (!this.joinInfo)
            throw new SE(fE.UNEXPECTED_ERROR, "can not generate rejoin message, no join info");
          return { session_id: this.joinInfo.sid, channel_name: this.joinInfo.cname, cid: this.joinInfo.cid, uid: this.joinInfo.uid, vid: Number(this.joinInfo.vid) };
        }
        handleSignalEvents() {
          this.signal.on(Nf.WS_RECONNECT_WAITTING_FINISH, (e2) => {
            ["tryNext", "recover"].includes(e2) && this.joinInfo && Pg.adjustSessionStartTime(this.joinInfo.sid);
          }), this.signal.on(Nf.WS_RECONNECT_CREATE_CONNECTION, (e2) => {
            this.joinGatewayStartTime = Date.now();
          }), this.signal.on(Nf.WS_RECONNECTING, (e2) => {
            this.joinInfo && Pg.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: e2 || Af.NETWORK_ERROR }), this.joinInfo && (this.state = "RECONNECTING", Pg.sessionInit(this.joinInfo.sid, { lts: new Date().getTime(), extend: this.isSignalRecover ? { recover: true } : { rejoin: true }, cname: this.joinInfo.cname, appid: this.joinInfo.appId, mode: this.spec.mode }), this.isSignalRecover = false, this.joinGatewayStartTime = Date.now());
          }), this.signal.on(Nf.WS_CLOSED, (e2) => {
            let t2;
            switch (e2) {
              case vf.LEAVE:
                t2 = Af.LEAVE;
                break;
              case vf.UID_BANNED:
              case vf.IP_BANNED:
              case vf.CHANNEL_BANNED:
              case vf.SERVER_ERROR:
                t2 = Af.SERVER_ERROR;
                break;
              case vf.FALLBACK:
                t2 = Af.FALLBACK;
                break;
              case vf.LICENSE_MISSING:
              case vf.LICENSE_EXPIRED:
              case vf.LICENSE_MINUTES_EXCEEDED:
              case vf.LICENSE_PERIOD_INVALID:
              case vf.LICENSE_MULTIPLE_SDK_SERVICE:
              case vf.LICENSE_ILLEGAL:
                t2 = e2;
                break;
              default:
                t2 = Af.NETWORK_ERROR;
            }
            OE.debug("[".concat(this.store.clientId, "] [signal] websocket closed, reason: ").concat(t2 || "undefined -> " + Af.NETWORK_ERROR)), this.joinInfo && Pg.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: e2 === vf.LEAVE ? 1 : -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: t2 }), this._disconnectedReason = e2, e2 !== vf.FALLBACK && (this.state = "DISCONNECTED"), this.reset();
          }), this.signal.on(Nf.WS_CONNECTED, () => {
            if (this.updateTurnConfigFromSignal(), this.state = "CONNECTED", this.joinInfo && ("audience" === this.role && this._clientRoleOptions && this._clientRoleOptions.level && (OE.debug("[".concat(this.store.clientId, "] patch to send set client role, role: ").concat(this.role, ", mode: ").concat(this.spec.mode, ", level: ").concat(this._clientRoleOptions && this._clientRoleOptions.level)), this.setClientRole(this.role, this._clientRoleOptions)), Pg.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: true, ec: null, vid: this.joinInfo.vid, addr: this.signal.url, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!this.joinInfo.proxyServer, signalChannel: this.signal instanceof kC ? "1" : "0" }), this._isProactiveJoin = false, this.joinInfo.useLocalAccessPoint && 1 === this.joinInfo.setLocalAPVersion)) {
              const e2 = this.signal.url && this.signal.url.match(/wss\:\/\/([^:]+):(\d+)/);
              if (!e2)
                return void OE.error("[".concat(this.store.clientId, "] set local access point after joined failed: ").concat(e2));
              BE("EVENT_REPORT_DOMAIN", e2[1]), BE("EVENT_REPORT_BACKUP_DOMAIN", e2[1]), BE("LOG_UPLOAD_SERVER", "".concat(e2[1], ":6444"));
            }
          }), this.signal.on(Df.ON_UPLINK_STATS, (e2) => {
            this._statsCollector.updateUplinkStats(e2);
          }), this.signal.on(Nf.REQUEST_RECOVER, (e2, t2, i2) => {
            if (!this.joinInfo)
              return i2(new SE(fE.UNEXPECTED_ERROR, "gateway: can not recover, no join info"));
            e2 && (this.joinInfo.multiIP = e2, this.hasChangeBGPAddress = true), this.isSignalRecover = true, nC(this, aS.REQUEST_NEW_GATEWAY_LIST).then(t2).catch(i2);
          }), this.signal.on(Nf.REQUEST_JOIN_INFO, async (e2) => {
            var t2;
            this.updateTurnConfigFromSignal();
            const { iceParameters: i2, dtlsParameters: n2, rtpCapabilities: r2 } = await nC(this, aS.REQUEST_P2P_CONNECTION_PARAMS, { turnServer: null === (t2 = this.joinInfo) || void 0 === t2 ? void 0 : t2.turnServer });
            e2(this.getJoinMessage({ ortc: { iceParameters: i2, dtlsParameters: n2, rtpCapabilities: r2, version: "2" } }));
          }), this.signal.on(Nf.REQUEST_REJOIN_INFO, (e2) => {
            e2(this.getRejoinMessage());
          }), this.signal.on(Nf.REPORT_JOIN_GATEWAY, (e2, t2) => {
            this.joinInfo && (Pg.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: false, ec: e2, addr: t2, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!this.joinInfo.proxyServer, signalChannel: this.signal instanceof kC ? "1" : "0" }), this._isProactiveJoin = false);
          }), this.signal.on(Nf.IS_P2P_DISCONNECTED, (e2) => {
            e2(sC(this, aS.IS_P2P_DISCONNECTED));
          }), this.signal.on(Nf.DISCONNECT_P2P, () => {
            this.emit(aS.DISCONNECT_P2P);
          }), this.signal.on(Nf.NEED_RENEW_SESSION, () => {
            this.emit(aS.NEED_RENEW_SESSION);
          }), this.signal.on(Nf.REQUEST_SUCCESS, () => {
            this._signalTimeout = false;
          }), this.signal.on(Nf.REQUEST_TIMEOUT, () => {
            this._signalTimeout = true;
          }), this.signal.on(Nf.JOIN_RESPONSE, (e2) => {
            const t2 = this.getCurrentGatewayAddress();
            this.emit(aS.JOIN_RESPONSE, e2, t2);
          }), this.signal.on(Nf.DATACHANNEL_PRECONNECT, async (e2, t2, i2) => {
            this.updateTurnConfigFromSignal();
            const n2 = this.getCurrentGatewayAddress();
            return nC(this, aS.DATACHANNEL_PRECONNECT, e2, n2).then(t2).catch(i2);
          }), this.signal.on(Nf.DATACHANNEL_CONNECTING, async (e2) => {
            const { iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 } = await nC(this, aS.REQUEST_DC_CONNECTION_PARAMS);
            e2(this.getJoinMessage({ ortc: { iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2, version: "2" } }));
          }), this.signal.on(Nf.DATACHANNEL_FAILBACK, () => {
            OE.warning("[".concat(this.store.clientId, "] User join datachannel failed")), this.reset(), this.resetSignal(), this.emit(aS.DATACHANNEL_FAILBACK);
          });
        }
        async tryUnsubBeforeResub(e2, t2) {
          try {
            await this.signal.request(bf.UNSUBSCRIBE, { p2p_id: this.store.p2pId, stream_id: e2, ortc: [t2] }, true);
          } catch (e3) {
            throw OE.warning("[".concat(this.store.clientId, "] tryUnsubBeforeResub warning"), e3), e3;
          }
        }
        async tryUnpubBeforeRepub(e2, t2) {
          try {
            await this.signal.request(bf.UNPUBLISH, { stream_id: e2, ortc: t2 }, true);
          } catch (e3) {
            throw OE.warning("[".concat(this.store.clientId, "] tryUnpubBeforeRepub warning: "), e3), e3;
          }
        }
        async tryMassUnsubBeforeResub(e2) {
          const t2 = { users: e2.map((e3) => ({ stream_id: e3.stream_id, stream_type: e3.stream_type })) };
          try {
            await this.signal.request(bf.UNSUBSCRIBE_STREAMS, t2, true);
          } catch (e3) {
            throw OE.warning("[".concat(this.store.clientId, "] tryMassUnsubBeforeResub warning"), e3), e3;
          }
        }
        async muteLocal(e2, t2) {
          const i2 = { action: e2.find((e3) => e3.stream_type === sS.Audio) ? "mute_local_audio" : "mute_local_video", p2p_id: this.store.p2pId, ortc: e2, stream_id: t2 };
          try {
            await this.signal.request(bf.CONTROL, i2, true, true);
          } catch (e3) {
            throw OE.warning("[".concat(this.store.clientId, "] gateway muteLocal warning: "), e3), e3;
          }
        }
        async unmuteLocal(e2, t2) {
          const i2 = { action: e2.find((e3) => e3.stream_type === sS.Audio) ? "unmute_local_audio" : "unmute_local_video", p2p_id: this.store.p2pId, ortc: e2, stream_id: t2 };
          try {
            await this.signal.request(bf.CONTROL, i2, true, true);
          } catch (e3) {
            throw OE.warning("[".concat(this.store.clientId, "] gateway unmuteLocal warning: "), e3), e3;
          }
        }
        uploadStats(e2, t2) {
          this.signal.upload(e2, t2);
        }
        getSignalRTT() {
          return this.signal.rtt;
        }
        async restartICE(e2) {
          const t2 = { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: e2 };
          try {
            return await this.signal.request(bf.RESTART_ICE, t2, true);
          } catch (e3) {
            throw OE.warning("[".concat(this.store.clientId, "] P2PChannel.restartICE warning: "), e3), e3;
          }
        }
        reconnect() {
          "CONNECTED" === this.state && this.signal.reconnect(void 0, Af.P2P_FAILED);
        }
        getCurrentGatewayAddress() {
          var e2;
          if (!GE("GATEWAY_WSS_ADDRESS"))
            return null !== (e2 = this.joinInfo) && void 0 !== e2 && e2.gatewayAddrs ? this.joinInfo.gatewayAddrs[this.signal.currentURLIndex] : void 0;
        }
        async setPublishAudioFilterEnabled(e2) {
          await this.signal.request(bf.SET_PARAMETER, { enablePublishAudioFilter: e2 });
        }
        resetSignal() {
          this.signal && (this.signal.removeAllListeners(), this.signal.close(vf.FALLBACK)), this.store.useDataChannel = false, this.signal = new AC(UC(UC({}, this.spec), {}, { retryConfig: this.spec.websocketRetryConfig }), this.store), this.handleSignalEvents(), this.emit(aS.RESET_SIGNAL, dS.websocket);
        }
      }
      !function() {
        var e2;
        function i2(e3) {
          var t2 = 0;
          return function() {
            return t2 < e3.length ? { done: false, value: e3[t2++] } : { done: true };
          };
        }
        var n2 = "function" == typeof Object.defineProperties ? Object.defineProperty : function(e3, t2, i3) {
          return e3 == Array.prototype || e3 == Object.prototype || (e3[t2] = i3.value), e3;
        };
        var r2, o2 = function(e3) {
          e3 = ["object" == typeof globalThis && globalThis, e3, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof t && t];
          for (var i3 = 0; i3 < e3.length; ++i3) {
            var n3 = e3[i3];
            if (n3 && n3.Math == Math)
              return n3;
          }
          throw Error("Cannot find global object");
        }(this);
        function s2(e3, t2) {
          if (t2)
            e: {
              var i3 = o2;
              e3 = e3.split(".");
              for (var r3 = 0; r3 < e3.length - 1; r3++) {
                var s3 = e3[r3];
                if (!(s3 in i3))
                  break e;
                i3 = i3[s3];
              }
              (t2 = t2(r3 = i3[e3 = e3[e3.length - 1]])) != r3 && null != t2 && n2(i3, e3, { configurable: true, writable: true, value: t2 });
            }
        }
        function a2(e3) {
          return (e3 = { next: e3 })[Symbol.iterator] = function() {
            return this;
          }, e3;
        }
        function c2(e3) {
          var t2 = "undefined" != typeof Symbol && Symbol.iterator && e3[Symbol.iterator];
          return t2 ? t2.call(e3) : { next: i2(e3) };
        }
        if (s2("Symbol", function(e3) {
          function t2(e4, t3) {
            this.A = e4, n2(this, "description", { configurable: true, writable: true, value: t3 });
          }
          if (e3)
            return e3;
          t2.prototype.toString = function() {
            return this.A;
          };
          var i3 = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", r3 = 0;
          return function e4(n3) {
            if (this instanceof e4)
              throw new TypeError("Symbol is not a constructor");
            return new t2(i3 + (n3 || "") + "_" + r3++, n3);
          };
        }), s2("Symbol.iterator", function(e3) {
          if (e3)
            return e3;
          e3 = Symbol("Symbol.iterator");
          for (var t2 = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), r3 = 0; r3 < t2.length; r3++) {
            var s3 = o2[t2[r3]];
            "function" == typeof s3 && "function" != typeof s3.prototype[e3] && n2(s3.prototype, e3, { configurable: true, writable: true, value: function() {
              return a2(i2(this));
            } });
          }
          return e3;
        }), "function" == typeof Object.setPrototypeOf)
          r2 = Object.setPrototypeOf;
        else {
          var d2;
          e: {
            var u2 = {};
            try {
              u2.__proto__ = { a: true }, d2 = u2.a;
              break e;
            } catch (e3) {
            }
            d2 = false;
          }
          r2 = d2 ? function(e3, t2) {
            if (e3.__proto__ = t2, e3.__proto__ !== t2)
              throw new TypeError(e3 + " is not extensible");
            return e3;
          } : null;
        }
        var l2 = r2;
        function h2() {
          this.m = false, this.j = null, this.v = void 0, this.h = 1, this.u = this.C = 0, this.l = null;
        }
        function p2(e3) {
          if (e3.m)
            throw new TypeError("Generator is already running");
          e3.m = true;
        }
        function _2(e3, t2) {
          return e3.h = 3, { value: t2 };
        }
        function E2(e3) {
          this.g = new h2(), this.G = e3;
        }
        function m2(e3, t2, i3, n3) {
          try {
            var r3 = t2.call(e3.g.j, i3);
            if (!(r3 instanceof Object))
              throw new TypeError("Iterator result " + r3 + " is not an object");
            if (!r3.done)
              return e3.g.m = false, r3;
            var o3 = r3.value;
          } catch (t3) {
            return e3.g.j = null, e3.g.s(t3), f2(e3);
          }
          return e3.g.j = null, n3.call(e3.g, o3), f2(e3);
        }
        function f2(e3) {
          for (; e3.g.h; )
            try {
              var t2 = e3.G(e3.g);
              if (t2)
                return e3.g.m = false, { value: t2.value, done: false };
            } catch (t3) {
              e3.g.v = void 0, e3.g.s(t3);
            }
          if (e3.g.m = false, e3.g.l) {
            if (t2 = e3.g.l, e3.g.l = null, t2.F)
              throw t2.D;
            return { value: t2.return, done: true };
          }
          return { value: void 0, done: true };
        }
        function S2(e3) {
          this.next = function(t2) {
            return e3.o(t2);
          }, this.throw = function(t2) {
            return e3.s(t2);
          }, this.return = function(t2) {
            return function(e4, t3) {
              p2(e4.g);
              var i3 = e4.g.j;
              return i3 ? m2(e4, "return" in i3 ? i3.return : function(e5) {
                return { value: e5, done: true };
              }, t3, e4.g.return) : (e4.g.return(t3), f2(e4));
            }(e3, t2);
          }, this[Symbol.iterator] = function() {
            return this;
          };
        }
        function T2(e3, t2) {
          return t2 = new S2(new E2(t2)), l2 && e3.prototype && l2(t2, e3.prototype), t2;
        }
        if (h2.prototype.o = function(e3) {
          this.v = e3;
        }, h2.prototype.s = function(e3) {
          this.l = { D: e3, F: true }, this.h = this.C || this.u;
        }, h2.prototype.return = function(e3) {
          this.l = { return: e3 }, this.h = this.u;
        }, E2.prototype.o = function(e3) {
          return p2(this.g), this.g.j ? m2(this, this.g.j.next, e3, this.g.o) : (this.g.o(e3), f2(this));
        }, E2.prototype.s = function(e3) {
          return p2(this.g), this.g.j ? m2(this, this.g.j.throw, e3, this.g.o) : (this.g.s(e3), f2(this));
        }, s2("Array.prototype.entries", function(e3) {
          return e3 || function() {
            return function(e4, t2) {
              e4 instanceof String && (e4 += "");
              var i3 = 0, n3 = false, r3 = { next: function() {
                if (!n3 && i3 < e4.length) {
                  var r4 = i3++;
                  return { value: t2(r4, e4[r4]), done: false };
                }
                return n3 = true, { done: true, value: void 0 };
              } };
              return r3[Symbol.iterator] = function() {
                return r3;
              }, r3;
            }(this, function(e4, t2) {
              return [e4, t2];
            });
          };
        }), "undefined" != typeof Blob && ("undefined" == typeof FormData || !FormData.prototype.keys)) {
          var g2 = function(e3, t2) {
            for (var i3 = 0; i3 < e3.length; i3++)
              t2(e3[i3]);
          }, R2 = function(e3) {
            return e3.replace(/\r?\n|\r/g, "\r\n");
          }, I2 = function(e3, t2, i3) {
            return t2 instanceof Blob ? (i3 = void 0 !== i3 ? String(i3 + "") : "string" == typeof t2.name ? t2.name : "blob", t2.name === i3 && "[object Blob]" !== Object.prototype.toString.call(t2) || (t2 = new File([t2], i3)), [String(e3), t2]) : [String(e3), String(t2)];
          }, C2 = function(e3, t2) {
            if (e3.length < t2)
              throw new TypeError(t2 + " argument required, but only " + e3.length + " present.");
          }, v2 = "object" == typeof globalThis ? globalThis : "object" == typeof window ? window : "object" == typeof self ? self : this, y2 = v2.FormData, A2 = v2.XMLHttpRequest && v2.XMLHttpRequest.prototype.send, O2 = v2.Request && v2.fetch, N2 = v2.navigator && v2.navigator.sendBeacon, b2 = v2.Element && v2.Element.prototype, w2 = v2.Symbol && Symbol.toStringTag;
          w2 && (Blob.prototype[w2] || (Blob.prototype[w2] = "Blob"), "File" in v2 && !File.prototype[w2] && (File.prototype[w2] = "File"));
          try {
            new File([], "");
          } catch (e3) {
            v2.File = function(e4, t2, i3) {
              return e4 = new Blob(e4, i3 || {}), Object.defineProperties(e4, { name: { value: t2 }, lastModified: { value: +(i3 && void 0 !== i3.lastModified ? new Date(i3.lastModified) : new Date()) }, toString: { value: function() {
                return "[object File]";
              } } }), w2 && Object.defineProperty(e4, w2, { value: "File" }), e4;
            };
          }
          var D2 = function(e3) {
            return e3.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
          }, P2 = function(e3) {
            this.i = [];
            var t2 = this;
            e3 && g2(e3.elements, function(e4) {
              if (e4.name && !e4.disabled && "submit" !== e4.type && "button" !== e4.type && !e4.matches("form fieldset[disabled] *"))
                if ("file" === e4.type) {
                  var i3 = e4.files && e4.files.length ? e4.files : [new File([], "", { type: "application/octet-stream" })];
                  g2(i3, function(i4) {
                    t2.append(e4.name, i4);
                  });
                } else
                  "select-multiple" === e4.type || "select-one" === e4.type ? g2(e4.options, function(i4) {
                    !i4.disabled && i4.selected && t2.append(e4.name, i4.value);
                  }) : "checkbox" === e4.type || "radio" === e4.type ? e4.checked && t2.append(e4.name, e4.value) : (i3 = "textarea" === e4.type ? R2(e4.value) : e4.value, t2.append(e4.name, i3));
            });
          };
          if ((e2 = P2.prototype).append = function(e3, t2, i3) {
            C2(arguments, 2), this.i.push(I2(e3, t2, i3));
          }, e2.delete = function(e3) {
            C2(arguments, 1);
            var t2 = [];
            e3 = String(e3), g2(this.i, function(i3) {
              i3[0] !== e3 && t2.push(i3);
            }), this.i = t2;
          }, e2.entries = function e3() {
            var t2, i3 = this;
            return T2(e3, function(e4) {
              if (1 == e4.h && (t2 = 0), 3 != e4.h)
                return t2 < i3.i.length ? e4 = _2(e4, i3.i[t2]) : (e4.h = 0, e4 = void 0), e4;
              t2++, e4.h = 2;
            });
          }, e2.forEach = function(e3, t2) {
            C2(arguments, 1);
            for (var i3 = c2(this), n3 = i3.next(); !n3.done; n3 = i3.next()) {
              var r3 = c2(n3.value);
              n3 = r3.next().value, r3 = r3.next().value, e3.call(t2, r3, n3, this);
            }
          }, e2.get = function(e3) {
            C2(arguments, 1);
            var t2 = this.i;
            e3 = String(e3);
            for (var i3 = 0; i3 < t2.length; i3++)
              if (t2[i3][0] === e3)
                return t2[i3][1];
            return null;
          }, e2.getAll = function(e3) {
            C2(arguments, 1);
            var t2 = [];
            return e3 = String(e3), g2(this.i, function(i3) {
              i3[0] === e3 && t2.push(i3[1]);
            }), t2;
          }, e2.has = function(e3) {
            C2(arguments, 1), e3 = String(e3);
            for (var t2 = 0; t2 < this.i.length; t2++)
              if (this.i[t2][0] === e3)
                return true;
            return false;
          }, e2.keys = function e3() {
            var t2, i3, n3, r3, o3 = this;
            return T2(e3, function(e4) {
              if (1 == e4.h && (t2 = c2(o3), i3 = t2.next()), 3 != e4.h)
                return i3.done ? void (e4.h = 0) : (n3 = i3.value, r3 = c2(n3), _2(e4, r3.next().value));
              i3 = t2.next(), e4.h = 2;
            });
          }, e2.set = function(e3, t2, i3) {
            C2(arguments, 2), e3 = String(e3);
            var n3 = [], r3 = I2(e3, t2, i3), o3 = true;
            g2(this.i, function(t3) {
              t3[0] === e3 ? o3 && (o3 = !n3.push(r3)) : n3.push(t3);
            }), o3 && n3.push(r3), this.i = n3;
          }, e2.values = function e3() {
            var t2, i3, n3, r3, o3 = this;
            return T2(e3, function(e4) {
              if (1 == e4.h && (t2 = c2(o3), i3 = t2.next()), 3 != e4.h)
                return i3.done ? void (e4.h = 0) : (n3 = i3.value, (r3 = c2(n3)).next(), _2(e4, r3.next().value));
              i3 = t2.next(), e4.h = 2;
            });
          }, P2.prototype._asNative = function() {
            for (var e3 = new y2(), t2 = c2(this), i3 = t2.next(); !i3.done; i3 = t2.next()) {
              var n3 = c2(i3.value);
              i3 = n3.next().value, n3 = n3.next().value, e3.append(i3, n3);
            }
            return e3;
          }, P2.prototype._blob = function() {
            var e3 = "----formdata-polyfill-" + Math.random(), t2 = [], i3 = "--" + e3 + '\r\nContent-Disposition: form-data; name="';
            return this.forEach(function(e4, n3) {
              return "string" == typeof e4 ? t2.push(i3 + D2(R2(n3)) + '"\r\n\r\n' + R2(e4) + "\r\n") : t2.push(i3 + D2(R2(n3)) + '"; filename="' + D2(e4.name) + '"\r\nContent-Type: ' + (e4.type || "application/octet-stream") + "\r\n\r\n", e4, "\r\n");
            }), t2.push("--" + e3 + "--"), new Blob(t2, { type: "multipart/form-data; boundary=" + e3 });
          }, P2.prototype[Symbol.iterator] = function() {
            return this.entries();
          }, P2.prototype.toString = function() {
            return "[object FormData]";
          }, b2 && !b2.matches && (b2.matches = b2.matchesSelector || b2.mozMatchesSelector || b2.msMatchesSelector || b2.oMatchesSelector || b2.webkitMatchesSelector || function(e3) {
            for (var t2 = (e3 = (this.document || this.ownerDocument).querySelectorAll(e3)).length; 0 <= --t2 && e3.item(t2) !== this; )
              ;
            return -1 < t2;
          }), w2 && (P2.prototype[w2] = "FormData"), A2) {
            var L2 = v2.XMLHttpRequest.prototype.setRequestHeader;
            v2.XMLHttpRequest.prototype.setRequestHeader = function(e3, t2) {
              L2.call(this, e3, t2), "content-type" === e3.toLowerCase() && (this.B = true);
            }, v2.XMLHttpRequest.prototype.send = function(e3) {
              e3 instanceof P2 ? (e3 = e3._blob(), this.B || this.setRequestHeader("Content-Type", e3.type), A2.call(this, e3)) : A2.call(this, e3);
            };
          }
          O2 && (v2.fetch = function(e3, t2) {
            return t2 && t2.body && t2.body instanceof P2 && (t2.body = t2.body._blob()), O2.call(this, e3, t2);
          }), N2 && (v2.navigator.sendBeacon = function(e3, t2) {
            return t2 instanceof P2 && (t2 = t2._asNative()), N2.call(this, e3, t2);
          }), v2.FormData = P2;
        }
      }();
      const jC = () => {
        const e2 = GE("AREAS");
        0 === e2.length && e2.push(SS.GLOBAL);
        return zi(e2).call(e2, (e3, t2, i2) => {
          const n2 = FC(t2);
          return n2 ? 0 === i2 ? n2 : "".concat(e3, ",").concat(n2) : e3;
        }, "");
      }, FC = (e2) => e2 === SS.OVERSEA ? "".concat(IS.ASIA, ",").concat(IS.EUROPE, ",").concat(IS.AFRICA, ",").concat(IS.NORTH_AMERICA, ",").concat(IS.SOUTH_AMERICA, ",").concat(IS.OCEANIA) : IS[e2], BC = (e2) => {
        const t2 = { CODE: "", WEBCS_DOMAIN: [], WEBCS_DOMAIN_BACKUP_LIST: [], PROXY_CS: [], CDS_AP: [], ACCOUNT_REGISTER: [], UAP_AP: [], EVENT_REPORT_DOMAIN: [], EVENT_REPORT_BACKUP_DOMAIN: [], LOG_UPLOAD_SERVER: [], PROXY_SERVER_TYPE3: [] };
        return e2.map((e3) => {
          const i2 = CS[e3], n2 = Object.keys(i2);
          n2 && n2.map((e4) => {
            "CODE" !== e4 && (t2[e4] = t2[e4].concat(i2[e4]));
          });
        }), t2;
      }, GC = { GLOBAL: { ASIA: [SS.CHINA, SS.JAPAN, SS.INDIA, SS.KOREA, SS.HKMC], EUROPE: [], NORTH_AMERICA: [SS.US], SOUTH_AMERICA: [], OCEANIA: [], AFRICA: [] } }, WC = Object.keys(GC[SS.GLOBAL]), HC = [SS.CHINA, SS.NORTH_AMERICA, SS.EUROPE, SS.ASIA, SS.JAPAN, SS.INDIA, SS.OCEANIA, SS.SOUTH_AMERICA, SS.AFRICA, SS.KOREA, SS.HKMC, SS.US], KC = function(e2, t2) {
        let i2 = [];
        if (e2.includes(SS.GLOBAL)) {
          const o2 = [SS.GLOBAL, SS.OVERSEA], s2 = Object.keys(CS);
          if (t2 === SS.GLOBAL)
            throw new SE(fE.INVALID_PARAMS, "GLOBAL is an invalid excludedArea value");
          if (t2 === SS.CHINA)
            i2 = [SS.OVERSEA];
          else if (r2 = t2, WC.includes(r2)) {
            const e3 = (n2 = t2, GC[SS.GLOBAL][n2] || []), r3 = [...o2, t2, ...e3];
            i2 = s2.filter((e4) => !r3.includes(e4));
          } else if (function(e3) {
            let t3 = false;
            return WC.forEach((i3) => {
              GC[SS.GLOBAL][i3].includes(e3) && (t3 = true);
            }), t3;
          }(t2)) {
            const e3 = function(e4) {
              let t3;
              return WC.forEach((i3) => {
                GC[SS.GLOBAL][i3].includes(e4) && (t3 = i3);
              }), t3;
            }(t2), n3 = [...o2, e3, t2];
            i2 = s2.filter((e4) => !n3.includes(e4));
          } else
            i2 = e2;
          i2 = function(e3) {
            const t3 = [];
            return HC.forEach((i3) => {
              e3.includes(i3) && t3.push(i3);
            }), t3.concat(e3.filter((e4) => !HC.includes(e4)));
          }(i2);
        } else
          i2 = e2;
        var n2, r2;
        return i2;
      };
      function YC(e2) {
        if (!e2 && GE("AREAS").includes(SS.EXTENSIONS))
          return OE.debug("update area from ap : reset"), void qC(DE, true);
        if (!GE("AREAS").includes(SS.GLOBAL) || !e2)
          return;
        let t2 = CS.EXTENSIONS;
        t2 && (t2 = { CODE: FC(SS.EXTENSIONS), WEBCS_DOMAIN: ["ap-web-1-".concat(e2, ".agora.io")], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-".concat(e2, ".ap.sd-rtn.com")], PROXY_CS: ["proxy-ap-web-".concat(e2, ".agora.io")], CDS_AP: ["cds-ap-web-1-".concat(e2, ".agora.io"), "cds-ap-web-2-".concat(e2, ".ap.sd-rtn.com")], ACCOUNT_REGISTER: ["sua-ap-web-1-".concat(e2, ".agora.io"), "sua-ap-web-2-".concat(e2, ".ap.sd-rtn.com")], UAP_AP: ["uap-ap-web-1-".concat(e2, ".agora.io"), "uap-ap-web-2-".concat(e2, ".ap.sd-rtn.com")], EVENT_REPORT_DOMAIN: ["statscollector-1-".concat(e2, ".agora.io")], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-".concat(e2, ".agora.io")], LOG_UPLOAD_SERVER: ["logservice-".concat(e2, ".agora.io")], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy-".concat(e2, ".agora.io")] }, OE.debug("update area from ap success: ".concat(e2, ",config is "), t2), BE("AREAS", [SS.EXTENSIONS], true), Object.keys(t2).map((e3) => {
          if ("LOG_UPLOAD_SERVER" === e3 || "EVENT_REPORT_DOMAIN" === e3 || "EVENT_REPORT_BACKUP_DOMAIN" === e3 || "PROXY_SERVER_TYPE3" === e3) {
            BE(e3, t2[e3][0]);
          } else
            BE(e3, t2[e3]);
        }));
      }
      function qC(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        const i2 = Pg.reportApiInvoke(null, { name: _f.SET_AREA, options: e2, tag: Ef.TRACER });
        try {
          let n2 = [];
          if ("string" == typeof e2 && (n2 = [e2]), Array.isArray(e2) && (e2.forEach((e3) => {
            if (!RS.includes(e3))
              throw new SE(fE.INVALID_PARAMS, "invalid area code");
          }), n2 = e2), "[object Object]" === Object.prototype.toString.call(e2)) {
            const { areaCode: t3, excludedArea: i3 } = e2;
            if (!t3)
              throw new SE(fE.INVALID_PARAMS, "area code is needed");
            let r3 = t3;
            "string" == typeof t3 && (r3 = [t3]), n2 = i3 ? KC(r3, i3) : r3;
          }
          if (!t2) {
            if (HE.AREAS) {
              const e3 = new SE(fE.PROHIBITED_OPERATION, "setArea is prohibited because of config-distribute");
              return i2.onError(e3), void OE.warning("setArea is prohibited because of config-distribute");
            }
            if (n2.includes(SS.GLOBAL) && GE("AREAS") === SS.EXTENSIONS) {
              const e3 = new SE(fE.PROHIBITED_OPERATION, "setArea is prohibited because of ap extensions");
              return i2.onError(e3), void OE.warning("setArea is prohibited because of ap extensions");
            }
          }
          BE("AREAS", n2, t2);
          const r2 = BC(n2);
          Object.keys(r2).map((e3) => {
            if ("LOG_UPLOAD_SERVER" === e3 || "EVENT_REPORT_DOMAIN" === e3 || "EVENT_REPORT_BACKUP_DOMAIN" === e3 || "PROXY_SERVER_TYPE3" === e3) {
              BE(e3, r2[e3][0]);
            } else
              BE(e3, r2[e3]);
          }), OE.debug("set area success:", n2.join(","));
        } catch (e3) {
          throw i2.onError(e3), e3;
        }
        i2.onSuccess();
      }
      function JC(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function XC(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? JC(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : JC(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      let zC = 1;
      function QC(e2, t2, i2, n2, r2) {
        zC += 1;
        const o2 = { sid: i2.sid, command: "convergeAllocateEdge", uid: "666", appId: i2.appId, ts: Math.floor(Date.now() / 1e3), seq: zC, requestId: zC, version: bE, cname: i2.cname }, s2 = { service_name: t2, json_body: JSON.stringify(o2) };
        let a2, c2, d2 = e2[0];
        return RE(async () => {
          a2 = Date.now();
          const e3 = await gg(d2, { data: s2, cancelToken: n2, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" } });
          if (c2 = Date.now() - a2, 0 !== e3.code) {
            const t3 = new SE(fE.UNEXPECTED_RESPONSE, "live streaming ap error, code" + e3.code, { retry: true, responseTime: c2 });
            throw OE.error(t3.toString()), t3;
          }
          const i3 = JSON.parse(e3.json_body);
          if (200 !== i3.code) {
            const e4 = new SE(fE.UNEXPECTED_RESPONSE, "live streaming app center error, code: ".concat(i3.code, ", reason: ").concat(i3.reason), { code: i3.code, responseTime: c2 });
            throw OE.error(e4.toString()), e4;
          }
          if (!i3.servers || 0 === i3.servers.length) {
            const e4 = new SE(fE.UNEXPECTED_RESPONSE, "live streaming app center empty server", { code: i3.code, responseTime: c2 });
            throw OE.error(e4.toString()), e4;
          }
          const r3 = function(e4, t3) {
            return { addressList: e4.servers.map((e5) => "wss://".concat(e5.address.replace(/\./g, "-"), ".").concat(GE("WORKER_DOMAIN"), ":").concat(e5.wss, "?serviceName=").concat(encodeURIComponent(t3))), workerToken: e4.workerToken, vid: e4.vid };
          }(i3, t2);
          return GE("LIVE_STREAMING_ADDRESS") && (r3.addressList = GE("LIVE_STREAMING_ADDRESS") instanceof Array ? GE("LIVE_STREAMING_ADDRESS") : [GE("LIVE_STREAMING_ADDRESS")]), XC(XC({}, r3), {}, { responseTime: c2 });
        }, (n3, r3) => (Pg.apworkerEvent(i2.sid, { success: true, sc: 200, serviceName: t2, responseDetail: JSON.stringify(n3.addressList), firstSuccess: 0 === r3, responseTime: c2, serverIp: e2[r3 % e2.length] }), false), (n3, r3) => (Pg.apworkerEvent(i2.sid, { success: false, sc: n3.data && n3.data.code || 200, serviceName: t2, responseTime: c2, serverIp: e2[r3 % e2.length] }), !!(n3.code !== fE.OPERATION_ABORTED && n3.code !== fE.UNEXPECTED_RESPONSE || n3.data && n3.data.retry) && (d2 = e2[(r3 + 1) % e2.length], true)), r2);
      }
      let ZC = 1;
      function $C(e2, t2, i2, n2) {
        let { url: r2, areaCode: o2 } = e2;
        const s2 = Date.now();
        let a2;
        const [c2, d2] = rv(t2, o2, [XS.CHOOSE_SERVER]);
        let u2 = Ig.networkState;
        return RE(async () => {
          u2 && Ig.networkState === PS.OFFLINE && Ig.onlineWaiter && await Sl.race([Ig.onlineWaiter, zI(n2 && n2.maxRetryTimeout || TE.maxRetryTimeout)]), u2 = Ig.networkState;
          const { data: e3, headers: o3 } = await gg(r2, { data: c2, cancelToken: i2, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
          a2 = "1" === o3.http3 ? 1 : -1, Pg.reportResourceTiming(r2, t2.sid), tv(e3, r2, t2, s2, [XS.CHOOSE_SERVER], a2);
          const d3 = WI(e3, XS.CHOOSE_SERVER);
          return iv(d3), jI(d3, r2);
        }, (e3) => (e3 && Pg.joinChooseServer(t2.sid, { lts: s2, succ: true, csAddr: r2, opid: d2, serverList: e3.gatewayAddrs.map((e4) => e4.address), ec: null, cid: e3.cid.toString(), uid: e3.uid.toString(), csIp: e3.csIp, unilbsServerIds: [XS.CHOOSE_SERVER].toString(), isHttp3: a2 }), false), (e3) => e3.code !== fE.OPERATION_ABORTED && (e3.code === fE.CAN_NOT_GET_GATEWAY_SERVER ? e3.data.retry : (Pg.joinChooseServer(t2.sid, { lts: s2, succ: false, csAddr: r2, serverList: null, opid: d2, ec: e3.code, csIp: e3.data && e3.data.csIp, unilbsServerIds: [XS.CHOOSE_SERVER].toString(), extend: JSON.stringify({ networkState: u2 }), isHttp3: a2 }), OE.warning("[".concat(t2.clientId, "] Choose server network error, retry"), e3), true)), n2);
      }
      function ev(e2, t2, i2, n2) {
        let r2, { url: o2, areaCode: s2, serviceIds: a2 } = e2;
        const c2 = Date.now(), [d2, u2] = rv(t2, s2, a2);
        let l2 = void 0;
        return RE(async () => {
          l2 && Ig.networkState === PS.OFFLINE && Ig.onlineWaiter && await Sl.race([Ig.onlineWaiter, zI(n2 && n2.maxRetryTimeout || TE.maxRetryTimeout)]), l2 = Ig.networkState;
          const { data: e3, headers: s3 } = await gg(o2, { data: d2, cancelToken: i2, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
          r2 = "1" === s3.http3 ? 1 : -1, Pg.reportResourceTiming(o2, t2.sid), tv(e3, o2, t2, c2, a2, r2);
          const u3 = WI(e3, XS.CHOOSE_SERVER), h2 = WI(e3, "proxy5" === t2.cloudProxyServer ? XS.CLOUD_PROXY_5 : "proxy3" === t2.cloudProxyServer || "proxy4" === t2.cloudProxyServer ? XS.CLOUD_PROXY : XS.CLOUD_PROXY_FALLBACK);
          return iv(u3), { gatewayInfo: jI(u3, o2), proxyInfo: h2, url: o2 };
        }, (e3) => (e3.gatewayInfo && Pg.joinChooseServer(t2.sid, { lts: c2, succ: true, csAddr: o2, serverList: e3.gatewayInfo.gatewayAddrs.map((e4) => e4.address), ec: null, opid: u2, cid: e3.gatewayInfo.cid.toString(), uid: e3.gatewayInfo.uid.toString(), csIp: e3.gatewayInfo.csIp, unilbsServerIds: a2.toString(), isHttp3: r2 }), e3.proxyInfo && Pg.joinWebProxyAP(t2.sid, { lts: c2, sucess: 1, apServerAddr: o2, turnServerAddrList: e3.proxyInfo.addresses.map((e4) => e4.ip).join(","), errorCode: null, eventType: t2.cloudProxyServer, unilbsServerIds: a2.toString() }), false), (e3) => e3.code !== fE.OPERATION_ABORTED && (e3.code === fE.CAN_NOT_GET_GATEWAY_SERVER ? e3.data.retry : (Pg.joinWebProxyAP(t2.sid, { lts: c2, sucess: 0, apServerAddr: o2, turnServerAddrList: null, errorCode: e3.code, eventType: t2.cloudProxyServer, unilbsServerIds: a2.toString(), extend: JSON.stringify({ networkState: l2 }) }), OE.warning("[".concat(t2.clientId, "] multi unilbs network error, retry"), e3), true)), n2);
      }
      const tv = (e2, t2, i2, n2, r2, o2) => {
        const s2 = [], a2 = (s3) => {
          4096 === s3.flag ? Pg.joinChooseServer(i2.sid, { lts: n2, succ: false, csAddr: t2, opid: e2.opid, serverList: null, ec: s3.error.message, csIp: s3.error.data && s3.error.data.csIp, unilbsServerIds: r2.toString(), isHttp3: o2 }) : 1048576 !== s3.flag && 4194304 !== s3.flag && 4194310 !== s3.flag || Pg.joinWebProxyAP(i2.sid, { lts: n2, sucess: 0, apServerAddr: t2, turnServerAddrList: null, errorCode: s3.error.code, eventType: i2.cloudProxyServer, unilbsServerIds: r2.toString() });
        };
        if (e2.response_body.forEach((t3) => {
          const i3 = t3.buffer.code;
          if (23 === t3.uri && 0 === i3 && !t3.buffer.edges_services)
            if (4194310 === t3.buffer.flag)
              OE.warning("no edge services in ap response of proxy fallback, will not set proxy in iceServers"), t3.buffer.edges_services = [];
            else {
              const i4 = { error: new SE(fE.CAN_NOT_GET_GATEWAY_SERVER, "no edge services in ap response", { retry: true, csIp: e2.detail[502] }), flag: t3.buffer.flag };
              s2.push(i4), a2(i4);
            }
          if (0 !== i3) {
            const n3 = gC(i3), r3 = { error: new SE(fE.CAN_NOT_GET_GATEWAY_SERVER, n3.desc, { desc: n3.desc, retry: n3.retry, csIp: e2.detail[502] }), flag: t3.buffer.flag };
            4194310 === t3.buffer.flag ? OE.warning(r3.error.toString()) : s2.push(r3), a2(r3);
          }
        }), s2.length)
          throw OE.warning("[".concat(i2.clientId, "] multi unilbs ").concat(t2, " failed, ").concat(s2.map((e3) => "flag: ".concat(e3.flag, ", message: ").concat(e3.error.message, ", retry: ").concat(e3.error.data.retry)).join(" | "))), new SE(fE.CAN_NOT_GET_GATEWAY_SERVER, s2.map((e3) => "flag: ".concat(e3.flag, ", message: ").concat(e3.error.message)).join(" | "), { retry: !!s2.find((e3) => e3.error.data.retry), csIp: e2.detail[502], desc: [...new Set(s2.map((e3) => {
            var t3, i3;
            return null == e3 || null === (t3 = e3.error) || void 0 === t3 || null === (i3 = t3.data) || void 0 === i3 ? void 0 : i3.desc;
          }).filter((e3) => !!e3))] });
      }, iv = (e2) => {
        var t2, i2, n2, r2;
        if (e2.addresses && 0 === e2.addresses.length && 0 === e2.code)
          throw new SE(fE.CAN_NOT_GET_GATEWAY_SERVER, "void gateway address", { retry: true, csIp: e2.detail && e2.detail[502] });
        GE("AP_AREA") && (null !== (n2 = e2.detail) && void 0 !== n2 && n2[23] && "string" == typeof (null === (r2 = e2.detail) || void 0 === r2 ? void 0 : r2[23]) ? YC(e2.detail[23].toLowerCase()) : YC());
        if (null !== (t2 = e2.detail) && void 0 !== t2 && t2[19] && "string" == typeof (null === (i2 = e2.detail) || void 0 === i2 ? void 0 : i2[19])) {
          const t3 = e2.detail[19], i3 = null == t3 ? void 0 : t3.split(";");
          for (let t4 = 0; t4 < i3.length; t4++) {
            var o2;
            const n3 = mh(o2 = i3[t4]).call(o2);
            e2.addresses[t4] && i3 && (e2.addresses[t4].fingerprint = n3);
          }
        }
        if (GE("GATEWAY_ADDRESS") && GE("GATEWAY_ADDRESS").length > 0) {
          OE.debug("assign gateway address to", GE("GATEWAY_ADDRESS"));
          const t3 = GE("GATEWAY_ADDRESS").map((t4) => {
            var i3, n3;
            const r3 = null !== (i3 = null === (n3 = e2.addresses.find((e3) => e3.ip === t4.ip && e3.port === t4.port)) || void 0 === n3 ? void 0 : n3.fingerprint) && void 0 !== i3 ? i3 : "";
            return { ip: t4.ip, port: t4.port, ticket: e2.addresses[0] && e2.addresses[0].ticket, fingerprint: r3 };
          });
          e2.addresses = t3;
        }
      }, nv = (e2, t2) => {
        if (e2.response_body && e2.response_body.length) {
          const t3 = e2.response_body[0];
          if (0 !== t3.buffer.code) {
            const e3 = gC(t3.buffer.code);
            throw new SE(fE.UPDATE_TICKET_FAILED, "[".concat(t3.buffer.code, "]: ").concat(e3.desc), { retry: e3.retry });
          }
          return t3.buffer.ticket;
        }
        throw OE.debug("update ticket request received ap response without response body:", t2), new SE(fE.UPDATE_TICKET_FAILED, "cannot find response body from ap response", { retry: false });
      }, rv = (e2, t2, i2) => {
        const n2 = Math.floor(Math.random() * 10 ** 12), r2 = { appid: e2.appId, client_ts: Date.now(), opid: n2, sid: e2.sid, request_bodies: [{ uri: 22, buffer: { cname: e2.cname, detail: { 6: e2.stringUid, 11: t2, 12: GE("USE_NEW_TOKEN") ? "1" : void 0, 22: t2 }, key: e2.token, service_ids: i2, uid: e2.uid || 0 } }] };
        r2.request_bodies.forEach((t3) => {
          e2.multiIP && e2.multiIP.gateway_ip && (t3.buffer.detail[5] = JSON.stringify({ vocs_ip: [e2.multiIP.uni_lbs_ip], vos_ip: [e2.multiIP.gateway_ip] }));
        });
        const o2 = new FormData();
        return o2.append("request", JSON.stringify(r2)), [o2, n2];
      }, ov = (e2, t2) => {
        const i2 = Math.floor(Math.random() * 10 ** 12), n2 = { appid: e2.appId, client_ts: Date.now(), opid: i2, sid: e2.sid, request_bodies: [{ uri: 28, buffer: { cname: e2.cname, detail: { 1: "", 6: e2.stringUid, 12: "1" }, token: e2.token, service_ids: t2, uid: e2.uid || 0, edges_services: e2.apResponse.addresses.map((e3) => ({ ip: e3.ip, port: e3.port })) } }] }, r2 = new FormData();
        return r2.append("request", JSON.stringify(n2)), [r2, i2];
      };
      let sv = 0;
      async function av(e2, t2, i2, n2) {
        const r2 = async function(e3, t3, i3, n3) {
          let r3 = null;
          const o2 = [], s2 = async () => {
            const r4 = GE("WEBCS_DOMAIN").slice(0, GE("AJAX_REQUEST_CONCURRENT")).map((t4) => ({ url: e3.proxyServer ? "https://".concat(e3.proxyServer, "/ap/?url=").concat(t4 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t4, "/api/v2/transpond/webrtc?v=2"), areaCode: jC() })), s3 = n3.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r4.map((e4) => e4.url) }), a3 = await fC({ fragementLength: GE("FRAGEMENT_LENGTH"), referenceList: r4, asyncMapHandler: (n4) => (OE.debug("[".concat(e3.clientId, "] Connect to choose_server:"), n4.url), $C(n4, e3, t3, i3)), allFailedhandler: (e4) => {
              throw n3.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e4 }, s3), e4[0];
            }, promisesCollector: o2 });
            return n3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, s3), a3;
          }, a2 = async () => {
            if (await zI(1e3), null !== r3)
              return r3;
            const s3 = GE("WEBCS_DOMAIN_BACKUP_LIST").map((t4) => ({ url: e3.proxyServer ? "https://".concat(e3.proxyServer, "/ap/?url=").concat(t4 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t4, "/api/v2/transpond/webrtc?v=2"), areaCode: jC() })), a3 = n3.recordJoinChannelService({ endTs: void 0, startTs: Date.now(), status: "pending", service: "chooseServer", urls: s3.map((e4) => e4.url) }), c2 = await fC({ fragementLength: GE("FRAGEMENT_LENGTH"), referenceList: s3, asyncMapHandler: (n4) => (OE.debug("[".concat(e3.clientId, "] Connect to backup choose_server:"), n4.url), $C(n4, e3, t3, i3)), allFailedhandler: (e4) => {
              throw n3.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e4 }, a3), e4[0];
            }, promisesCollector: o2 });
            return n3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a3), c2;
          };
          try {
            return r3 = await iC([s2(), a2()]), o2.length && o2.forEach((e4) => e4.cancel && "function" == typeof e4.cancel && e4.cancel()), r3;
          } catch (e4) {
            throw e4[0];
          }
        }(e2, t2, i2, n2);
        return { gatewayInfo: await r2 };
      }
      async function cv(e2, t2, i2, n2, r2) {
        const o2 = e2.cloudProxyServer;
        if ("disabled" === o2) {
          if (!n2)
            return;
          if (e2.useLocalAccessPoint)
            return await av(e2, t2, i2, r2);
          if (GE("JOIN_WITH_FALLBACK_MEDIA_PROXY")) {
            const { gatewayInfo: n3, proxyInfo: o3 } = await lv(e2, t2, i2, r2);
            return e2.turnServer && "auto" !== e2.turnServer.mode || (e2.turnServer = { mode: "manual", servers: o3.map((e3) => ({ turnServerURL: e3.address, tcpport: e3.tcpport || PE.tcpport, udpport: e3.udpport || PE.udpport, username: e3.username || PE.username, password: e3.password || PE.password, forceturn: false, security: true })) }), { gatewayInfo: n3 };
          }
          return await av(e2, t2, i2, r2);
        }
        const { proxyInfo: s2, gatewayInfo: a2 } = await lv(e2, t2, i2, r2), c2 = { gatewayInfo: a2 };
        return e2.turnServer = { mode: "manual", servers: s2.map((e3) => ({ turnServerURL: e3.address, tcpport: "proxy3" === o2 ? void 0 : e3.tcpport ? e3.tcpport : PE.tcpport, udpport: "proxy4" === o2 ? void 0 : e3.udpport ? e3.udpport : PE.udpport, username: e3.username || PE.username, password: e3.password || PE.password, forceturn: "proxy4" !== o2, security: "proxy5" === o2 })) }, OE.debug("[".concat(e2.clientId, "] set proxy server: ").concat(e2.proxyServer, ", mode: ").concat(o2)), c2;
      }
      async function dv(e2, t2, i2, n2, r2) {
        const o2 = GE("ACCOUNT_REGISTER").slice(0, GE("AJAX_REQUEST_CONCURRENT"));
        let s2 = [];
        s2 = t2.proxyServer ? o2.map((e3) => "https://".concat(t2.proxyServer, "/ap/?url=").concat(e3 + "/api/v1")) : o2.map((e3) => "https://".concat(e3, "/api/v1"));
        const a2 = null == r2 ? void 0 : r2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "stringUID", urls: s2 });
        try {
          const o3 = await async function(e3, t3, i3, n3, r3) {
            const o4 = Date.now(), s3 = { sid: i3.sid, opid: 10, appid: i3.appId, string_uid: t3 };
            let a3 = e3[0];
            const c2 = await RE(() => gg(a3 + "".concat(-1 === a3.indexOf("?") ? "?" : "&", "action=stringuid"), { data: s3, cancelToken: n3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 72 } }), (i4, n4) => {
              if (0 === i4.code) {
                if (i4.uid <= 0 || i4.uid >= Math.pow(2, 32))
                  throw OE.error("Invalid Uint Uid ".concat(t3, " => ").concat(i4.uid), i4), Pg.reqUserAccount(s3.sid, { lts: o4, success: false, serverAddr: a3, stringUid: s3.string_uid, uid: i4.uid, errorCode: fE.INVALID_UINT_UID_FROM_STRING_UID, extend: s3 }), new SE(fE.INVALID_UINT_UID_FROM_STRING_UID);
                return Pg.reqUserAccount(s3.sid, { lts: o4, success: true, serverAddr: a3, stringUid: s3.string_uid, uid: i4.uid, errorCode: null, extend: s3 }), false;
              }
              const r4 = gC(i4.code);
              return r4.retry && (a3 = e3[(n4 + 1) % e3.length]), Pg.reqUserAccount(s3.sid, { lts: o4, success: false, serverAddr: a3, stringUid: s3.string_uid, uid: i4.uid, errorCode: r4.desc, extend: s3 }), r4.retry;
            }, (t4, i4) => t4.code !== fE.OPERATION_ABORTED && (Pg.reqUserAccount(s3.sid, { lts: o4, success: false, serverAddr: a3, stringUid: s3.string_uid, uid: null, errorCode: t4.code, extend: s3 }), a3 = e3[(i4 + 1) % e3.length], true), r3);
            if (0 !== c2.code) {
              const e4 = gC(c2.code);
              throw new SE(fE.UNEXPECTED_RESPONSE, e4.desc);
            }
            return c2;
          }(s2, e2, t2, i2, n2);
          return null == r2 || r2.recordJoinChannelService({ status: "success", endTs: Date.now() }, a2), o3.uid;
        } catch (e3) {
          throw null == r2 || r2.recordJoinChannelService({ status: "error", endTs: Date.now(), errors: [e3] }, a2), e3;
        }
      }
      async function uv(e2, t2, i2) {
        const n2 = GE("CDS_AP").slice(0, GE("AJAX_REQUEST_CONCURRENT")).map((t3) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t3 + "/api/v1") : "https://".concat(t3, "/api/v1?action=config")).map((n3) => function(e3, t3, i3, n4) {
          const r3 = xh(), o3 = { flag: 64, cipher_method: 0, features: { device: r3.name, system: r3.os, system_general: navigator.userAgent, vendor: t3.appId, version: bE, cname: t3.cname, sid: t3.sid, session_id: t3.sid, detail: "", proxyServer: t3.proxyServer } };
          return RE(() => gg(e3, { data: o3, timeout: 1e3, cancelToken: i3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 54 } }), void 0, (e4) => e4.code !== fE.OPERATION_ABORTED, n4);
        }(n3, e2, t2, i2));
        let r2 = null, o2 = null, s2 = {};
        try {
          r2 = await iC(n2);
        } catch (e3) {
          if (e3.code === fE.OPERATION_ABORTED)
            throw e3;
          o2 = e3;
        }
        n2.forEach((e3) => e3.cancel());
        if (Pg.reportApiInvoke(e2.sid, { name: _f.REQUEST_CONFIG_DISTRIBUTE, options: { error: o2, res: r2 } }).onSuccess(), r2 && r2.test_tags)
          try {
            s2 = function(e3) {
              if (!e3.test_tags)
                return {};
              const t3 = e3.test_tags, i3 = Object.keys(t3), n3 = {};
              return i3.forEach((e4) => {
                var i4;
                const r3 = mh(i4 = e4.slice(4)).call(i4), o3 = JSON.parse(t3[e4])[1];
                n3[r3] = o3;
              }), n3;
            }(r2);
          } catch (e3) {
          }
        return s2;
      }
      async function lv(e2, t2, i2, n2) {
        const r2 = GE("PROXY_SERVER_TYPE3"), o2 = (e3, t3, i3) => {
          let n3 = i3 || r2;
          return Array.isArray(n3) && (n3 = t3 % 2 == 0 ? r2[1] : r2[0]), "https://".concat(n3, "/ap/?url=").concat(e3);
        };
        let s2 = null;
        const a2 = [], c2 = async () => {
          const r3 = GE("WEBCS_DOMAIN").slice(0, GE("AJAX_REQUEST_CONCURRENT")).map((t3, i3) => {
            let n3;
            return n3 = "disabled" === e2.cloudProxyServer && e2.proxyServer ? o2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i3, e2.proxyServer) : "disabled" === e2.cloudProxyServer || "fallback" === e2.cloudProxyServer ? "https://".concat(t3, "/api/v2/transpond/webrtc?v=2") : o2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i3), { url: n3, areaCode: jC(), serviceIds: [XS.CHOOSE_SERVER, "proxy5" === e2.cloudProxyServer ? XS.CLOUD_PROXY_5 : "proxy3" === e2.cloudProxyServer || "proxy4" === e2.cloudProxyServer ? XS.CLOUD_PROXY : XS.CLOUD_PROXY_FALLBACK] };
          }), s3 = n2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r3.map((e3) => e3.url) }), c3 = await fC({ fragementLength: GE("FRAGEMENT_LENGTH"), referenceList: r3, asyncMapHandler: (n3) => (OE.debug("[".concat(e2.clientId, "] Connect to choose_server:"), n3.url), ev(n3, e2, t2, i2)), allFailedhandler: (e3) => {
            throw n2.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e3 }, s3), e3[0];
          }, promisesCollector: a2 });
          return n2.recordJoinChannelService({ endTs: Date.now(), status: "success" }, s3), c3;
        }, d2 = async () => {
          if (await zI(1e3), null !== s2)
            return s2;
          const r3 = GE("WEBCS_DOMAIN_BACKUP_LIST").map((t3, i3) => {
            let n3;
            return n3 = "disabled" === e2.cloudProxyServer && e2.proxyServer ? o2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i3, e2.proxyServer) : "disabled" === e2.cloudProxyServer || "fallback" === e2.cloudProxyServer ? "https://".concat(t3, "/api/v2/transpond/webrtc?v=2") : o2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i3), { url: n3, areaCode: jC(), serviceIds: [XS.CHOOSE_SERVER, "proxy5" === e2.cloudProxyServer ? XS.CLOUD_PROXY_5 : "proxy3" === e2.cloudProxyServer || "proxy4" === e2.cloudProxyServer ? XS.CLOUD_PROXY : XS.CLOUD_PROXY_FALLBACK] };
          }), c3 = n2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r3.map((e3) => e3.url) }), d3 = await fC({ fragementLength: GE("FRAGEMENT_LENGTH"), referenceList: r3, asyncMapHandler: (n3) => (OE.debug("[".concat(e2.clientId, "] Connect to backup choose_server:"), n3.url), ev(n3, e2, t2, i2)), allFailedhandler: (e3) => {
            throw n2.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e3 }, c3), e3[0];
          }, promisesCollector: a2 });
          return n2.recordJoinChannelService({ endTs: Date.now(), status: "success" }, c3), d3;
        };
        let u2, l2, h2;
        try {
          ({ gatewayInfo: u2, proxyInfo: l2, url: h2 } = await iC([c2(), d2()]));
        } catch (e3) {
          throw e3[0];
        }
        if (a2.length && a2.forEach((e3) => e3.cancel && "function" == typeof e3.cancel && e3.cancel()), !u2 || !l2)
          throw new SE(fE.UNEXPECTED_ERROR, "missing gateway or proxy response").print();
        if (e2.apUrl = h2, "disabled" !== e2.cloudProxyServer && Array.isArray(r2) && h2) {
          const t3 = /^https?:\/\/(.+?)(\/.*)?$/.exec(h2)[1];
          r2.includes(t3) && (e2.proxyServer = t3, OE.setProxyServer(t3), Pg.setProxyServer(t3));
        }
        return s2 = { gatewayInfo: u2, proxyInfo: await HI(l2, u2.uid) }, s2;
      }
      async function hv(e2, t2, i2, n2) {
        const r2 = GE("UAP_AP").slice(0, GE("AJAX_REQUEST_CONCURRENT")).map((e3) => t2.proxyServer ? "https://".concat(t2.proxyServer, "/ap/?url=").concat(e3 + "/api/v1?action=uap") : "https://".concat(e3, "/api/v1?action=uap"));
        return await QC(r2, e2, t2, i2, n2);
      }
      async function pv(e2, t2, i2) {
        const n2 = GE("UAP_AP").slice(0, GE("AJAX_REQUEST_CONCURRENT")).map((t3) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t3 + "/api/v1?action=uap") : "https://".concat(t3, "/api/v1?action=uap")).map((n3) => function(e3, t3, i3, n4) {
          const r2 = { command: "convergeAllocateEdge", sid: t3.sid, appId: t3.appId, token: t3.token, ts: Date.now(), version: bE, cname: t3.cname, uid: t3.uid.toString(), requestId: ZC, seq: ZC };
          ZC += 1;
          const o2 = { service_name: "tele_channel", json_body: JSON.stringify(r2) };
          return RE(async () => {
            const t4 = await gg(e3, { data: o2, cancelToken: i3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 61 } });
            if (0 !== t4.code) {
              const e4 = new SE(fE.UNEXPECTED_RESPONSE, "cross channel ap error, code" + t4.code, { retry: true });
              throw OE.error(e4.toString()), e4;
            }
            const n5 = JSON.parse(t4.json_body);
            if (200 !== n5.code) {
              const e4 = new SE(fE.UNEXPECTED_RESPONSE, "cross channel app center error, code: ".concat(n5.code, ", reason: ").concat(n5.reason));
              throw OE.error(e4.toString()), e4;
            }
            if (!n5.servers || 0 === n5.servers.length) {
              const e4 = new SE(fE.UNEXPECTED_RESPONSE, "cross channel app center empty server");
              throw OE.error(e4.toString()), e4;
            }
            return { vid: n5.vid, workerToken: n5.workerToken, addressList: (GE("CHANNEL_MEDIA_RELAY_SERVERS") || n5.servers).map((e4) => "wss://".concat(e4.address.replace(/\./g, "-"), ".").concat(GE("WORKER_DOMAIN"), ":").concat(e4.wss)) };
          }, void 0, (e4) => !!(e4.code !== fE.OPERATION_ABORTED && e4.code !== fE.UNEXPECTED_RESPONSE || e4.data && e4.data.retry), n4);
        }(n3, e2, t2, i2));
        try {
          const e3 = await iC(n2);
          return n2.forEach((e4) => e4.cancel()), e3;
        } catch (e3) {
          throw e3[0];
        }
      }
      async function _v(e2, t2, i2) {
        let n2 = null;
        const r2 = [], o2 = async (o3) => {
          const s2 = GE(o3 ? "WEBCS_DOMAIN_BACKUP_LIST" : "WEBCS_DOMAIN").map((t3) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t3 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t3, "/api/v2/transpond/webrtc?v=2"));
          return o3 && (await zI(1e3), null !== n2) ? n2 : await fC({ fragementLength: GE("FRAGEMENT_LENGTH"), referenceList: s2, asyncMapHandler: (n3) => (OE.debug("[".concat(e2.clientId, "] update ticket, Connect to ").concat(o3 ? "backup" : "", " choose_server:"), n3), function(e3, t3, i3, n4) {
            const [r3] = ov(t3, [XS.CHOOSE_SERVER]);
            let o4 = Ig.networkState;
            return RE(async () => {
              o4 && Ig.networkState === PS.OFFLINE && Ig.onlineWaiter && await Sl.race([Ig.onlineWaiter, zI(n4 && n4.maxRetryTimeout || TE.maxRetryTimeout)]), o4 = Ig.networkState;
              const t4 = await gg(e3, { data: r3, cancelToken: i3, headers: { "Content-Type": "multipart/form-data;" } }, true);
              return nv(t4, e3);
            }, () => false, (e4) => e4.code !== fE.OPERATION_ABORTED && (e4.code === fE.UPDATE_TICKET_FAILED ? e4.data.retry : (OE.warning("[".concat(t3.clientId, "] update ticket network error, retry"), e4), true)), n4);
          }(n3, e2, t2, i2)), allFailedhandler: (e3) => {
            throw e3[0];
          }, promisesCollector: r2 });
        };
        try {
          return n2 = await iC([o2(false), o2(true)]), r2.length && r2.forEach((e3) => e3.cancel && "function" == typeof e3.cancel && e3.cancel()), n2;
        } catch (e3) {
          throw e3[0];
        }
      }
      function Ev(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function mv(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Ev(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : Ev(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class fv extends EE {
        constructor() {
          super(), _p(this, "configs", void 0), _p(this, "joinInfo", void 0), _p(this, "cancelToken", void 0), _p(this, "retryConfig", { timeout: 3e3, timeoutFactor: 1.5, maxRetryCount: 1, maxRetryTimeout: 1e4 }), _p(this, "interval", void 0), _p(this, "mutex", new Ug("config-distribute")), _p(this, "mutableParamsRead", false);
        }
        startGetConfigDistribute(e2, t2) {
          this.joinInfo = e2, this.cancelToken = t2, this.interval && this.stopGetConfigDistribute(), GE("ENABLE_CONFIG_DISTRIBUTE") && (this.updateConfigDistribute(), this.interval = window.setInterval(() => {
            this.updateConfigDistribute();
          }, GE("CONFIG_DISTRIBUTE_INTERVAL")));
        }
        stopGetConfigDistribute() {
          this.interval && clearInterval(this.interval), this.interval = void 0, this.joinInfo = void 0, this.cancelToken = void 0;
        }
        async awaitConfigDistributeComplete() {
          if (!this.mutex.isLocked)
            return;
          (await this.mutex.lock())();
        }
        async updateConfigDistribute() {
          if (!this.mutableParamsRead) {
            this.mutableParamsRead = true;
            Pg.reportApiInvoke(null, { options: void 0, name: _f.LOAD_CONFIG_FROM_LOCALSTORAGE, tag: Ef.TRACER }).onSuccess(JSON.stringify(HE));
          }
          if (!this.joinInfo || !this.cancelToken || !this.retryConfig)
            return void OE.debug("[config-distribute] get config distribute interrupted have no joininfo");
          let e2;
          const t2 = await this.mutex.lock();
          try {
            e2 = await uv(this.joinInfo, this.cancelToken, this.retryConfig), OE.debug("[config-distribute] get config distribute", JSON.stringify(e2)), e2.limit_bitrate && this.handleBitrateLimit(e2.limit_bitrate), this.cacheGlobalParameterConfig(e2), this.configs = e2;
          } catch (e3) {
            const t3 = new SE(fE.NETWORK_RESPONSE_ERROR, e3);
            OE.warning("[config-distribute] ".concat(t3.toString()));
          } finally {
            t2();
          }
        }
        getBitrateLimit() {
          return this.configs ? this.configs.limit_bitrate : void 0;
        }
        handleBitrateLimit(e2) {
          var t2;
          (t2 = e2) && t2.uplink && t2.id && void 0 !== t2.uplink.max_bitrate && void 0 !== t2.uplink.min_bitrate && (this.configs && this.configs.limit_bitrate ? this.configs && this.configs.limit_bitrate && this.configs.limit_bitrate.id !== e2.id && this.emit(vS.UPDATE_BITRATE_LIMIT, e2) : this.emit(vS.UPDATE_BITRATE_LIMIT, e2));
        }
        getLowStreamConfigDistribute() {
          return this.configs && this.configs.limit_bitrate && mv({}, this.configs.limit_bitrate.low_stream_uplink);
        }
        cacheGlobalParameterConfig(e2) {
          var t2;
          const i2 = Hm(t2 = Object.keys(e2).filter((e3) => /^webrtc_ng_global_parameter/.test(e3))).call(t2);
          for (let t3 = 0; t3 < i2.length; t3++)
            for (let n3 = i2.length - 1; n3 > t3; n3--) {
              const t4 = i2[n3];
              if ("number" == typeof e2[t4].__priority) {
                const r2 = e2[t4].__priority, o2 = i2[n3 - 1];
                if ("number" == typeof e2[o2].__priority) {
                  if (!(r2 > e2[o2].__priority))
                    continue;
                  {
                    const e3 = t4;
                    i2[n3] = i2[n3 - 1], i2[n3 - 1] = e3;
                  }
                } else {
                  const e3 = t4;
                  i2[n3] = i2[n3 - 1], i2[n3 - 1] = e3;
                }
              }
            }
          const n2 = {};
          i2.forEach((t3) => {
            const i3 = e2[t3], r2 = i3.__expires;
            Object.keys(i3).forEach((e3) => {
              "__priority" === e3 || "__expires" === e3 || Object.prototype.hasOwnProperty.call(n2, e3) || (n2[e3] = mv({ value: i3[e3] }, r2 && { expires: r2 }));
            });
          });
          try {
            const e3 = JSON.stringify(n2), t3 = window.btoa(e3);
            window.localStorage.setItem("websdk_ng_global_parameter", t3), OE.debug("Caching global parameters ".concat(e3));
          } catch (e3) {
            OE.error("Error caching global parameters:", e3.message);
          }
        }
      }
      function Sv(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function Tv(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Sv(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : Sv(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class gv extends EE {
        constructor(e2, t2, i2, n2) {
          super(), _p(this, "spec", void 0), _p(this, "token", void 0), _p(this, "websocket", void 0), _p(this, "pingpongTimer", void 0), _p(this, "reconnectMode", "retry"), _p(this, "serviceMode", void 0), _p(this, "reqId", 0), _p(this, "commandReqId", 0), _p(this, "handleWebSocketOpen", () => {
            this.reconnectMode = "retry", this.startPingPong();
          }), _p(this, "handleWebSocketMessage", (e3) => {
            if (!e3.data)
              return;
            const t3 = JSON.parse(e3.data);
            t3.requestId ? this.emit("@".concat(t3.requestId, "-").concat(t3.sid), t3) : this.serviceMode === Kf.INJECT ? this.emit(Zf.INJECT_STREAM_STATUS, t3) : (Pg.workerEvent(this.spec.sid, { actionType: "status", serverCode: t3.code, workerType: this.serviceMode === Kf.TRANSCODE ? 1 : 2 }), this.emit(Zf.PUBLISH_STREAM_STATUS, t3));
          }), this.spec = t2, this.token = e2, this.serviceMode = n2, this.websocket = new vC("live-streaming", i2), this.websocket.on(Hf.CONNECTED, this.handleWebSocketOpen), this.websocket.on(Hf.ON_MESSAGE, this.handleWebSocketMessage), this.websocket.on(Hf.REQUEST_NEW_URLS, (e3, t3) => {
            nC(this, Zf.REQUEST_NEW_ADDRESS).then(e3).catch(t3);
          }), this.websocket.on(Hf.RECONNECTING, () => {
            this.websocket.reconnectMode = this.reconnectMode;
          });
        }
        init(e2) {
          return this.websocket.init(e2);
        }
        async request(e2, t2, i2, n2) {
          this.reqId += 1, "request" === e2 && (this.commandReqId += 1);
          const r2 = this.commandReqId, o2 = this.reqId;
          if (!o2 || !this.websocket)
            throw new SE(fE.UNEXPECTED_ERROR);
          const s2 = Tv({ command: e2, sdkVersion: "4.18.2" === bE ? "0.0.1" : bE, seq: o2, requestId: o2, allocate: i2, cname: this.spec.cname, appId: this.spec.appId, sid: this.spec.sid, uid: this.spec.uid.toString(), ts: Math.floor(Date.now() / 1e3) }, t2);
          if ("closed" === this.websocket.state)
            throw new SE(fE.WS_DISCONNECT);
          const a2 = () => new Sl((e3, t3) => {
            this.websocket.once(Hf.CLOSED, () => t3(new SE(fE.WS_ABORT))), this.websocket.once(Hf.CONNECTED, e3);
          });
          "connected" !== this.websocket.state && await a2(), s2.clientRequest && (s2.clientRequest.workerToken = this.token);
          const c2 = new Sl((e3, t3) => {
            const i3 = () => {
              t3(new SE(fE.WS_ABORT));
            };
            this.websocket.once(Hf.RECONNECTING, i3), this.websocket.once(Hf.CLOSED, i3), this.once("@".concat(o2, "-").concat(this.spec.sid), (t4) => {
              e3(t4);
            });
          });
          n2 && Pg.workerEvent(this.spec.sid, Tv(Tv({}, n2), {}, { requestId: r2, actionType: "request", payload: JSON.stringify(t2.clientRequest), serverCode: 0, code: 0 }));
          const d2 = Date.now();
          this.websocket.sendMessage(s2);
          let u2 = null;
          try {
            u2 = await c2;
          } catch (n3) {
            if ("closed" === this.websocket.state)
              throw n3;
            return await a2(), await this.request(e2, t2, i2);
          }
          return n2 && Pg.workerEvent(this.spec.sid, Tv(Tv({}, n2), {}, { requestId: r2, actionType: "response", payload: JSON.stringify(u2.serverResponse), serverCode: u2.code, success: 200 === u2.code, responseTime: Date.now() - d2 })), 200 !== u2.code && this.handleResponseError(u2), u2;
        }
        tryNextAddress() {
          this.reconnectMode = "tryNext", this.websocket.reconnect("tryNext");
        }
        close() {
          const e2 = "4.18.2" === bE ? "0.0.1" : bE;
          this.reqId += 1, "connected" === this.websocket.state ? (this.websocket.sendMessage({ command: "request", appId: this.spec.appId, cname: this.spec.cname, uid: this.spec.uid.toString(), sdkVersion: e2, sid: this.spec.sid, seq: this.reqId, ts: Math.floor(Date.now() / 1e3), requestId: this.reqId, clientRequest: { command: "DestroyWorker" } }), this.websocket.close(false, true)) : this.websocket.close(false), this.pingpongTimer && (window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0);
        }
        handleResponseError(e2) {
          switch (e2.code) {
            case eS.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM:
              return void OE.warning("live stream response already exists stream");
            case eS.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR:
            case eS.LIVE_STREAM_RESPONSE_BAD_STREAM:
            case eS.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR:
              return new SE(fE.LIVE_STREAMING_INVALID_ARGUMENT, "", { code: e2.code }).throw();
            case eS.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST:
              if ("UnpublishStream" === e2.serverResponse.command || "UninjectStream" === e2.serverResponse.command)
                return;
              throw new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: true });
            case eS.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED:
              return new SE(fE.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED, "", { code: e2.code }).throw();
            case eS.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
              const t2 = new SE(fE.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE);
              return this.emit(Zf.WARNING, t2, e2.serverResponse.url);
            }
            case eS.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN: {
              const t2 = new SE(fE.LIVE_STREAMING_WARN_FREQUENT_REQUEST);
              return this.emit(Zf.WARNING, t2, e2.serverResponse.url);
            }
            case eS.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH:
              throw new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: true });
            case eS.LIVE_STREAM_RESPONSE_NOT_SUPPORTED:
              return new SE(fE.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED, "", { code: e2.code }).throw();
            case eS.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM: {
              const t2 = new SE(fE.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT);
              return this.emit(Zf.WARNING, t2, e2.serverResponse.url);
            }
            case eS.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR:
              return new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e2.code }).throw();
            case eS.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT:
              throw new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream resource limit", { retry: true, changeAddress: true });
            case eS.LIVE_STREAM_RESPONSE_WORKER_LOST:
            case eS.LIVE_STREAM_RESPONSE_WORKER_QUIT:
              if ("UnpublishStream" === e2.serverResponse.command || "UninjectStream" === e2.serverResponse.command)
                return;
              throw new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: true, changeAddress: true });
            case eS.ERROR_FAIL_SEND_MESSAGE:
              if ("UnpublishStream" === e2.serverResponse.command || "UninjectStream" === e2.serverResponse.command)
                return;
              if ("UpdateTranscoding" === e2.serverResponse.command || "ControlStream" === e2.serverResponse.command)
                return new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { code: e2.code }).throw();
              throw new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: true, changeAddress: true });
            case eS.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
            case eS.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
            case eS.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
            case eS.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:
              return new SE(fE.LIVE_STREAMING_CDN_ERROR, "", { code: e2.code }).throw();
          }
        }
        startPingPong() {
          this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(() => {
            "connected" === this.websocket.state && this.request("ping", {}).catch(eC);
          }, 6e3);
        }
      }
      function Rv(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function Iv(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Rv(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : Rv(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class Cv extends EE {
        constructor(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : TE, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : TE;
          super(), _p(this, "onLiveStreamWarning", void 0), _p(this, "onLiveStreamError", void 0), _p(this, "onInjectStatusChange", void 0), _p(this, "spec", void 0), _p(this, "retryTimeout", 1e4), _p(this, "connection", void 0), _p(this, "httpRetryConfig", void 0), _p(this, "wsRetryConfig", void 0), _p(this, "streamingTasks", /* @__PURE__ */ new Map()), _p(this, "isStartingStreamingTask", false), _p(this, "taskMutex", new Ug("live-streaming")), _p(this, "cancelToken", pE.CancelToken.source()), _p(this, "transcodingConfig", void 0), _p(this, "injectConfig", Iv({}, Qf)), _p(this, "injectLoopTimes", 0), _p(this, "uapResponse", void 0), _p(this, "lastTaskId", 1), _p(this, "statusError", /* @__PURE__ */ new Map()), this.spec = e2, this.httpRetryConfig = i2, this.wsRetryConfig = t2;
        }
        async setTranscodingConfig(e2) {
          const t2 = Iv(Iv({}, zf), e2);
          66 !== t2.videoCodecProfile && 77 !== t2.videoCodecProfile && 100 !== t2.videoCodecProfile && (OE.debug("[".concat(this.spec.clientId, "] set transcoding config, fix video codec profile: ").concat(t2.videoCodecProfile, " -> 100")), t2.videoCodecProfile = 100), t2.transcodingUsers || (t2.transcodingUsers = t2.userConfigs), t2.transcodingUsers && (t2.transcodingUsers = t2.transcodingUsers.map((e3) => Iv(Iv(Iv({}, qf), e3), {}, { zOrder: e3.zOrder ? e3.zOrder + 1 : 1 }))), function(e3) {
            $m(e3.width) || qm(e3.width, "config.width", 0, 1e4), $m(e3.height) || qm(e3.height, "config.height", 0, 1e4), $m(e3.videoBitrate) || qm(e3.videoBitrate, "config.videoBitrate", 1, 1e6), $m(e3.videoFrameRate) || qm(e3.videoFrameRate, "config.videoFrameRate"), $m(e3.lowLatency) || Km(e3.lowLatency, "config.lowLatency"), $m(e3.audioSampleRate) || Ym(e3.audioSampleRate, "config.audioSampleRate", [32e3, 44100, 48e3]), $m(e3.audioBitrate) || qm(e3.audioBitrate, "config.audioBitrate", 1, 128), $m(e3.audioChannels) || Ym(e3.audioChannels, "config.audioChannels", [1, 2, 3, 4, 5]), $m(e3.videoGop) || qm(e3.videoGop, "config.videoGop"), $m(e3.videoCodecProfile) || Ym(e3.videoCodecProfile, "config.videoCodecProfile", [66, 77, 100]), $m(e3.userCount) || qm(e3.userCount, "config.userCount", 0, 17), $m(e3.backgroundColor) || qm(e3.backgroundColor, "config.backgroundColor", 0, 16777215), $m(e3.userConfigExtraInfo) || Xm(e3.userConfigExtraInfo, "config.userConfigExtraInfo", 0, 4096, false), e3.transcodingUsers && !$m(e3.transcodingUsers) && (zm(e3.transcodingUsers, "config.transcodingUsers"), e3.transcodingUsers.forEach((e4, t3) => {
              Zm(e4.uid), $m(e4.x) || qm(e4.x, "transcodingUser[".concat(t3, "].x"), 0, 1e4), $m(e4.y) || qm(e4.y, "transcodingUser[".concat(t3, "].y"), 0, 1e4), $m(e4.width) || qm(e4.width, "transcodingUser[".concat(t3, "].width"), 0, 1e4), $m(e4.height) || qm(e4.height, "transcodingUser[".concat(t3, "].height"), 0, 1e4), $m(e4.zOrder) || qm(e4.zOrder - 1, "transcodingUser[".concat(t3, "].zOrder"), 0, 100), $m(e4.alpha) || qm(e4.alpha, "transcodingUser[".concat(t3, "].alpha"), 0, 1, false);
            })), $m(e3.watermark) || Xf(e3.watermark, "watermark"), $m(e3.backgroundImage) || Xf(e3.backgroundImage, "backgroundImage"), e3.images && !$m(e3.images) && (zm(e3.images, "config.images"), e3.images.forEach((e4, t3) => {
              Xf(e4, "images[".concat(t3, "]"));
            }));
          }(t2);
          const i2 = [];
          t2.images && i2.push(...t2.images.map((e3) => Iv(Iv(Iv({}, Jf), e3), {}, { zOrder: 255 }))), t2.backgroundImage && (i2.push(Iv(Iv(Iv({}, Jf), t2.backgroundImage), {}, { zOrder: 0 })), delete t2.backgroundImage), t2.watermark && (i2.push(Iv(Iv(Iv({}, Jf), t2.watermark), {}, { zOrder: 255 })), delete t2.watermark), t2.images = i2, t2.transcodingUsers && (t2.userConfigs = t2.transcodingUsers.map((e3) => Iv({}, e3)), t2.userCount = t2.transcodingUsers.length, delete t2.transcodingUsers);
          const n2 = (t2.userConfigs || []).map((e3) => "number" == typeof e3.uid ? Sl.resolve(e3.uid) : dv(e3.uid, this.spec, this.cancelToken.token, this.httpRetryConfig));
          if ((await Sl.all(n2)).forEach((e3, i3) => {
            t2.userConfigs && t2.userConfigs[i3] && (t2.userConfigs[i3].uid = e3);
          }), this.transcodingConfig = t2, this.connection)
            try {
              var r2;
              const e3 = await this.connection.request("request", { clientRequest: { command: "UpdateTranscoding", transcodingConfig: this.transcodingConfig } }, false, { command: "UpdateTranscoding", workerType: 1, requestByUser: true, tid: Array.from(IR(r2 = this.streamingTasks).call(r2)).map((e4) => e4.taskId).join("#") });
              OE.debug("[".concat(this.spec.clientId, "] update live transcoding config success, code: ").concat(e3.code, ", config:"), JSON.stringify(this.transcodingConfig));
            } catch (e3) {
              if (!e3.data || !e3.data.retry)
                throw e3;
              e3.data.changeAddress && this.connection.tryNextAddress(), this.streamingTasks.forEach((t3) => {
                OE.warning("[".concat(this.spec.clientId, "] live streaming receive error"), e3.toString(), "try to republish", t3.url), this.startLiveStreamingTask(t3.url, t3.mode, e3).then(() => {
                  OE.debug("[".concat(this.spec.clientId, "] live streaming republish ").concat(t3.url, " success"));
                }).catch((e4) => {
                  OE.error("[".concat(this.spec.clientId, "] live streaming republish failed"), t3.url, e4.toString()), this.onLiveStreamError && this.onLiveStreamError(t3.url, e4);
                });
              });
            }
        }
        setInjectStreamConfig(e2, t2) {
          this.injectConfig = Object.assign({}, this.injectConfig, e2), this.injectLoopTimes = t2;
        }
        async startLiveStreamingTask(e2, t2, i2) {
          var n2;
          if (Array.from(IR(n2 = this.streamingTasks).call(n2)).find((e3) => e3.mode === Kf.INJECT) && t2 === Kf.INJECT)
            return new SE(fE.LIVE_STREAMING_TASK_CONFLICT, "inject stream over limit").throw();
          if (!this.transcodingConfig && t2 === Kf.TRANSCODE)
            throw new SE(fE.INVALID_OPERATION, "[LiveStreaming] no transcoding config found, can not start transcoding streaming task");
          let r2 = { command: "PublishStream", ts: Date.now(), url: e2, uid: this.spec.uid.toString(), autoDestroyTime: 100, acceptImageTimeout: true };
          OE.debug("[".concat(this.spec.clientId, "] start live streaming ").concat(e2, ", mode: ").concat(t2));
          const o2 = await this.taskMutex.lock();
          if (!this.connection && i2)
            return void o2();
          if (this.streamingTasks.get(e2) && !i2)
            return o2(), new SE(fE.LIVE_STREAMING_TASK_CONFLICT).throw();
          try {
            this.connection || (this.connection = await this.connect(t2));
          } catch (e3) {
            throw o2(), e3;
          }
          switch (t2) {
            case Kf.TRANSCODE:
              r2.transcodingConfig = Iv({}, this.transcodingConfig);
              break;
            case Kf.RAW:
              break;
            case Kf.INJECT:
              r2 = { cname: this.spec.cname, command: "InjectStream", sid: this.spec.sid, transcodingConfig: this.injectConfig, ts: Date.now(), url: e2, loopTimes: this.injectLoopTimes };
          }
          this.uapResponse && this.uapResponse.vid && (r2.vid = this.uapResponse.vid), this.isStartingStreamingTask = true;
          const s2 = this.lastTaskId++;
          try {
            const n3 = new Sl((t3, n4) => {
              zI(this.retryTimeout).then(() => {
                if (i2)
                  return n4(i2);
                const t4 = this.statusError.get(e2);
                return t4 ? (this.statusError.delete(e2), n4(t4)) : void 0;
              });
            }), a2 = await Sl.race([this.connection.request("request", { clientRequest: r2 }, true, { url: e2, command: "PublishStream", workerType: t2 === Kf.TRANSCODE ? 1 : 2, requestByUser: !i2, tid: s2.toString() }), n3]);
            this.isStartingStreamingTask = false, OE.debug("[".concat(this.spec.clientId, "] live streaming started, code: ").concat(a2.code)), this.streamingTasks.set(e2, { clientRequest: r2, mode: t2, url: e2, taskId: s2 }), o2();
          } catch (n3) {
            if (o2(), this.isStartingStreamingTask = false, !n3.data || !n3.data.retry || i2)
              throw n3;
            return n3.data.changeAddress ? (this.connection.tryNextAddress(), await this.startLiveStreamingTask(e2, t2, n3)) : await this.startLiveStreamingTask(e2, t2, n3);
          }
        }
        stopLiveStreamingTask(e2) {
          return new Sl((t2, i2) => {
            const n2 = this.streamingTasks.get(e2);
            if (!n2 || !this.connection)
              return new SE(fE.UNEXPECTED_ERROR, "can not find streaming task to stop").throw();
            const r2 = n2.mode;
            n2.abortTask = () => {
              OE.debug("[".concat(this.spec.clientId, "] stop live streaming success(worker exception)")), this.streamingTasks.delete(e2), t2();
            }, this.connection.request("request", { clientRequest: { command: r2 === Kf.INJECT ? "UninjectStream" : "UnpublishStream", url: n2.url } }, false, { url: e2, command: "UnPublishStream", workerType: r2 === Kf.TRANSCODE ? 1 : 2, requestByUser: true, tid: (this.lastTaskId++).toString() }).then((i3) => {
              OE.debug("[".concat(this.spec.clientId, "] stop live streaming success, code: ").concat(i3.code)), this.streamingTasks.delete(e2), 0 === this.streamingTasks.size && r2 !== Kf.INJECT && (this.connection && this.connection.close(), this.connection = void 0), t2(), r2 === Kf.INJECT && this.onInjectStatusChange && this.onInjectStatusChange(Yf.INJECT_STREAM_STATUS_STOP_SUCCESS, this.spec.uid, e2);
            }).catch(i2);
          });
        }
        async controlInjectStream(e2, t2, i2, n2) {
          const r2 = this.streamingTasks.get(e2);
          if (!r2 || !this.connection || r2.mode !== Kf.INJECT)
            throw new SE(fE.INVALID_OPERATION, "can not find inject stream task to control");
          return (await this.connection.request("request", { clientRequest: { command: "ControlStream", url: e2, control: t2, audioVolume: i2, position: n2 } })).serverResponse;
        }
        resetAllTask() {
          var e2;
          const t2 = Array.from(IR(e2 = this.streamingTasks).call(e2));
          this.terminate();
          for (const e3 of t2)
            this.startLiveStreamingTask(e3.url, e3.mode).catch((t3) => {
              this.onLiveStreamError && this.onLiveStreamError(e3.url, t3);
            });
        }
        terminate() {
          this.cancelToken && this.cancelToken.cancel(), this.streamingTasks = /* @__PURE__ */ new Map(), this.isStartingStreamingTask = false, this.statusError = /* @__PURE__ */ new Map(), this.cancelToken = pE.CancelToken.source(), this.uapResponse = void 0, this.connection && this.connection.close(), this.connection = void 0;
        }
        async connect(e2) {
          if (this.connection)
            throw new SE(fE.UNEXPECTED_ERROR, "live streaming connection has already connected");
          const t2 = await nC(this, $f.REQUEST_WORKER_MANAGER_LIST, e2);
          return this.uapResponse = t2, this.connection = new gv(t2.workerToken, this.spec, this.wsRetryConfig, e2), this.connection.on(Zf.WARNING, (e3, t3) => this.onLiveStreamWarning && this.onLiveStreamWarning(t3, e3)), this.connection.on(Zf.PUBLISH_STREAM_STATUS, (e3) => this.handlePublishStreamServer(e3)), this.connection.on(Zf.INJECT_STREAM_STATUS, (e3) => this.handleInjectStreamServerStatus(e3)), this.connection.on(Zf.REQUEST_NEW_ADDRESS, (t3, i2) => {
            if (!this.connection)
              return i2(new SE(fE.UNEXPECTED_ERROR, "can not get new live streaming address list"));
            nC(this, $f.REQUEST_WORKER_MANAGER_LIST, e2).then((e3) => {
              this.uapResponse = e3, t3(e3.addressList);
            }).catch(i2);
          }), await this.connection.init(t2.addressList), this.connection;
        }
        handlePublishStreamServer(e2) {
          const t2 = e2.serverStatus && e2.serverStatus.url || "empty_url", i2 = this.streamingTasks.get(t2), n2 = e2.reason;
          switch (e2.code) {
            case eS.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
            case eS.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
            case eS.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
            case eS.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH: {
              const n3 = new SE(fE.LIVE_STREAMING_CDN_ERROR, "", { code: e2.code });
              if (i2)
                return OE.error(n3.toString()), this.onLiveStreamError && this.onLiveStreamError(t2, n3);
              if (!this.isStartingStreamingTask)
                return;
              this.statusError.set(t2, n3);
            }
            case eS.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
              const e3 = new SE(fE.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE, n2);
              return this.onLiveStreamWarning && this.onLiveStreamWarning(t2, e3);
            }
            case eS.LIVE_STREAM_RESPONSE_WORKER_LOST:
            case eS.LIVE_STREAM_RESPONSE_WORKER_QUIT: {
              var r2;
              if (!this.connection)
                return;
              this.connection.tryNextAddress();
              const t3 = Array.from(IR(r2 = this.streamingTasks).call(r2));
              for (const i3 of t3)
                i3.abortTask ? i3.abortTask() : (OE.warning("[".concat(this.spec.clientId, "] publish stream status code"), e2.code, "try to republish", i3.url), this.startLiveStreamingTask(i3.url, i3.mode, new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e2.code })).then(() => {
                  OE.debug("[".concat(this.spec.clientId, "] republish live stream success"), i3.url);
                }).catch((e3) => {
                  OE.error(e3.toString()), this.onLiveStreamError && this.onLiveStreamError(i3.url, e3);
                }));
              return;
            }
          }
        }
        handleInjectStreamServerStatus(e2) {
          const t2 = Number(e2.uid), i2 = e2.serverStatus && e2.serverStatus.url;
          switch (e2.code) {
            case 200:
              return void (this.onInjectStatusChange && this.onInjectStatusChange(Yf.INJECT_STREAM_STATUS_START_SUCCESS, t2, i2));
            case 451:
              return this.onInjectStatusChange && this.onInjectStatusChange(Yf.INJECT_STREAM_STATUS_START_ALREADY_EXISTS, t2, i2), void this.streamingTasks.delete(i2);
            case 453:
              return this.onInjectStatusChange && this.onInjectStatusChange(Yf.INJECT_STREAM_STATUS_START_UNAUTHORIZED, t2, i2), void this.streamingTasks.delete(i2);
            case 470:
              return this.onInjectStatusChange && this.onInjectStatusChange(Yf.INJECT_STREAM_STATUS_BROKEN, t2, i2), void this.streamingTasks.delete(i2);
            case 499:
              return this.onInjectStatusChange && this.onInjectStatusChange(Yf.INJECT_STREAM_STATUS_START_TIMEOUT, t2, i2), void this.streamingTasks.delete(i2);
            default:
              return void OE.debug("inject stream server status", e2);
          }
        }
        hasUrl(e2) {
          return this.streamingTasks.has(e2);
        }
      }
      class vv {
        constructor() {
          _p(this, "destChannelMediaInfos", /* @__PURE__ */ new Map()), _p(this, "srcChannelMediaInfo", void 0);
        }
        setSrcChannelInfo(e2) {
          TS(e2), this.srcChannelMediaInfo = e2;
        }
        addDestChannelInfo(e2) {
          TS(e2), this.destChannelMediaInfos.set(e2.channelName, e2);
        }
        removeDestChannelInfo(e2) {
          Qm(e2), this.destChannelMediaInfos.delete(e2);
        }
        getSrcChannelMediaInfo() {
          return this.srcChannelMediaInfo;
        }
        getDestChannelMediaInfo() {
          return this.destChannelMediaInfos;
        }
      }
      function yv(e2) {
        if (!(e2 instanceof vv)) {
          return new SE(fE.INVALID_PARAMS, "Config should be instance of [ChannelMediaRelayConfiguration]").throw();
        }
        const t2 = e2.getSrcChannelMediaInfo(), i2 = e2.getDestChannelMediaInfo();
        if (!t2) {
          return new SE(fE.INVALID_PARAMS, "srcChannelMediaInfo should not be empty").throw();
        }
        if (0 === i2.size) {
          return new SE(fE.INVALID_PARAMS, "destChannelMediaInfo should not be empty").throw();
        }
      }
      class Av extends EE {
        constructor(e2, t2, i2) {
          super(), _p(this, "ws", void 0), _p(this, "requestId", 1), _p(this, "heartBeatTimer", void 0), _p(this, "joinInfo", void 0), _p(this, "clientId", void 0), _p(this, "onOpen", () => {
            this.emit("open"), this.startHeartBeatCheck();
          }), _p(this, "onClose", (e3) => {
            this.emit("close"), this.dispose();
          }), _p(this, "onMessage", (e3) => {
            const t3 = JSON.parse(e3.data);
            if (!t3 || "serverResponse" !== t3.command || !t3.requestId)
              return t3 && "serverStatus" === t3.command && t3.serverStatus && t3.serverStatus.command ? (this.emit("status", t3.serverStatus), void this.emit(t3.serverStatus.command, t3.serverStatus)) : void 0;
            this.emit("req_".concat(t3.requestId), t3);
          }), this.joinInfo = e2, this.clientId = t2, this.ws = new vC("cross-channel-".concat(this.clientId), i2), this.ws.on(Hf.RECONNECTING, () => {
            this.ws.reconnectMode = "retry", this.emit("reconnecting");
          }), this.ws.on(Hf.CONNECTED, this.onOpen), this.ws.on(Hf.ON_MESSAGE, this.onMessage), this.ws.on(Hf.CLOSED, this.onClose);
        }
        isConnect() {
          return "connected" === this.ws.state;
        }
        sendMessage(e2) {
          const t2 = this.requestId++;
          return e2.requestId = t2, e2.seq = t2, this.ws.sendMessage(e2), t2;
        }
        waitStatus(e2) {
          return new Sl((t2, i2) => {
            const n2 = window.setTimeout(() => {
              i2(new SE(fE.TIMEOUT, "wait status timeout, status: ".concat(e2)));
            }, 5e3);
            this.once(e2, (r2) => {
              window.clearTimeout(n2), r2.state && 0 !== r2.state ? i2(new SE(fE.CROSS_CHANNEL_WAIT_STATUS_ERROR, "wait status error, status: ".concat(e2))) : t2(void 0);
            }), this.once("dispose", () => {
              window.clearTimeout(n2), i2(new SE(fE.WS_ABORT));
            });
          });
        }
        async request(e2) {
          if ("closed" === this.ws.state)
            throw new SE(fE.WS_DISCONNECT);
          const t2 = () => new Sl((e3, t3) => {
            this.ws.once(Hf.CLOSED, () => t3(new SE(fE.WS_ABORT))), this.ws.once(Hf.CONNECTED, e3);
          });
          "connected" !== this.ws.state && await t2();
          const i2 = this.sendMessage(e2), n2 = new Sl((e3, t3) => {
            const n3 = () => {
              t3(new SE(fE.WS_ABORT));
            };
            this.ws.once(Hf.RECONNECTING, n3), this.ws.once(Hf.CLOSED, n3), this.once("req_".concat(i2), e3), zI(3e3).then(() => {
              this.removeAllListeners("req_".concat(i2)), this.ws.off(Hf.RECONNECTING, n3), this.ws.off(Hf.CLOSED, n3), t3(new SE(fE.TIMEOUT, "cross channel ws request timeout"));
            });
          }), r2 = await n2;
          if (!r2 || 200 !== r2.code)
            throw new SE(fE.CROSS_CHANNEL_SERVER_ERROR_RESPONSE, "response: ".concat(JSON.stringify(r2)));
          return r2;
        }
        async connect(e2) {
          this.ws.removeAllListeners(Hf.REQUEST_NEW_URLS), this.ws.on(Hf.REQUEST_NEW_URLS, (t2) => {
            t2(e2);
          }), await this.ws.init(e2);
        }
        dispose() {
          this.clearHeartBeatCheck(), this.emit("dispose"), this.removeAllListeners(), this.ws.close();
        }
        sendPing(e2) {
          const t2 = this.requestId++;
          return e2.requestId = t2, this.ws.sendMessage(e2), t2;
        }
        startHeartBeatCheck() {
          this.heartBeatTimer && window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = window.setInterval(() => {
            this.sendPing({ command: "ping", appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sid: this.joinInfo.sid, ts: +new Date(), requestId: 0 });
          }, 3e3);
        }
        clearHeartBeatCheck() {
          window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = void 0;
        }
      }
      class Ov extends EE {
        set state(e2) {
          e2 !== this._state && (e2 !== rS.RELAY_STATE_FAILURE && (this.errorCode = oS.RELAY_OK), this.emit("state", e2, this.errorCode), this._state = e2);
        }
        get state() {
          return this._state;
        }
        constructor(e2, t2, i2, n2, r2) {
          super(), _p(this, "joinInfo", void 0), _p(this, "sid", void 0), _p(this, "clientId", void 0), _p(this, "cancelToken", pE.CancelToken.source()), _p(this, "workerToken", void 0), _p(this, "requestId", 0), _p(this, "signal", void 0), _p(this, "prevChannelMediaConfig", void 0), _p(this, "httpRetryConfig", void 0), _p(this, "_resolution", void 0), _p(this, "_state", rS.RELAY_STATE_IDLE), _p(this, "errorCode", oS.RELAY_OK), _p(this, "onStatus", (e3) => {
            OE.debug("[".concat(this.clientId, "] ChannelMediaStatus: ").concat(JSON.stringify(e3))), e3 && e3.command && ("onAudioPacketReceived" === e3.command && this.emit("event", nS.PACKET_RECEIVED_AUDIO_FROM_SRC), "onVideoPacketReceived" === e3.command && this.emit("event", nS.PACKET_RECEIVED_VIDEO_FROM_SRC), "onSrcTokenPrivilegeDidExpire" === e3.command && (this.errorCode = oS.SRC_TOKEN_EXPIRED, this.state = rS.RELAY_STATE_FAILURE), "onDestTokenPrivilegeDidExpire" === e3.command && (this.errorCode = oS.DEST_TOKEN_EXPIRED, this.state = rS.RELAY_STATE_FAILURE));
          }), _p(this, "onReconnect", async () => {
            OE.debug("[".concat(this.clientId, "] ChannelMediaSocket disconnect, reconnecting")), this.emit("event", nS.NETWORK_DISCONNECTED), this.state = rS.RELAY_STATE_IDLE, this.prevChannelMediaConfig && this.sendStartRelayMessage(this.prevChannelMediaConfig).catch((e3) => {
              this.state !== rS.RELAY_STATE_IDLE && (OE.error("auto restart channel media relay failed", e3.toString()), this.errorCode = oS.SERVER_CONNECTION_LOST, this.state = rS.RELAY_STATE_FAILURE);
            });
          }), this.joinInfo = e2, this.clientId = t2, this.sid = $I(), this.signal = new Av(this.joinInfo, this.clientId, i2), this.httpRetryConfig = n2, this._resolution = r2;
        }
        async startChannelMediaRelay(e2) {
          if (this.state !== rS.RELAY_STATE_IDLE)
            throw new SE(fE.INVALID_OPERATION);
          this.state = rS.RELAY_STATE_CONNECTING, await this.connect(), OE.debug("[".concat(this.clientId, "] startChannelMediaRelay: connect success"));
          try {
            await this.sendStartRelayMessage(e2);
          } catch (e3) {
            if (e3.data && e3.data.serverResponse && "SetSourceChannel" === e3.data.serverResponse.command)
              throw new SE(fE.CROSS_CHANNEL_FAILED_JOIN_SRC);
            if (e3.data && e3.data.serverResponse && "SetDestChannelStatus" === e3.serverResponse.command)
              throw new SE(fE.CROSS_CHANNEL_FAILED_JOIN_DEST);
            if (e3.data && e3.data.serverResponse && "StartPacketTransfer" === e3.serverResponse.command)
              throw new SE(fE.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST);
            throw e3;
          }
          this.prevChannelMediaConfig = e2;
        }
        async updateChannelMediaRelay(e2) {
          if (this.state !== rS.RELAY_STATE_RUNNING)
            throw new SE(fE.INVALID_OPERATION);
          await this.sendUpdateMessage(e2), this.prevChannelMediaConfig = e2;
        }
        async setVideoProfile(e2) {
          if (this._resolution = e2, this.state !== rS.RELAY_STATE_RUNNING)
            throw new SE(fE.INVALID_OPERATION);
          const t2 = this.genMessage(iS.SetVideoProfile);
          await this.signal.request(t2), OE.debug("[".concat(this.clientId, "] startChannelMediaRelay: setVideoProfile success"));
        }
        async stopChannelMediaRelay() {
          await this.sendStopRelayMessage(), OE.debug("[".concat(this.clientId, "] stopChannelMediaRelay: send stop message success")), this.state = rS.RELAY_STATE_IDLE, this.dispose();
        }
        dispose() {
          OE.debug("[".concat(this.clientId, "] disposeChannelMediaRelay")), this.cancelToken.cancel(), this.cancelToken = pE.CancelToken.source(), this.state = rS.RELAY_STATE_IDLE, this.emit("dispose"), this.signal.dispose(), this.prevChannelMediaConfig = void 0;
        }
        async connect() {
          const e2 = await pv(this.joinInfo, this.cancelToken.token, this.httpRetryConfig);
          this.workerToken = e2.workerToken, await this.signal.connect(e2.addressList), this.emit("event", nS.NETWORK_CONNECTED), this.signal.on("status", this.onStatus), this.signal.on("reconnecting", this.onReconnect);
        }
        async sendStartRelayMessage(e2) {
          const t2 = this.genMessage(iS.StopPacketTransfer);
          await this.signal.request(t2), await this.signal.waitStatus("Normal Quit"), OE.debug("[".concat(this.clientId, "] startChannelMediaRelay: StopPacketTransfer success"));
          const i2 = this.genMessage(iS.SetSdkProfile, e2);
          await this.signal.request(i2), OE.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSdkProfile success"));
          const n2 = this.genMessage(iS.SetSourceChannel, e2);
          await this.signal.request(n2), await this.signal.waitStatus("SetSourceChannelStatus"), this.emit("event", nS.PACKET_JOINED_SRC_CHANNEL), OE.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceChannel success"));
          const r2 = this.genMessage(iS.SetSourceUserId, e2);
          await this.signal.request(r2), OE.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceUserId success"));
          const o2 = this.genMessage(iS.SetDestChannel, e2);
          await this.signal.request(o2), await this.signal.waitStatus("SetDestChannelStatus"), this.emit("event", nS.PACKET_JOINED_DEST_CHANNEL), OE.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetDestChannel success"));
          const s2 = this.genMessage(iS.StartPacketTransfer, e2);
          await this.signal.request(s2), this.emit("event", nS.PACKET_SENT_TO_DEST_CHANNEL), this.state = rS.RELAY_STATE_RUNNING, OE.debug("[".concat(this.clientId, "] startChannelMediaRelay: StartPacketTransfer success")), this.setVideoProfile(this._resolution);
        }
        async sendUpdateMessage(e2) {
          const t2 = this.genMessage(iS.UpdateDestChannel, e2);
          await this.signal.request(t2), this.emit("event", nS.PACKET_UPDATE_DEST_CHANNEL), OE.debug("[".concat(this.clientId, "] sendUpdateMessage: UpdateDestChannel success"));
        }
        async sendStopRelayMessage() {
          const e2 = this.genMessage(iS.StopPacketTransfer);
          await this.signal.request(e2), OE.debug("[".concat(this.clientId, "] sendStopRelayMessage: StopPacketTransfer success"));
        }
        genMessage(e2, t2) {
          const i2 = [], n2 = [], r2 = [];
          this.requestId += 1;
          const o2 = { appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sdkVersion: bE, sid: this.sid, ts: Date.now(), requestId: this.requestId, seq: this.requestId, allocate: true, clientRequest: {} };
          "4.18.2" === o2.sdkVersion && (o2.sdkVersion = "0.0.1");
          let s2 = null, a2 = null;
          switch (e2) {
            case iS.SetSdkProfile:
              return o2.clientRequest = { command: "SetSdkProfile", type: "multi_channel" }, o2;
            case iS.SetSourceChannel:
              if (a2 = t2 && t2.getSrcChannelMediaInfo(), !a2)
                throw new SE(fE.UNEXPECTED_ERROR, "can not find source config");
              return o2.clientRequest = { command: "SetSourceChannel", uid: "0", channelName: a2.channelName, token: a2.token || this.joinInfo.appId }, o2;
            case iS.SetSourceUserId:
              if (a2 = t2 && t2.getSrcChannelMediaInfo(), !a2)
                throw new SE(fE.UNEXPECTED_ERROR, "can not find source config");
              return o2.clientRequest = { command: "SetSourceUserId", uid: a2.uid + "" }, o2;
            case iS.SetDestChannel:
              if (s2 = t2 && t2.getDestChannelMediaInfo(), !s2)
                throw new SE(fE.UNEXPECTED_ERROR, "can not find dest config");
              return s2.forEach((e3) => {
                i2.push(e3.channelName), n2.push(e3.uid + ""), r2.push(e3.token || this.joinInfo.appId);
              }), o2.clientRequest = { command: "SetDestChannel", channelName: i2, uid: n2, token: r2 }, o2;
            case iS.StartPacketTransfer:
              return o2.clientRequest = { command: "StartPacketTransfer" }, o2;
            case iS.Reconnect:
              return o2.clientRequest = { command: "Reconnect" }, o2;
            case iS.StopPacketTransfer:
              return o2.clientRequest = { command: "StopPacketTransfer" }, o2;
            case iS.UpdateDestChannel:
              if (s2 = t2 && t2.getDestChannelMediaInfo(), !s2)
                throw new SE(fE.UNEXPECTED_ERROR, "can not find dest config");
              return s2.forEach((e3) => {
                i2.push(e3.channelName), n2.push(e3.uid + ""), r2.push(e3.token || this.joinInfo.appId);
              }), o2.clientRequest = { command: "UpdateDestChannel", channelName: i2, uid: n2, token: r2 }, o2;
            case iS.SetVideoProfile:
              o2.clientRequest = { command: "SetVideoProfile", width: this._resolution.width, height: this._resolution.height };
          }
          return o2;
        }
      }
      const Nv = (e2) => {
        const t2 = document.createElement("canvas");
        return t2.width = 2, t2.height = 2, new Sl((i2, n2) => {
          t2.toBlob(async (e3) => {
            if (t2.remove(), e3) {
              const n3 = await bv(e3);
              i2({ buffer: n3, width: t2.width, height: t2.height });
            } else
              n2(new SE(fE.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));
          }, e2, 1);
        });
      }, bv = async (e2) => {
        const t2 = await e2.arrayBuffer();
        return new Uint8Array(t2);
      };
      function wv(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function Dv(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? wv(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : wv(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class Pv {
        get videoElementStatus() {
          return this._videoElementStatus;
        }
        set videoElementStatus(e2) {
          e2 !== this._videoElementStatus && (OE.debug("[".concat(this.trackId, "] video-element-status change ").concat(this._videoElementStatus, " => ").concat(e2)), this._videoElementStatus = e2);
        }
        constructor(e2) {
          _p(this, "trackId", void 0), _p(this, "config", void 0), _p(this, "onFirstVideoFrameDecoded", void 0), _p(this, "freezeTimeCounterList", []), _p(this, "renderFreezeAccTime", 0), _p(this, "isKeepLastFrame", false), _p(this, "timeUpdatedCount", 0), _p(this, "freezeTime", 0), _p(this, "playbackTime", 0), _p(this, "lastTimeUpdatedTime", 0), _p(this, "autoplayFailed", false), _p(this, "videoTrack", void 0), _p(this, "videoElement", void 0), _p(this, "cacheVideoElement", void 0), _p(this, "videoElementCheckInterval", void 0), _p(this, "_videoElementStatus", sf.NONE), _p(this, "isGettingVideoDimensions", false), _p(this, "startGetVideoDimensions", () => {
            const e3 = () => {
              if (this.isGettingVideoDimensions = true, this.videoElement.videoWidth * this.videoElement.videoHeight > 4)
                return OE.debug("[".concat(this.trackId, "] current video dimensions:"), this.videoElement.videoWidth, this.videoElement.videoHeight), void (this.isGettingVideoDimensions = false);
              setTimeout(e3, 500);
            };
            !this.isGettingVideoDimensions && e3();
          }), _p(this, "autoResumeAfterInterruption", () => {
            this.videoTrack && "live" === this.videoTrack.readyState && "running" === Gg.curState && (OE.debug("[track-".concat(this.trackId, "] video element paused, auto resume for ").concat(jh())), ep() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play()));
          }), _p(this, "handleVideoEvents", (e3) => {
            switch (e3.type) {
              case "play":
              case "playing":
                this.startGetVideoDimensions(), this.videoElementStatus = sf.PLAYING;
                break;
              case "loadeddata":
                if (this.onFirstVideoFrameDecoded && this.onFirstVideoFrameDecoded(), this.cacheVideoElement) {
                  try {
                    this.cacheVideoElement.srcObject = null, this.cacheVideoElement.remove();
                  } catch (e4) {
                  }
                  this.cacheVideoElement = void 0;
                }
                break;
              case "canplay":
                this.videoElementStatus = sf.CANPLAY;
                break;
              case "stalled":
                this.videoElementStatus = sf.STALLED;
                break;
              case "suspend":
                this.videoElementStatus = sf.SUSPEND;
                break;
              case "pause":
                this.videoElementStatus = sf.PAUSED, Yh() || tp() || Hh() && this.autoplayFailed || !this.videoTrack || "live" !== this.videoTrack.readyState || (OE.debug("[track-".concat(this.trackId, "] video element paused, auto resume")), this.videoElement.play());
                break;
              case "waiting":
                this.videoElementStatus = sf.WAITING;
                break;
              case "abort":
                this.videoElementStatus = sf.ABORT;
                break;
              case "ended":
                this.videoElementStatus = sf.ENDED;
                break;
              case "emptied":
                this.videoElementStatus = sf.EMPTIED;
                break;
              case "error": {
                this.videoElementStatus = sf.ERROR;
                const e4 = this.videoElement.error;
                e4 && OE.error("[".concat(this.trackId, "] media error, code: ").concat(e4.code, ", message: ").concat(e4.message));
                break;
              }
              case "timeupdate": {
                const e4 = performance.now();
                if (this.timeUpdatedCount += 1, this.timeUpdatedCount < 10)
                  return void (this.lastTimeUpdatedTime = e4);
                const t2 = e4 - this.lastTimeUpdatedTime, i2 = this.lastTimeUpdatedTime;
                if (this.lastTimeUpdatedTime = e4, MI.lastVisibleTime < MI.lastHiddenTime || i2 < MI.lastHiddenTime || i2 < MI.lastVisibleTime)
                  return;
                for (t2 > GE("VIDEO_FREEZE_DURATION") && (this.freezeTime += t2), this.playbackTime += t2; this.playbackTime >= 6e3; ) {
                  this.playbackTime -= 6e3;
                  const e5 = Math.min(6e3, this.freezeTime);
                  this.freezeTimeCounterList.push(e5), this.freezeTime = Math.max(0, this.freezeTime - 6e3);
                }
                break;
              }
            }
          }), _p(this, "autoResumeAfterInterruptionOnIOS15_16", () => {
            this.videoTrack && "live" === this.videoTrack.readyState && (OE.debug("[track-".concat(this.trackId, "] video element paused, auto resume for ").concat(jh())), ep() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play()));
          }), this.trackId = e2.trackId, this.config = e2, e2.element instanceof HTMLVideoElement ? this.videoElement = e2.element : this.videoElement = document.createElement("video"), Gg.on(kg.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), Gg.on(kg.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16);
        }
        getVideoElement() {
          return this.videoElement;
        }
        getContainerElement() {
          var e2;
          return null !== (e2 = this.videoElement.parentElement) && void 0 !== e2 ? e2 : void 0;
        }
        updateConfig(e2) {
          this.config = e2, this.trackId = e2.trackId, e2.element !== this.videoElement && (this.destroy(), this.videoElement = e2.element), this.videoTrack && this.initVideoElement();
        }
        updateVideoTrack(e2) {
          this.videoTrack !== e2 && (this.videoTrack = e2, this.initVideoElement());
        }
        play(e2) {
          const t2 = this.videoElement.play();
          t2 && t2.catch && t2.catch((t3) => {
            e2 && Pg.autoplayFailed(e2, "video", t3.message, this.trackId), "NotAllowedError" === t3.name ? (OE.warning("detected video element autoplay failed", t3), this.autoplayFailed = true, this.handleAutoPlayFailed()) : OE.warning("[".concat(this.trackId, "] play warning: "), t3);
          });
          const i2 = xh();
          if (("Safari" === i2.name && 15 === Number(i2.version) || Zh()) && t2 && t2.then && t2.catch) {
            const e3 = () => {
              this.config.mirror && (this.videoElement.style.transform = "rotateY(180deg)");
            };
            t2.then(e3).catch(e3);
          }
        }
        getCurrentFrame() {
          const e2 = document.createElement("canvas");
          e2.width = this.videoElement.videoWidth, e2.height = this.videoElement.videoHeight;
          const t2 = e2.getContext("2d");
          if (!t2)
            return OE.error("create canvas context failed!"), new ImageData(2, 2);
          t2.drawImage(this.videoElement, 0, 0, e2.width, e2.height);
          const i2 = t2.getImageData(0, 0, e2.width, e2.height);
          return e2.remove(), i2;
        }
        async getCurrentFrameToUint8Array(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
          const i2 = document.createElement("canvas");
          i2.width = this.videoElement.videoWidth, i2.height = this.videoElement.videoHeight;
          const n2 = i2.getContext("2d");
          return n2 ? (n2.drawImage(this.videoElement, 0, 0, i2.width, i2.height), new Sl((n3, r2) => {
            i2.toBlob(async (e3) => {
              if (i2.remove(), e3) {
                const t3 = await bv(e3);
                n3({ buffer: t3, width: i2.width, height: i2.height });
              } else
                r2(new SE(fE.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));
            }, e2, t2 < 0 ? 0.1 : t2 > 1 ? 1 : t2);
          })) : await Nv(e2);
        }
        destroy() {
          Gg.off(kg.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), Gg.off(kg.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), this.videoElement.srcObject = null, this.resetVideoElement(), this.freezeTimeCounterList = [];
        }
        initVideoElement() {
          if (this.videoElementStatus = sf.INIT, !this.videoElementCheckInterval && (Lv.forEach((e3) => {
            this.videoElement.addEventListener(e3, this.handleVideoEvents);
          }), this.videoElementCheckInterval = window.setInterval(() => {
            (function(e3) {
              return e3 !== document.body && document.body.contains(e3);
            })(this.videoElement) || (this.videoElementStatus = sf.DESTROYED);
          }, 1e3), GE("ENABLE_VIDEO_FRAME_CALLBACK"))) {
            var e2, t2;
            let i3;
            const n3 = (e3, t3) => {
              if (this.videoElementStatus === sf.PLAYING) {
                if (i3) {
                  const e4 = t3.presentationTime - i3.presentationTime;
                  e4 > GE("VIDEO_FREEZE_DURATION") && MI.lastVisibleTime >= MI.lastHiddenTime && i3.timestamp > MI.lastVisibleTime && i3.timestamp > MI.lastHiddenTime && (this.renderFreezeAccTime += e4);
                }
                i3 = Dv(Dv({}, t3), {}, { timestamp: e3 });
              }
              var r2, o2;
              GE("ENABLE_VIDEO_FRAME_CALLBACK") && (null === (r2 = (o2 = this.videoElement).requestVideoFrameCallback) || void 0 === r2 || r2.call(o2, n3));
            };
            null === (e2 = (t2 = this.videoElement).requestVideoFrameCallback) || void 0 === e2 || e2.call(t2, n3);
          }
          this.videoElement.controls = false, this.videoElement.setAttribute("playsinline", ""), op() && (this.videoElement.poster = "noposter");
          const i2 = xh();
          if ("Safari" === i2.name && 15 === Number(i2.version) || Zh() || !this.config.mirror || (this.videoElement.style.transform = "rotateY(180deg)"), this.config.fit ? this.videoElement.style.objectFit = this.config.fit : this.videoElement.style.objectFit = "cover", this.videoElement.setAttribute("muted", ""), this.videoElement.muted = true, this.videoElement.srcObject && this.videoElement.srcObject instanceof MediaStream) {
            this.videoElement.srcObject.getVideoTracks()[0] !== this.videoTrack && (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, Kh() && this.videoElement.load());
          } else
            this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, Kh() && this.videoElement.load();
          const n2 = this.videoElement.play();
          void 0 !== n2 && n2.catch((e3) => {
            OE.debug("[".concat(this.trackId, "] playback interrupted"), e3.toString());
          });
        }
        resetVideoElement() {
          Lv.forEach((e2) => {
            this.videoElement && this.videoElement.removeEventListener(e2, this.handleVideoEvents);
          }), this.videoElementCheckInterval && (window.clearInterval(this.videoElementCheckInterval), this.videoElementCheckInterval = void 0), this.videoElementStatus = sf.NONE;
        }
        handleAutoPlayFailed() {
          const e2 = (t2) => {
            t2.preventDefault(), this.videoElement.play().then(() => {
              OE.debug("[".concat(this.trackId, "] Video element for trackId:").concat(this.trackId, " autoplay resumed."));
            }).catch((e3) => {
              OE.error(e3);
            }), this.autoplayFailed = false, sp() ? document.body.removeEventListener("click", e2, true) : (document.body.removeEventListener("touchstart", e2, true), document.body.removeEventListener("mousedown", e2, true));
          };
          sp() ? document.body.addEventListener("click", e2, true) : (document.body.addEventListener("touchstart", e2, true), document.body.addEventListener("mousedown", e2, true)), yg();
        }
      }
      const Lv = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "timeupdate", "error"];
      class kv extends Pv {
        constructor(e2) {
          super(e2), _p(this, "container", void 0), _p(this, "slot", void 0), this.slot = e2.element, this.updateConfig(e2);
        }
        updateConfig(e2) {
          this.config = e2, this.trackId = e2.trackId;
          const t2 = e2.element;
          t2 !== this.slot && (this.destroy(), this.slot = t2), this.createElements();
        }
        updateVideoTrack(e2) {
          this.videoTrack !== e2 && (this.videoTrack = e2, this.createElements());
        }
        play(e2) {
          var t2;
          null !== (t2 = this.container) && void 0 !== t2 && t2.contains(this.videoElement) && super.play(e2);
        }
        getCurrentFrame() {
          var e2;
          return null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement) ? super.getCurrentFrame() : new ImageData(2, 2);
        }
        async getCurrentFrameToUint8Array(e2) {
          var t2;
          let i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
          return null !== (t2 = this.container) && void 0 !== t2 && t2.contains(this.videoElement) ? await super.getCurrentFrameToUint8Array(e2, i2) : await Nv(e2);
        }
        destroy() {
          if (super.destroy(), this.videoElement.remove(), this.videoElement = document.createElement("video"), this.container) {
            try {
              this.container.remove(), this.slot.removeChild(this.container);
            } catch (e2) {
            }
            this.container = void 0;
          }
        }
        createElements() {
          this.container || (this.container = document.createElement("div")), this.container.id = "agora-video-player-".concat(this.trackId), this.container.style.width = "100%", this.container.style.height = "100%", this.container.style.position = "relative", this.container.style.overflow = "hidden", this.videoTrack ? (this.container.style.backgroundColor = "black", GE("KEEP_LAST_FRAME") && this.isKeepLastFrame && this.videoElement.paused && this.resetVideoElement(), this.mountedVideoElement()) : this.unmountedVideoElement(), this.slot.appendChild(this.container);
        }
        mountedVideoElement() {
          var e2;
          !this.container || null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement) || this.container.appendChild(this.videoElement), super.initVideoElement(), this.videoElement.id = "video_".concat(this.trackId), this.videoElement.className = "agora_video_player", this.videoElement.style.width = "100%", this.videoElement.style.height = "100%", this.videoElement.style.position = "absolute", this.videoElement.style.left = "0", this.videoElement.style.top = "0";
        }
        unmountedVideoElement() {
          var e2;
          if (null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement)) {
            super.resetVideoElement();
            try {
              this.container && this.container.removeChild(this.videoElement);
            } catch (e3) {
            }
            this.videoElement = document.createElement("video");
          }
        }
        resetVideoElement() {
          var e2;
          null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement) && (super.resetVideoElement(), this.cacheVideoElement = this.videoElement, this.videoElement = document.createElement("video"));
        }
        getContainerElement() {
          return this.container;
        }
      }
      function Mv(e2) {
        const t2 = {};
        e2.facingMode && (t2.facingMode = e2.facingMode), e2.cameraId && (t2.deviceId = { exact: e2.cameraId });
        const i2 = UE(e2.encoderConfig);
        return t2.width = i2.width, t2.height = i2.height, !np() && i2.frameRate && (t2.frameRate = i2.frameRate), xh().name === wh.EDGE && "object" == typeof t2.frameRate && (t2.frameRate.max = 60), Kh() && (t2.frameRate = { ideal: 30, max: 30 }), t2;
      }
      function Uv(e2) {
        const t2 = {};
        e2.screenSourceType && (t2.mediaSource = e2.screenSourceType), e2.extensionId && Wh() && (t2.extensionId = e2.extensionId);
        const { displaySurface: i2, selfBrowserSurface: n2, surfaceSwitching: r2, systemAudio: o2 } = e2;
        (qh(107) || Jh(107) || Xh(93)) && (i2 && (Ym(i2, "displaySurface", ["browser", "window", "monitor"]), t2.displaySurface = i2), n2 ? (Ym(n2, "selfBrowserSurface", ["exclude", "include"]), t2.selfBrowserSurface = n2) : t2.selfBrowserSurface = "include", r2 && (Ym(r2, "surfaceSwitching", ["exclude", "include"]), t2.surfaceSwitching = r2)), (qh(105) || Jh(105) || Xh(91)) && o2 && (Ym(o2, "systemAudio", ["exclude", "include"]), t2.systemAudio = o2), e2.electronScreenSourceId && (t2.sourceId = e2.electronScreenSourceId);
        const s2 = e2.encoderConfig ? xE(e2.encoderConfig) : null;
        return t2.mandatory = { chromeMediaSource: "desktop", maxWidth: s2 ? s2.width : void 0, maxHeight: s2 ? s2.height : void 0 }, s2 && (s2.frameRate && ("number" == typeof s2.frameRate ? (t2.mandatory.maxFrameRate = s2.frameRate, t2.mandatory.minFrameRate = s2.frameRate) : (t2.mandatory.maxFrameRate = s2.frameRate.max || s2.frameRate.ideal || s2.frameRate.exact || void 0, t2.mandatory.minFrameRate = s2.frameRate.min || s2.frameRate.ideal || s2.frameRate.exact || void 0), t2.frameRate = s2.frameRate), s2.width && (t2.width = s2.width), s2.height && (t2.height = s2.height)), t2;
      }
      function xv(e2) {
        const t2 = {};
        if (np() || (void 0 !== e2.AGC && (t2.autoGainControl = e2.AGC), void 0 !== e2.AEC && (t2.echoCancellation = e2.AEC), void 0 !== e2.ANS && (t2.noiseSuppression = e2.ANS, Wh() && e2.ANS && (t2.googHighpassFilter = e2.ANS))), e2.encoderConfig) {
          const i2 = FE(e2.encoderConfig);
          t2.channelCount = i2.stereo ? 2 : 1, t2.sampleRate = i2.sampleRate, t2.sampleSize = i2.sampleSize;
        }
        return e2.microphoneId && (t2.deviceId = { exact: e2.microphoneId }), op() && (t2.sampleRate = void 0), t2;
      }
      var Vv, jv;
      !function(e2) {
        e2.COVERED = "COVERED", e2.POSITION = "POSITION", e2.SIZE = "SIZE", e2.STYLE = "STYLE";
      }(Vv || (Vv = {})), function(e2) {
        e2.UNMOUNTED = "UNMOUNTED", e2.INVALID_HTML_ELEMENT = "INVALID_HTML_ELEMENT";
      }(jv || (jv = {}));
      var Fv, Bv, Gv, Wv, Hv, Kv, Yv, qv, Jv, Xv, zv, Qv, Zv, $v, ey, ty, iy, ny, ry, oy, sy, ay, cy, dy, uy, ly, hy, py, _y, Ey, my, fy, Sy, Ty, gy = new class {
        constructor() {
          _p(this, "_clientSize", null), _p(this, "getClientWidth", () => document.documentElement ? document.documentElement.clientWidth : document.body.clientWidth), _p(this, "getClientHeight", () => document.documentElement ? document.documentElement.clientHeight : document.body.clientHeight), _p(this, "getStyle", (e2) => window.getComputedStyle(e2, null)), _p(this, "checkCssVisibleProperty", (e2) => {
            let t2 = true;
            const i2 = this.getStyle(e2), { display: n2, visibility: r2, opacity: o2, filter: s2 } = i2;
            if (("none" === n2 || ["hidden", "collapse"].includes(r2) || Number(o2) < 0.1) && (t2 = false), !t2)
              return false;
            if (s2) {
              s2.split(" ").filter((e3) => {
                const t3 = e3.split("(")[0];
                return ["brightness", "blur", "opacity"].includes(t3);
              }).map((e3) => {
                const [t3, i3] = e3.split(/\(|\)/);
                return [t3, Number(i3.match(/^[0-9\.]+/))];
              }).forEach((e3) => {
                const [i3, n3] = e3;
                switch (i3) {
                  case "brightness":
                    (n3 < 0.1 || n3 > 3) && (t2 = false);
                    break;
                  case "blur":
                    n3 > 3 && (t2 = false);
                    break;
                  case "opacity":
                    n3 < 0.1 && (t2 = false);
                }
              });
            }
            return t2;
          }), _p(this, "checkPropertyUpToAllParentNodes", (e2, t2) => {
            let i2 = true, n2 = true;
            const r2 = (e3) => t2(e3);
            let o2 = e2;
            for (; o2 && n2; ) {
              r2(o2) || (i2 = false, n2 = false), o2 = o2.parentElement, o2 || (n2 = false);
            }
            return i2;
          }), _p(this, "checkActualCssVisibleIncludeInherit", (e2) => this.checkPropertyUpToAllParentNodes(e2, this.checkCssVisibleProperty)), _p(this, "getSizeAboutClient", (e2) => {
            const { width: t2, height: i2, left: n2, right: r2, top: o2, bottom: s2 } = e2.getBoundingClientRect(), a2 = this.getClientWidth(), c2 = this.getClientHeight();
            return { width: t2, height: i2, left: n2, right: r2, top: o2, bottom: s2, clientWidth: a2, clientHeight: c2, clientMin: Math.min(a2, c2) };
          }), _p(this, "checkActualSize", () => {
            const { width: e2, height: t2, clientMin: i2 } = this._clientSize;
            return this.checkSizeIsVisible(e2, t2, i2);
          }), _p(this, "elementFromPoint", (e2, t2) => document.elementFromPoint ? document.elementFromPoint(e2, t2) : null), _p(this, "checkCoverForAPoint", (e2, t2, i2) => {
            const n2 = this.elementFromPoint(e2, t2);
            return null !== n2 && n2 !== i2;
          }), _p(this, "getPointPositionList", () => {
            const { width: e2, height: t2, left: i2, top: n2 } = this._clientSize, r2 = e2 / 6, o2 = t2 / 6, s2 = [], a2 = 10 ** 6;
            for (let e3 = 0; e3 < 5; e3++)
              for (let t3 = 0; t3 < 5; t3++) {
                const c2 = (i2 * a2 + (0 === e3 ? 0.1 : 4 === e3 ? (r2 * e3 * a2 - 1e5) / a2 : r2 * e3) * a2) / a2, d2 = (n2 * a2 + (0 === t3 ? 0.1 : 4 === t3 ? (o2 * t3 * a2 - 1e5) / a2 : o2 * t3) * a2) / a2;
                s2.push({ x: c2, y: d2 });
              }
            return [...s2];
          }), _p(this, "checkElementCover", (e2) => this.getPointPositionList().map((t2) => this.checkCoverForAPoint(t2.x, t2.y, e2)).filter((e3) => !!e3).length > 6), _p(this, "checkSizeIsVisible", (e2, t2, i2) => (e2 > 50 || i2 / e2 <= 10) && (t2 > 50 || i2 / t2 <= 10)), _p(this, "checkSizeOfPartInClient", () => {
            const { left: e2, right: t2, top: i2, bottom: n2, clientHeight: r2, clientWidth: o2, clientMin: s2 } = this._clientSize;
            let a2, c2, d2, u2;
            if (e2 < 0)
              a2 = 0;
            else {
              if (!(e2 < o2))
                return false;
              a2 = e2;
            }
            if (t2 < 0)
              return false;
            if (c2 = t2 < o2 ? t2 : o2, i2 < 0)
              d2 = 0;
            else {
              if (!(i2 < r2))
                return false;
              d2 = i2;
            }
            if (n2 < 0)
              return false;
            u2 = n2 < r2 ? n2 : r2;
            const l2 = c2 - a2, h2 = u2 - d2;
            return this.checkSizeIsVisible(l2, h2, s2);
          }), _p(this, "returnHiddenResult", (e2) => (this._clientSize = null, { visible: false, reason: e2 })), _p(this, "checkOneElementVisible", (e2) => {
            if (e2 instanceof HTMLElement) {
              if (this.checkElementIsMountedOnDom(e2)) {
                if (this.checkActualCssVisibleIncludeInherit(e2)) {
                  if (this._clientSize = this.getSizeAboutClient(e2), this.checkElementCover(e2))
                    return this.returnHiddenResult(Vv.COVERED);
                  {
                    const e3 = this.checkActualSize(), t2 = this.checkSizeOfPartInClient();
                    return e3 && !t2 ? this.returnHiddenResult(Vv.POSITION) : e3 ? (this._clientSize = null, { visible: true }) : this.returnHiddenResult(Vv.SIZE);
                  }
                }
                return this.returnHiddenResult(Vv.STYLE);
              }
              return this.returnHiddenResult(jv.UNMOUNTED);
            }
            return this.returnHiddenResult(jv.INVALID_HTML_ELEMENT);
          }), _p(this, "checkElementIsMountedOnDom", (e2) => this.checkPropertyUpToAllParentNodes(e2, (e3) => "HTML" !== e3.nodeName.toUpperCase() ? null !== e3.parentElement : !!document.documentElement));
        }
      }();
      function Ry(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function Iy(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Ry(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : Ry(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      let Cy = (Fv = Dg({ argsMap: (e2, t2, i2) => [e2.getTrackId(), "string" == typeof t2 ? t2 : t2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement", i2] }), Bv = _R(), Gv = Dg({ argsMap: (e2) => [e2.getTrackId()] }), Wv = xg("LocalVideoTrack", "_enabledMutex"), Hv = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), Kv = _R(), Yv = xg("LocalVideoTrack", "_enabledMutex"), qv = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), Jv = _R(), Xv = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), zv = _R(), Qv = _R(), Zv = Dg({ argsMap: (e2, t2, i2) => [e2.getTrackId(), t2, i2] }), $v = _R(), ey = _R(), ty = _R(), iy = _R(), ny = _R(), ry = _R(), oy = _R(), sy = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), ay = Dg({ argsMap: (e2) => [e2.getTrackId()] }), cy = Dg({ argsMap: (e2) => [e2.getTrackId()] }), dy = Dg({ argsMap: (e2, t2, i2) => [e2.getTrackId(), t2.label, i2] }), ag((uy = class e2 extends Vg {
        get isPlaying() {
          return !(!this._player || this._player.videoElementStatus !== sf.PLAYING);
        }
        get processorContext() {
          return this._processorContext;
        }
        set processorContext(e3) {
          this._processorContext = e3;
        }
        get __className__() {
          return "LocalVideoTrack";
        }
        constructor(e3, t2, i2, n2, r2, o2) {
          if (super(e3, r2), _p(this, "trackMediaType", "video"), _p(this, "_player", void 0), _p(this, "_videoVisibleTimer", null), _p(this, "_previousVideoVisibleStatus", void 0), _p(this, "_clearPreviousVideoVisibleStatus", () => this._previousVideoVisibleStatus = void 0), _p(this, "_encoderConfig", void 0), _p(this, "_scalabiltyMode", { numSpatialLayers: 1, numTemporalLayers: 1 }), _p(this, "_optimizationMode", void 0), _p(this, "_videoHeight", void 0), _p(this, "_videoWidth", void 0), _p(this, "_forceBitrateLimit", void 0), _p(this, "_enabled", true), _p(this, "processorDestination", void 0), _p(this, "_processorContext", void 0), Hh()) {
            const { width: t3, height: i3 } = e3.getSettings();
            this._videoWidth = t3, this._videoHeight = i3;
          } else
            this.updateMediaStreamTrackResolution();
          this._encoderConfig = t2, this._scalabiltyMode = i2, this._optimizationMode = n2, this._hints = o2 || [], -1 === this._hints.indexOf(lS.SCREEN_TRACK) && this.updateBitrateFromProfile(), t2 && -1 !== this._hints.indexOf(lS.CUSTOM_TRACK) && this.setEncoderConfiguration(t2), this.processorContext = new AR(this.getTrackId(), "local"), this.processorDestination = new yR(this.processorContext), this.bindProcessorDestinationEvents();
        }
        play(e3) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          if ("string" == typeof e3) {
            const t3 = document.getElementById(e3);
            t3 ? e3 = t3 : (OE.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e3, '" element, use document.body')), e3 = document.body);
          }
          OE.debug("[".concat(this.getTrackId(), "] start video playback in ").concat(e3 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement"), JSON.stringify(t2));
          const i2 = Iy(Iy(Iy({}, this._getDefaultPlayerConfig()), t2), {}, { trackId: this.getTrackId(), element: e3 });
          this._player ? this._player.updateConfig(i2) : (e3 instanceof HTMLVideoElement ? this._player = new Pv(i2) : this._player = new kv(i2), this._player.updateVideoTrack(this._mediaStreamTrack)), this._player.play(), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {
            try {
              const e4 = this.getVideoElementVisibleStatus();
              this.safeEmit(mS.VIDEO_ELEMENT_VISIBLE_STATUS, e4);
            } catch (e4) {
            }
          }, GE("CHECK_VIDEO_VISIBLE_INTERVAL"));
        }
        stop() {
          this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, OE.debug("[".concat(this.getTrackId(), "] stop video playback")));
        }
        async setEnabled(e3, t2) {
          if (!t2) {
            if (e3 === this._enabled)
              return;
            this.stateCheck("enabled", e3);
          }
          if (OE.info("[".concat(this.getTrackId(), "] start setEnabled"), e3), !e3) {
            this._originMediaStreamTrack.enabled = false;
            try {
              await rC(this, uS.NEED_DISABLE_TRACK, this);
            } catch (e4) {
              throw OE.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e4.toString()), e4;
            }
            return t2 || (this._enabled = false), void OE.info("[".concat(this.getTrackId(), "] setEnabled to false success"));
          }
          this._originMediaStreamTrack.enabled = true;
          try {
            await rC(this, uS.NEED_ENABLE_TRACK, this);
          } catch (e4) {
            throw OE.error("[".concat(this.getTrackId(), "] setEnabled to true error"), e4.toString()), e4;
          }
          OE.info("[".concat(this.getTrackId(), "] setEnabled to true success")), t2 || (this._enabled = true);
        }
        async setMuted(e3) {
          e3 !== this._muted && (this.stateCheck("muted", e3), this._muted = e3, this._originMediaStreamTrack.enabled = !e3, OE.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e3)), e3 ? await rC(this, uS.NEED_MUTE_TRACK, this) : await rC(this, uS.NEED_UNMUTE_TRACK, this));
        }
        async setEncoderConfiguration(e3, t2) {
          if (!this._enabled)
            throw new SE(fE.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
          if (e3 = UE(e3), this._forceBitrateLimit && (e3.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e3.bitrateMax, e3.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e3.bitrateMin), e3.width || e3.height || e3.frameRate) {
            const t3 = Mv({ encoderConfig: e3 });
            (Hh() || Yh() || tp()) && (t3.deviceId = void 0), OE.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e3), JSON.stringify(t3));
            try {
              await this._originMediaStreamTrack.applyConstraints(t3), this.updateMediaStreamTrackResolution();
            } catch (e4) {
              const t4 = new SE(fE.UNEXPECTED_ERROR, e4.toString());
              throw OE.error("[".concat(this.getTrackId(), "] applyConstraints error"), t4.toString()), t4;
            }
          }
          this._encoderConfig = e3, -1 === this._hints.indexOf(lS.SCREEN_TRACK) && this.updateBitrateFromProfile();
          try {
            await rC(this, uS.NEED_UPDATE_VIDEO_ENCODER, this);
          } catch (e4) {
            return e4.throw();
          }
        }
        getStats() {
          hC(() => {
            OE.warning("[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead");
          }, "localVideoTrackGetStatsWarning");
          const e3 = oC(this, uS.GET_STATS);
          return e3 || Iy({}, Ff);
        }
        async setBeautyEffect(e3) {
          OE.error("LocalVideoTrack.setBeautyEffect was deprecated, please migrate to agora-extension-beauty-effect");
        }
        getCurrentFrameData() {
          return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);
        }
        async getCurrentFrameImage(e3) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
          return this._player ? this._player.getCurrentFrameToUint8Array(e3, t2) : await Nv(e3);
        }
        clone(t2, i2, n2, r2) {
          const o2 = this._mediaStreamTrack.clone();
          return new e2(o2, t2, i2, n2, r2);
        }
        async setBitrateLimit(e3) {
          if (OE.debug("[".concat(this.getTrackId(), "] set bitrate limit, ").concat(JSON.stringify(e3))), e3) {
            this._forceBitrateLimit = e3, this._encoderConfig && (this._encoderConfig.bitrateMax ? this._encoderConfig.bitrateMax = this._encoderConfig.bitrateMax < e3.max_bitrate ? this._encoderConfig.bitrateMax : e3.max_bitrate : this._encoderConfig.bitrateMax = e3.max_bitrate, this._encoderConfig.bitrateMin, this._encoderConfig.bitrateMin = e3.min_bitrate);
            try {
              await rC(this, uS.NEED_UPDATE_VIDEO_ENCODER, this);
            } catch (e4) {
              return e4.throw();
            }
          }
        }
        async setOptimizationMode(e3) {
          if ("motion" !== e3 && "detail" !== e3 && "balanced" !== e3)
            return void OE.error(fE.INVALID_PARAMS, "optimization mode must be motion, detail or balanced");
          const t2 = this._optimizationMode;
          try {
            this._optimizationMode = e3, await rC(this, uS.SET_OPTIMIZATION_MODE, this);
          } catch (e4) {
            throw this._optimizationMode = t2, OE.error("[".concat(this.getTrackId(), "] set optimization mode failed"), e4.toString()), e4;
          }
          OE.info("[".concat(this.getTrackId(), "] set optimization mode success (").concat(e3, ")"));
        }
        setScalabiltyMode(e3) {
          if (1 === e3.numSpatialLayers && 1 !== e3.numTemporalLayers)
            return OE.error(fE.INVALID_PARAMS, "scalability mode currently not supported, no SVC."), void (this._scalabiltyMode = { numSpatialLayers: 1, numTemporalLayers: 1 });
          this._scalabiltyMode = e3, OE.info("[".concat(this.getTrackId(), "] set scalability mode success (").concat(e3, ")"));
        }
        updateMediaStreamTrackResolution() {
          tC(this._originMediaStreamTrack).then((e3) => {
            let [t2, i2] = e3;
            this._videoHeight = i2, this._videoWidth = t2;
          }).catch(eC);
        }
        _updatePlayerSource() {
          this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
        }
        _getDefaultPlayerConfig() {
          return { fit: "contain" };
        }
        updateBitrateFromProfile() {
          if (!this._encoderConfig)
            return;
          const { width: e3, height: t2, frameRate: i2 } = this.getMediaStreamTrackSettings();
          if (!e3 || !t2 || !i2)
            return;
          const [n2, r2] = function(e4, t3, i3) {
            const n3 = GE("BITRATE_ADAPTER_TYPE");
            let r3;
            const o2 = 200 * Math.pow(i3 / 15, 0.6) * Math.pow(e4 * t3 / 640 / 360, 0.75), s2 = o2;
            if ("STANDARD_BITRATE" === n3)
              r3 = 4 * o2;
            else {
              if ("COMPATIABLE_BITRATE" !== n3)
                return;
              r3 = 2 * o2;
            }
            return [Math.floor(r3), Math.floor(s2)];
          }(e3, t2, i2) || [void 0, void 0];
          this._encoderConfig.bitrateMin || this._encoderConfig.bitrateMax || (this._encoderConfig.bitrateMin = r2, this._encoderConfig.bitrateMax = n2, OE.debug("[".concat(this.getTrackId(), "] update bitrate from profile, [w: ").concat(e3, ", h: ").concat(t2, ", fps: ").concat(i2, "] => [brMax: ").concat(n2, ", brMin: ").concat(r2, "]")));
        }
        getVideoElementVisibleStatus() {
          try {
            var e3, t2;
            const i2 = null == this || null === (e3 = this._player) || void 0 === e3 ? void 0 : e3.getContainerElement(), n2 = { track: this, element: null == this || null === (t2 = this._player) || void 0 === t2 ? void 0 : t2.getVideoElement(), slot: null == i2 ? void 0 : i2.parentElement }, { element: r2, slot: o2 } = n2;
            if (this.isPlaying && r2 instanceof HTMLVideoElement && o2 instanceof HTMLElement) {
              const e4 = gy.checkOneElementVisible(r2), t3 = Object.assign({}, e4);
              if (t3.visible !== this._previousVideoVisibleStatus) {
                this._previousVideoVisibleStatus = t3.visible;
                const e5 = Pg.reportApiInvoke(null, { tag: Ef.TRACER, name: _f.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] });
                t3.visible ? e5.onSuccess("Video is visible") : e5.onSuccess("Invisible because of ".concat(t3.reason));
              }
              return t3;
            }
            return;
          } catch (e4) {
            throw new SE(fE.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e4.message);
          }
        }
        async renewMediaStreamTrack(e3) {
        }
        pipe(e3) {
          if (this.processor === e3)
            return e3;
          if (e3._source)
            throw new SE(fE.INVALID_OPERATION, "Processor ".concat(e3.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e3, this.processor._source = this, e3.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), e3;
        }
        unpipe() {
          if (!this.processor)
            return;
          const e3 = this.processor;
          this.processor._source = void 0, this.processor = void 0, e3.reset();
        }
        close() {
          super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe();
        }
        async replaceTrack(e3, t2) {
          if (!(e3 instanceof MediaStreamTrack))
            throw new SE(fE.INVALID_PARAMS, "track should be an instance of MediaStreamTrack");
          if ("video" !== e3.kind)
            throw new SE(fE.INVALID_PARAMS, "track should be a video MediaStreamTrack");
          await this._updateOriginMediaStreamTrack(e3, t2, true), this.updateMediaStreamTrackResolution();
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(kS.ON_TRACK, async (e3) => {
            e3 ? e3 !== this._mediaStreamTrack && (this._mediaStreamTrack = e3, this._updatePlayerSource(), await rC(this, uS.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await rC(this, uS.NEED_REPLACE_TRACK, this));
          });
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(kS.ON_TRACK);
        }
        unbindProcessorContextEvents() {
          this.processorContext.removeAllListeners(MS.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(MS.REQUEST_CONSTRAINTS);
        }
      }).prototype, "play", [Fv, Bv], Object.getOwnPropertyDescriptor(uy.prototype, "play"), uy.prototype), ag(uy.prototype, "stop", [Gv], Object.getOwnPropertyDescriptor(uy.prototype, "stop"), uy.prototype), ag(uy.prototype, "setEnabled", [Wv, Hv, Kv], Object.getOwnPropertyDescriptor(uy.prototype, "setEnabled"), uy.prototype), ag(uy.prototype, "setMuted", [Yv, qv, Jv], Object.getOwnPropertyDescriptor(uy.prototype, "setMuted"), uy.prototype), ag(uy.prototype, "setEncoderConfiguration", [Xv, zv], Object.getOwnPropertyDescriptor(uy.prototype, "setEncoderConfiguration"), uy.prototype), ag(uy.prototype, "getStats", [Qv], Object.getOwnPropertyDescriptor(uy.prototype, "getStats"), uy.prototype), ag(uy.prototype, "setBeautyEffect", [Zv, $v], Object.getOwnPropertyDescriptor(uy.prototype, "setBeautyEffect"), uy.prototype), ag(uy.prototype, "getCurrentFrameData", [ey], Object.getOwnPropertyDescriptor(uy.prototype, "getCurrentFrameData"), uy.prototype), ag(uy.prototype, "getCurrentFrameImage", [ty], Object.getOwnPropertyDescriptor(uy.prototype, "getCurrentFrameImage"), uy.prototype), ag(uy.prototype, "setBitrateLimit", [iy], Object.getOwnPropertyDescriptor(uy.prototype, "setBitrateLimit"), uy.prototype), ag(uy.prototype, "setOptimizationMode", [ny], Object.getOwnPropertyDescriptor(uy.prototype, "setOptimizationMode"), uy.prototype), ag(uy.prototype, "setScalabiltyMode", [ry], Object.getOwnPropertyDescriptor(uy.prototype, "setScalabiltyMode"), uy.prototype), ag(uy.prototype, "updateMediaStreamTrackResolution", [oy], Object.getOwnPropertyDescriptor(uy.prototype, "updateMediaStreamTrackResolution"), uy.prototype), ag(uy.prototype, "pipe", [sy], Object.getOwnPropertyDescriptor(uy.prototype, "pipe"), uy.prototype), ag(uy.prototype, "unpipe", [ay], Object.getOwnPropertyDescriptor(uy.prototype, "unpipe"), uy.prototype), ag(uy.prototype, "close", [cy], Object.getOwnPropertyDescriptor(uy.prototype, "close"), uy.prototype), ag(uy.prototype, "replaceTrack", [dy], Object.getOwnPropertyDescriptor(uy.prototype, "replaceTrack"), uy.prototype), uy), vy = (ly = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), hy = _R(), py = xg("CameraVideoTrack", "_enabledMutex"), _y = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), Ey = _R(), my = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), fy = _R(), Sy = Dg({ argsMap: (e2) => [e2.getTrackId()] }), ag((Ty = class extends Cy {
        get __className__() {
          return "CameraVideoTrack";
        }
        constructor(e2, t2, i2, n2, r2, o2) {
          super(e2, UE(t2.encoderConfig), n2, r2, o2), _p(this, "_config", void 0), _p(this, "_originalConstraints", void 0), _p(this, "_constraints", void 0), _p(this, "_enabled", true), _p(this, "_deviceName", "default"), _p(this, "tryResumeVideoForIOS15_16WeChat", async () => {
            (Zh() || $h()) && !function() {
              const e3 = xh();
              if (e3.os !== bh.IOS || !e3.osVersion)
                return false;
              const t3 = e3.osVersion.split(".");
              return 15 === Number(t3[0]) && Number(t3[1]) >= 2;
            }() && ip() && this._enabled && !this._isClosed && (OE.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS 15 device on WeChat.")), await this.renewMediaStreamTrack());
          }), this._config = t2, this._originalConstraints = i2, this._constraints = i2, this._deviceName = e2.label, this._encoderConfig = UE(this._config.encoderConfig), Gg.on(kg.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), Gg.on(kg.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), this.bindProcessorContextEvents();
        }
        async setDevice(e2) {
          if (OE.info("[".concat(this.getTrackId(), "] set device to ").concat(e2)), this._enabled)
            try {
              const t2 = await lR.getDeviceById(e2), i2 = {};
              i2.video = Iy({}, this._constraints), i2.video.deviceId = { exact: e2 }, i2.video.facingMode = void 0, this._originMediaStreamTrack.stop();
              let n2 = null;
              try {
                n2 = await aR(i2, this.getTrackId());
              } catch (e3) {
                throw OE.error("[".concat(this.getTrackId(), "] setDevice failed"), e3.toString()), n2 = await aR({ video: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(n2.getVideoTracks()[0], false), e3;
              }
              await this._updateOriginMediaStreamTrack(n2.getVideoTracks()[0], false), this.updateMediaStreamTrackResolution(), this._deviceName = t2.label, this._config.cameraId = e2, this._constraints.deviceId = { exact: e2 };
            } catch (e3) {
              throw OE.error("[".concat(this.getTrackId(), "] setDevice error"), e3.toString()), e3;
            }
          else
            try {
              const t2 = await lR.getDeviceById(e2);
              this._deviceName = t2.label, this._config.cameraId = e2, this._constraints.deviceId = { exact: e2 };
            } catch (e3) {
              throw OE.error("[".concat(this.getTrackId(), "] setDevice error"), e3.toString()), e3;
            }
          OE.info("[".concat(this.getTrackId(), "] setDevice success"));
        }
        async setEnabled(e2, t2) {
          if (!t2) {
            if (e2 === this._enabled)
              return;
            this.stateCheck("enabled", e2);
          }
          if (OE.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), e2) {
            try {
              if (this.isExternalTrack)
                this._originMediaStreamTrack.enabled = true;
              else {
                const e3 = await aR({ video: this._constraints }, this.getTrackId());
                await this._updateOriginMediaStreamTrack(e3.getVideoTracks()[0], false);
              }
              await rC(this, uS.NEED_ENABLE_TRACK, this);
            } catch (e3) {
              throw OE.error("[".concat(this.getTrackId(), "] setEnabled true error"), e3.toString()), e3;
            }
            this.updateMediaStreamTrackResolution(), OE.info("[".concat(this.getTrackId(), "] setEnabled to true success")), t2 || (this._enabled = true);
          } else {
            this.isExternalTrack ? this._originMediaStreamTrack.enabled = false : (this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop()), t2 || (this._enabled = false);
            try {
              await rC(this, uS.NEED_DISABLE_TRACK, this);
            } catch (e3) {
              throw OE.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e3.toString()), e3;
            }
            OE.info("[".concat(this.getTrackId(), "] setEnabled to false success"));
          }
        }
        async setEncoderConfiguration(e2, t2) {
          if (!this._enabled)
            throw new SE(fE.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
          e2 = UE(e2), this._forceBitrateLimit && (e2.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e2.bitrateMax, e2.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e2.bitrateMin);
          const i2 = uC(this._config);
          i2.encoderConfig = e2;
          const n2 = Mv(i2);
          (Hh() || Yh() || tp()) && (n2.deviceId = void 0), OE.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e2), JSON.stringify(n2));
          try {
            await this._originMediaStreamTrack.applyConstraints(n2), this.updateMediaStreamTrackResolution();
          } catch (e3) {
            const t3 = new SE(fE.UNEXPECTED_ERROR, e3.toString());
            throw OE.error("[".concat(this.getTrackId(), "] applyConstraints error"), t3.toString()), t3;
          }
          this._config = i2, this._constraints = n2, this._originalConstraints = n2, this._encoderConfig = e2, -1 === this._hints.indexOf(lS.SCREEN_TRACK) && this.updateBitrateFromProfile();
          try {
            await rC(this, uS.NEED_UPDATE_VIDEO_ENCODER, this);
          } catch (e3) {
            return e3.throw();
          }
        }
        _getDefaultPlayerConfig() {
          return { mirror: true, fit: "cover" };
        }
        onTrackEnded() {
          if ((Yh() || tp()) && this._enabled && !this._isClosed && Gg.duringInterruption) {
            const e2 = async () => {
              Gg.off(kg.IOS_INTERRUPTION_END, e2), this._enabled && !this._isClosed && (OE.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS device.")), await this.setEnabled(false), await this.setEnabled(true));
            };
            Gg.on(kg.IOS_INTERRUPTION_END, e2);
          } else
            OE.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(mS.TRACK_ENDED);
        }
        async renewMediaStreamTrack(e2) {
          const t2 = e2 || this._constraints, i2 = lR.searchDeviceIdByName(this._deviceName);
          if (i2 && !t2.deviceId && (t2.deviceId = { exact: i2 }), this._enabled) {
            const e3 = await aR({ video: t2 }, this.getTrackId());
            this._constraints = t2, await this._updateOriginMediaStreamTrack(e3.getVideoTracks()[0], true), this.updateMediaStreamTrackResolution();
          }
        }
        close() {
          super.close(), Gg.off(kg.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), Gg.off(kg.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat);
        }
        bindProcessorContextEvents() {
          this.processorContext.on(MS.REQUEST_UPDATE_CONSTRAINTS, async (e2, t2, i2) => {
            try {
              const i3 = Object.assign({}, this._originalConstraints, ...e2);
              await this.renewMediaStreamTrack(i3), t2();
            } catch (e3) {
              i2(e3);
            }
          }), this.processorContext.on(MS.REQUEST_CONSTRAINTS, async (e2) => {
            e2(this._originMediaStreamTrack.getSettings());
          });
        }
      }).prototype, "setDevice", [ly, hy], Object.getOwnPropertyDescriptor(Ty.prototype, "setDevice"), Ty.prototype), ag(Ty.prototype, "setEnabled", [py, _y, Ey], Object.getOwnPropertyDescriptor(Ty.prototype, "setEnabled"), Ty.prototype), ag(Ty.prototype, "setEncoderConfiguration", [my, fy], Object.getOwnPropertyDescriptor(Ty.prototype, "setEncoderConfiguration"), Ty.prototype), ag(Ty.prototype, "close", [Sy], Object.getOwnPropertyDescriptor(Ty.prototype, "close"), Ty.prototype), Ty);
      class yy {
        get hasVideo() {
          return this._video_enabled_ && !this._video_muted_ && this._video_added_;
        }
        get hasAudio() {
          return this._audio_enabled_ && !this._audio_muted_ && this._audio_added_;
        }
        get audioTrack() {
          if (this.hasAudio)
            return this._audioTrack;
        }
        get videoTrack() {
          if (this.hasVideo)
            return this._videoTrack;
        }
        constructor(e2, t2) {
          _p(this, "uid", void 0), _p(this, "_uintid", void 0), _p(this, "_trust_in_room_", true), _p(this, "_trust_audio_enabled_state_", true), _p(this, "_trust_video_enabled_state_", true), _p(this, "_trust_audio_mute_state_", true), _p(this, "_trust_video_mute_state_", true), _p(this, "_audio_muted_", false), _p(this, "_video_muted_", false), _p(this, "_audio_enabled_", true), _p(this, "_video_enabled_", true), _p(this, "_audio_added_", false), _p(this, "_video_added_", false), _p(this, "_trust_video_stream_added_state_", true), _p(this, "_trust_audio_stream_added_state_", true), _p(this, "_audioTrack", void 0), _p(this, "_videoTrack", void 0), _p(this, "_audioSSRC", void 0), _p(this, "_videoSSRC", void 0), _p(this, "_audioOrtc", void 0), _p(this, "_videoOrtc", void 0), _p(this, "_cname", void 0), _p(this, "_rtxSsrcId", void 0), this.uid = e2, this._uintid = t2;
        }
      }
      var Ay = fl, Oy = pd, Ny = Rd;
      Ii({ target: "Promise", stat: true }, { try: function(e2) {
        var t2 = Oy.f(this), i2 = Ny(e2);
        return (i2.error ? t2.reject : t2.resolve)(i2.value), t2.promise;
      } });
      var by = Ay, wy = Ii, Dy = h, Py = i, Ly = QS, ky = q, My = je, Uy = bi, xy = im, Vy = oT, jy = FT, Fy = ae, By = rt("isConcatSpreadable"), Gy = 9007199254740991, Wy = "Maximum allowed index exceeded", Hy = Dy.TypeError, Ky = Fy >= 51 || !Py(function() {
        var e2 = [];
        return e2[By] = false, e2.concat()[0] !== e2;
      }), Yy = jy("concat"), qy = function(e2) {
        if (!ky(e2))
          return false;
        var t2 = e2[By];
        return void 0 !== t2 ? !!t2 : Ly(e2);
      };
      wy({ target: "Array", proto: true, forced: !Ky || !Yy }, { concat: function(e2) {
        var t2, i2, n2, r2, o2, s2 = My(this), a2 = Vy(s2, 0), c2 = 0;
        for (t2 = -1, n2 = arguments.length; t2 < n2; t2++)
          if (qy(o2 = -1 === t2 ? s2 : arguments[t2])) {
            if (c2 + (r2 = Uy(o2)) > Gy)
              throw Hy(Wy);
            for (i2 = 0; i2 < r2; i2++, c2++)
              i2 in o2 && xy(a2, c2, o2[i2]);
          } else {
            if (c2 >= Gy)
              throw Hy(Wy);
            xy(a2, c2++, o2);
          }
        return a2.length = c2, a2;
      } });
      var Jy = {}, Xy = k, zy = K, Qy = Pn.f, Zy = cm, $y = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
      Jy.f = function(e2) {
        return $y && "Window" == Xy(e2) ? function(e3) {
          try {
            return Qy(e3);
          } catch (e4) {
            return Zy($y);
          }
        }(e2) : Qy(zy(e2));
      };
      var eA = {}, tA = rt;
      eA.f = tA;
      var iA = J, nA = Ge, rA = eA, oA = Ht.f, sA = function(e2) {
        var t2 = iA.Symbol || (iA.Symbol = {});
        nA(t2, e2) || oA(t2, e2, { value: rA.f(e2) });
      }, aA = Ii, cA = h, dA = $, uA = f, lA = C, hA = d, pA = g, _A = ue, EA = i, mA = Ge, fA = QS, SA = S, TA = q, gA = u, RA = fe, IA = zt, CA = je, vA = K, yA = Et, AA = wo, OA = w, NA = Pr, bA = hr, wA = Pn, DA = Jy, PA = Zn, LA = T, kA = Ht, MA = dr, UA = v, xA = pc, VA = xs, jA = we.exports, FA = Gn, BA = qe, GA = rt, WA = eA, HA = sA, KA = ta, YA = bs, qA = pT.forEach, JA = pn("hidden"), XA = "Symbol", zA = GA("toPrimitive"), QA = YA.set, ZA = YA.getterFor(XA), $A = Object.prototype, eO = cA.Symbol, tO = eO && eO.prototype, iO = cA.TypeError, nO = cA.QObject, rO = dA("JSON", "stringify"), oO = LA.f, sO = kA.f, aO = DA.f, cO = UA.f, dO = hA([].push), uO = jA("symbols"), lO = jA("op-symbols"), hO = jA("string-to-symbol-registry"), pO = jA("symbol-to-string-registry"), _O = jA("wks"), EO = !nO || !nO.prototype || !nO.prototype.findChild, mO = pA && EA(function() {
        return 7 != NA(sO({}, "a", { get: function() {
          return sO(this, "a", { value: 7 }).a;
        } })).a;
      }) ? function(e2, t2, i2) {
        var n2 = oO($A, t2);
        n2 && delete $A[t2], sO(e2, t2, i2), n2 && e2 !== $A && sO($A, t2, n2);
      } : sO, fO = function(e2, t2) {
        var i2 = uO[e2] = NA(tO);
        return QA(i2, { type: XA, tag: e2, description: t2 }), pA || (i2.description = t2), i2;
      }, SO = function(e2, t2, i2) {
        e2 === $A && SO(lO, t2, i2), IA(e2);
        var n2 = yA(t2);
        return IA(i2), mA(uO, n2) ? (i2.enumerable ? (mA(e2, JA) && e2[JA][n2] && (e2[JA][n2] = false), i2 = NA(i2, { enumerable: OA(0, false) })) : (mA(e2, JA) || sO(e2, JA, OA(1, {})), e2[JA][n2] = true), mO(e2, n2, i2)) : sO(e2, n2, i2);
      }, TO = function(e2, t2) {
        IA(e2);
        var i2 = vA(t2), n2 = bA(i2).concat(CO(i2));
        return qA(n2, function(t3) {
          pA && !lA(gO, i2, t3) || SO(e2, t3, i2[t3]);
        }), e2;
      }, gO = function(e2) {
        var t2 = yA(e2), i2 = lA(cO, this, t2);
        return !(this === $A && mA(uO, t2) && !mA(lO, t2)) && (!(i2 || !mA(this, t2) || !mA(uO, t2) || mA(this, JA) && this[JA][t2]) || i2);
      }, RO = function(e2, t2) {
        var i2 = vA(e2), n2 = yA(t2);
        if (i2 !== $A || !mA(uO, n2) || mA(lO, n2)) {
          var r2 = oO(i2, n2);
          return !r2 || !mA(uO, n2) || mA(i2, JA) && i2[JA][n2] || (r2.enumerable = true), r2;
        }
      }, IO = function(e2) {
        var t2 = aO(vA(e2)), i2 = [];
        return qA(t2, function(e3) {
          mA(uO, e3) || mA(FA, e3) || dO(i2, e3);
        }), i2;
      }, CO = function(e2) {
        var t2 = e2 === $A, i2 = aO(t2 ? lO : vA(e2)), n2 = [];
        return qA(i2, function(e3) {
          !mA(uO, e3) || t2 && !mA($A, e3) || dO(n2, uO[e3]);
        }), n2;
      };
      (_A || (VA(tO = (eO = function() {
        if (gA(tO, this))
          throw iO("Symbol is not a constructor");
        var e2 = arguments.length && void 0 !== arguments[0] ? AA(arguments[0]) : void 0, t2 = BA(e2), i2 = function(e3) {
          this === $A && lA(i2, lO, e3), mA(this, JA) && mA(this[JA], t2) && (this[JA][t2] = false), mO(this, t2, OA(1, e3));
        };
        return pA && EO && mO($A, t2, { configurable: true, set: i2 }), fO(t2, e2);
      }).prototype, "toString", function() {
        return ZA(this).tag;
      }), VA(eO, "withoutSetter", function(e2) {
        return fO(BA(e2), e2);
      }), UA.f = gO, kA.f = SO, MA.f = TO, LA.f = RO, wA.f = DA.f = IO, PA.f = CO, WA.f = function(e2) {
        return fO(GA(e2), e2);
      }, pA && sO(tO, "description", { configurable: true, get: function() {
        return ZA(this).description;
      } })), aA({ global: true, wrap: true, forced: !_A, sham: !_A }, { Symbol: eO }), qA(bA(_O), function(e2) {
        HA(e2);
      }), aA({ target: XA, stat: true, forced: !_A }, { for: function(e2) {
        var t2 = AA(e2);
        if (mA(hO, t2))
          return hO[t2];
        var i2 = eO(t2);
        return hO[t2] = i2, pO[i2] = t2, i2;
      }, keyFor: function(e2) {
        if (!RA(e2))
          throw iO(e2 + " is not a symbol");
        if (mA(pO, e2))
          return pO[e2];
      }, useSetter: function() {
        EO = true;
      }, useSimple: function() {
        EO = false;
      } }), aA({ target: "Object", stat: true, forced: !_A, sham: !pA }, { create: function(e2, t2) {
        return void 0 === t2 ? NA(e2) : TO(NA(e2), t2);
      }, defineProperty: SO, defineProperties: TO, getOwnPropertyDescriptor: RO }), aA({ target: "Object", stat: true, forced: !_A }, { getOwnPropertyNames: IO, getOwnPropertySymbols: CO }), aA({ target: "Object", stat: true, forced: EA(function() {
        PA.f(1);
      }) }, { getOwnPropertySymbols: function(e2) {
        return PA.f(CA(e2));
      } }), rO) && aA({ target: "JSON", stat: true, forced: !_A || EA(function() {
        var e2 = eO();
        return "[null]" != rO([e2]) || "{}" != rO({ a: e2 }) || "{}" != rO(Object(e2));
      }) }, { stringify: function(e2, t2, i2) {
        var n2 = xA(arguments), r2 = t2;
        if ((TA(t2) || void 0 !== e2) && !RA(e2))
          return fA(t2) || (t2 = function(e3, t3) {
            if (SA(r2) && (t3 = lA(r2, this, e3, t3)), !RA(t3))
              return t3;
          }), n2[1] = t2, uA(rO, null, n2);
      } });
      if (!tO[zA]) {
        var vO = tO.valueOf;
        VA(tO, zA, function(e2) {
          return lA(vO, this);
        });
      }
      KA(eO, XA), FA[JA] = true, sA("asyncIterator"), sA("hasInstance"), sA("isConcatSpreadable"), sA("iterator"), sA("match"), sA("matchAll"), sA("replace"), sA("search"), sA("species"), sA("split"), sA("toPrimitive"), sA("toStringTag"), sA("unscopables"), ta(h.JSON, "JSON", true);
      var yO = J.Symbol;
      sA("asyncDispose"), sA("dispose"), sA("matcher"), sA("metadata"), sA("observable"), sA("patternMatch"), sA("replaceAll");
      var AO = yO, OO = eA.f("asyncIterator"), NO = OO;
      function bO(e2) {
        this.wrapped = e2;
      }
      function wO(e2) {
        var t2, i2;
        function n2(t3, i3) {
          try {
            var o2 = e2[t3](i3), s2 = o2.value, a2 = s2 instanceof bO;
            by.resolve(a2 ? s2.wrapped : s2).then(function(e3) {
              a2 ? n2("return" === t3 ? "return" : "next", e3) : r2(o2.done ? "return" : "normal", e3);
            }, function(e3) {
              n2("throw", e3);
            });
          } catch (e3) {
            r2("throw", e3);
          }
        }
        function r2(e3, r3) {
          switch (e3) {
            case "return":
              t2.resolve({ value: r3, done: true });
              break;
            case "throw":
              t2.reject(r3);
              break;
            default:
              t2.resolve({ value: r3, done: false });
          }
          (t2 = t2.next) ? n2(t2.key, t2.arg) : i2 = null;
        }
        this._invoke = function(e3, r3) {
          return new by(function(o2, s2) {
            var a2 = { key: e3, arg: r3, resolve: o2, reject: s2, next: null };
            i2 ? i2 = i2.next = a2 : (t2 = i2 = a2, n2(e3, r3));
          });
        }, "function" != typeof e2.return && (this.return = void 0);
      }
      function DO(e2) {
        return function() {
          return new wO(e2.apply(this, arguments));
        };
      }
      function PO(e2) {
        return new bO(e2);
      }
      wO.prototype["function" == typeof AO && NO || "@@asyncIterator"] = function() {
        return this;
      }, wO.prototype.next = function(e2) {
        return this._invoke("next", e2);
      }, wO.prototype.throw = function(e2) {
        return this._invoke("throw", e2);
      }, wO.prototype.return = function(e2) {
        return this._invoke("return", e2);
      };
      var LO = eA.f("iterator");
      function kO(e2, t2) {
        var i2 = {}, n2 = false;
        function r2(i3, r3) {
          return n2 = true, r3 = new by(function(t3) {
            t3(e2[i3](r3));
          }), { done: false, value: t2(r3) };
        }
        return i2[void 0 !== AO && LO || "@@iterator"] = function() {
          return this;
        }, i2.next = function(e3) {
          return n2 ? (n2 = false, e3) : r2("next", e3);
        }, "function" == typeof e2.throw && (i2.throw = function(e3) {
          if (n2)
            throw n2 = false, e3;
          return r2("throw", e3);
        }), "function" == typeof e2.return && (i2.return = function(e3) {
          return n2 ? (n2 = false, e3) : r2("return", e3);
        }), i2;
      }
      var MO = OO, UO = { exports: {} };
      function xO(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function VO(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? xO(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : xO(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      function jO(e2, t2, i2, n2, r2, o2, s2) {
        let a2 = [], c2 = [], d2 = [], u2 = [], l2 = false, h2 = false;
        if (UO.exports.parse(e2).mediaDescriptions.forEach((e3) => {
          s2 && s2 !== e3.attributes.direction || ("video" !== e3.media.mediaType || l2 || (c2 = e3.attributes.payloads, u2 = e3.attributes.extmaps, l2 = true), "audio" !== e3.media.mediaType || h2 || (a2 = e3.attributes.payloads, d2 = e3.attributes.extmaps, h2 = true));
        }), !u2 || 0 === c2.length)
          throw new Error("Cannot get video capabilities from SDP.");
        if (!d2 || 0 === a2.length)
          throw new Error("Cannot get audio capabilities from SDP.");
        return c2.forEach((e3) => {
          var t3;
          null !== (t3 = e3.rtpMap) && void 0 !== t3 && t3.clockRate && (e3.rtpMap.clockRate = parseInt(e3.rtpMap.clockRate));
        }), a2.forEach((e3) => {
          var t3;
          null !== (t3 = e3.rtpMap) && void 0 !== t3 && t3.clockRate && (e3.rtpMap.clockRate = parseInt(e3.rtpMap.clockRate));
        }), t2 && (a2 = a2.filter((e3) => {
          var t3;
          return "rtx" !== (null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase());
        }), c2 = c2.filter((e3) => {
          var t3;
          return "rtx" !== (null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase());
        })), i2 && (c2 = c2.filter((e3) => {
          var t3;
          return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName) || "");
        })), n2 && (a2 = a2.filter((e3) => {
          var t3;
          return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName) || "");
        })), r2 && (null == r2 ? void 0 : r2.length) > 0 && (a2 = a2.filter((e3) => {
          var t3;
          return r2.includes((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "");
        })), o2 && (null == o2 ? void 0 : o2.length) > 0 && (c2 = c2.filter((e3) => {
          var t3;
          return o2.includes((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "");
        })), { audioCodecs: a2, videoCodecs: c2, audioExtensions: d2, videoExtensions: u2 };
      }
      function FO(e2) {
        const t2 = UO.exports.parse(e2);
        let i2, n2;
        for (const e3 of t2.mediaDescriptions) {
          if (!i2) {
            const t3 = e3.attributes.iceUfrag, n3 = e3.attributes.icePwd;
            if (!t3 || !n3)
              throw new Error("Cannot get iceUfrag or icePwd from SDP.");
            i2 = { iceUfrag: t3, icePwd: n3 };
          }
          if (!n2) {
            const t3 = e3.attributes.fingerprints;
            t3.length > 0 && (n2 = { fingerprints: t3 });
          }
        }
        if (!n2 && t2.attributes.fingerprints.length > 0 && (n2 = { fingerprints: t2.attributes.fingerprints }), !n2 || !i2)
          throw new Error("Cannot get iceParameters or dtlsParameters from SDP.");
        return { iceParameters: i2, dtlsParameters: n2 };
      }
      function BO(e2, t2) {
        const i2 = [], n2 = e2.attributes.ssrcGroups.filter((e3) => "FID" === e3.semantic), r2 = e2.attributes.ssrcGroups.find((e3) => "SIM" === e3.semantic), o2 = e2.attributes.ssrcs;
        if (r2)
          r2.ssrcIds.forEach((e3) => {
            var r3;
            const o3 = null === (r3 = n2.find((t3) => t3.ssrcIds[0] === e3)) || void 0 === r3 ? void 0 : r3.ssrcIds[1];
            i2.push({ ssrcId: e3, rtx: t2 ? o3 : void 0 });
          });
        else if (n2.length > 0) {
          const e3 = n2[0].ssrcIds[0], r3 = n2[0].ssrcIds[1];
          i2.push({ ssrcId: e3, rtx: t2 ? r3 : void 0 });
        } else {
          if (0 === o2.length)
            throw new Error("No ssrcs found on local media description.");
          i2.push({ ssrcId: o2[0].ssrcId });
        }
        return i2;
      }
      function GO(e2, t2) {
        const { cname: i2 } = e2;
        let n2;
        t2 && t2.ip && "number" == typeof t2.port ? (n2 = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t2.ip, port: t2.port.toString(), type: "host", extension: {} }], OE.debug("Using remote candidate from AP ".concat(t2.ip, ":").concat(t2.port)), t2.ip6 && (n2.push({ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t2.ip6, port: t2.port.toString(), type: "host", extension: {} }), OE.debug("Using IPV6 remote candidate from AP ".concat(t2.ip6, ":").concat(t2.port)))) : n2 = e2.iceParameters.candidates.map((e3) => ({ foundation: e3.foundation, componentId: "1", transport: e3.protocol, priority: e3.priority.toString(), connectionAddress: e3.ip, port: e3.port.toString(), type: e3.type, extension: {} }));
        const r2 = { fingerprints: e2.dtlsParameters.fingerprints.map((e3) => ({ hashFunction: e3.algorithm, fingerprint: e3.fingerprint })) }, o2 = { iceUfrag: e2.iceParameters.iceUfrag, icePwd: e2.iceParameters.icePwd };
        let s2;
        switch (e2.dtlsParameters.role) {
          case "server":
            s2 = "passive";
            break;
          case "client":
            s2 = "active";
            break;
          case "auto":
            s2 = "actpass";
        }
        return { dtlsParameters: r2, iceParameters: o2, candidates: n2, rtpCapabilities: ZO(e2.rtpCapabilities), setup: s2, cname: i2 };
      }
      function WO(e2, t2, i2) {
        const n2 = [], r2 = [];
        return e2.forEach((e3) => {
          let { ssrcId: o2, rtx: s2 } = e3;
          const a2 = ZI(8, "track-"), c2 = { ssrcId: o2, attributes: VO({ label: a2, mslabel: i2 = i2 || ZI(10, ""), msid: "".concat(i2, " ").concat(a2) }, t2 && { cname: t2 }) };
          if (n2.push(c2), void 0 !== s2) {
            const e4 = { ssrcId: s2, attributes: VO({ label: a2, mslabel: i2, msid: "".concat(i2, " ").concat(a2) }, t2 && { cname: t2 }) };
            n2.push(e4), r2.push({ semantic: "FID", ssrcIds: [o2, s2] });
          }
        }), e2.length > 1 && r2.push({ semantic: "SIM", ssrcIds: e2.map((e3) => {
          let { ssrcId: t3 } = e3;
          return t3;
        }) }), { ssrcs: n2, ssrcGroups: r2 };
      }
      function HO(e2, t2) {
        t2 instanceof yI && e2.attributes.payloads.forEach((e3) => {
          var i2;
          const n2 = null === (i2 = e3.rtpMap) || void 0 === i2 ? void 0 : i2.encodingName.toLowerCase();
          if (!n2 || -1 === ["opus", "pcmu", "pcma", "g722"].indexOf(n2))
            return;
          e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters.minptime = "10", e3.fmtp.parameters.useinbandfec = "1";
          const r2 = t2._encoderConfig;
          r2 && "pcmu" !== n2 && "pcma" !== n2 && "g722" !== n2 && (r2.bitrate && !Kh() && (e3.fmtp.parameters.maxaveragebitrate = "".concat(Math.floor(1e3 * r2.bitrate))), r2.sampleRate && (e3.fmtp.parameters.maxplaybackrate = "".concat(r2.sampleRate), e3.fmtp.parameters["sprop-maxcapturerate"] = "".concat(r2.sampleRate)), r2.stereo && (e3.fmtp.parameters.stereo = "1", e3.fmtp.parameters["sprop-stereo"] = "1"));
        });
      }
      function KO(e2) {
        const t2 = e2.attributes.unrecognized.findIndex((e3) => "x-google-flag" === e3.attField && "conference" === e3.attValue);
        -1 !== t2 && e2.attributes.unrecognized.splice(t2, 1);
      }
      function YO(e2, t2) {
        if (!(t2 instanceof Cy && t2._encoderConfig && -1 === t2._hints.indexOf(lS.SCREEN_TRACK)))
          return;
        const i2 = t2._encoderConfig;
        JS().supportMinBitrate && i2.bitrateMin && e2.attributes.payloads.forEach((e3) => {
          var t3;
          ["h264", "h265", "vp8", "vp9", "av1"].includes((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "") && (e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters["x-google-min-bitrate"] = "".concat(i2.bitrateMin));
        }), JS().supportMinBitrate && !t2._hints.includes(lS.LOW_STREAM) && i2.bitrateMax && e2.attributes.payloads.forEach((e3) => {
          var t3;
          ["h264", "h265", "vp8", "vp9", "av1"].includes((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "") && (e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters["x-google-start-bitrate"] = "".concat(GE("X_GOOGLE_START_BITRATE") || Math.floor(i2.bitrateMax)));
        });
      }
      function qO(e2) {
        if ("video" !== e2.media.mediaType)
          return;
        const t2 = xh();
        if (t2.name !== wh.SAFARI && t2.os !== bh.IOS)
          return;
        const i2 = e2.attributes.extmaps.findIndex((e3) => /video-orientation/g.test(e3.extensionName));
        -1 !== i2 && e2.attributes.extmaps.splice(i2, 1);
      }
      function JO(e2, t2, i2) {
        if (!t2)
          return;
        let n2, r2;
        if ("video" === e2.media.mediaType ? (n2 = i2.videoExtensions, r2 = i2.videoCodecs) : (n2 = i2.audioExtensions, r2 = i2.audioCodecs), true === t2.twcc) {
          const t3 = n2.find((e3) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e3.extensionName);
          if (t3) {
            e2.attributes.extmaps.find((e3) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e3.extensionName) || e2.attributes.extmaps.push({ entry: t3.entry, extensionName: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" });
            (function(e3, t4) {
              return t4.filter((t5) => !!e3.find((e4) => e4.payloadType === t5.payloadType && !!e4.rtcpFeedbacks.find((e5) => "transport-cc" === e5.type)));
            })(r2, e2.attributes.payloads).forEach((e3) => {
              e3.rtcpFeedbacks.find((e4) => "transport-cc" === e4.type) || e3.rtcpFeedbacks.push({ type: "transport-cc" });
            });
          }
        } else if (false === t2.twcc) {
          const t3 = e2.attributes.extmaps.findIndex((e3) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e3.extensionName);
          -1 !== t3 && e2.attributes.extmaps.splice(t3, 1), e2.attributes.payloads.forEach((e3) => {
            const t4 = e3.rtcpFeedbacks.findIndex((e4) => "transport-cc" === e4.type);
            -1 !== t4 && e3.rtcpFeedbacks.splice(t4, 1);
          });
        }
        if (true === t2.remb) {
          const t3 = n2.find((e3) => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e3.extensionName);
          if (t3) {
            e2.attributes.extmaps.find((e3) => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e3.extensionName) || e2.attributes.extmaps.push({ entry: t3.entry, extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" });
            (function(e3, t4) {
              return t4.filter((t5) => !!e3.find((e4) => e4.payloadType === t5.payloadType && !!e4.rtcpFeedbacks.find((e5) => "goog-remb" === e5.type)));
            })(r2, e2.attributes.payloads).forEach((e3) => {
              e3.rtcpFeedbacks.find((e4) => "goog-remb" === e4.type) || e3.rtcpFeedbacks.push({ type: "goog-remb" });
            });
          }
        } else if (false === t2.remb) {
          const t3 = e2.attributes.extmaps.findIndex((e3) => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e3.extensionName);
          -1 !== t3 && e2.attributes.extmaps.splice(t3, 1), e2.attributes.payloads.forEach((e3) => {
            const t4 = e3.rtcpFeedbacks.findIndex((e4) => "goog-remb" === e4.type);
            -1 !== t4 && e3.rtcpFeedbacks.splice(t4, 1);
          });
        }
      }
      function XO(e2, t2, i2) {
        if (Kh())
          return;
        if ("video" !== e2.media.mediaType)
          return;
        if (!(t2 instanceof Cy))
          return;
        if ("vp9" !== i2 && "vp8" !== i2)
          return;
        if ("vp8" === i2 && !GE("SIMULCAST"))
          return;
        if (void 0 === t2._scalabiltyMode || t2._scalabiltyMode.numSpatialLayers <= 1)
          return;
        const n2 = "vp8" === i2 ? 2 : t2._scalabiltyMode.numSpatialLayers, r2 = e2.attributes.ssrcs[0], o2 = e2.attributes.ssrcGroups.find((e3) => "FID" === e3.semantic && e3.ssrcIds[0] === r2.ssrcId), s2 = { semantic: "SIM", ssrcIds: [r2.ssrcId] };
        for (let t3 = 1; t3 < n2; t3++)
          e2.attributes.ssrcs.push({ ssrcId: r2.ssrcId + t3, attributes: uC(r2.attributes) }), s2.ssrcIds.push(r2.ssrcId + t3), o2 && (e2.attributes.ssrcs.push({ ssrcId: o2.ssrcIds[1] + t3, attributes: uC(r2.attributes) }), e2.attributes.ssrcGroups.push({ semantic: "FID", ssrcIds: [r2.ssrcId + t3, o2.ssrcIds[1] + t3] }));
        e2.attributes.ssrcGroups.unshift(s2);
      }
      async function zO(e2, t2, i2, n2, r2) {
        const o2 = new RTCPeerConnection();
        o2.addTransceiver("video", { direction: "sendonly" }), o2.addTransceiver("audio", { direction: "sendonly" }), o2.addTransceiver("video", { direction: "recvonly" }), o2.addTransceiver("audio", { direction: "recvonly" });
        const s2 = (await o2.createOffer()).sdp, a2 = jO(s2, e2, t2, i2, n2, r2, "sendonly"), c2 = jO(s2, e2, t2, i2, n2, r2, "recvonly"), d2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, u2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, l2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
        if (QO(a2, c2, "videoExtensions", d2, u2, l2), QO(a2, c2, "videoCodecs", d2, u2, l2), QO(a2, c2, "audioExtensions", d2, u2, l2), QO(a2, c2, "audioCodecs", d2, u2, l2), GE("RAISE_H264_BASELINE_PRIORITY")) {
          const e3 = l2.videoCodecs.findIndex((e4) => {
            var t3, i3;
            return "h264" === (null === (t3 = e4.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLocaleLowerCase()) && "42001f" === (null === (i3 = e4.fmtp) || void 0 === i3 ? void 0 : i3.parameters["profile-level-id"]);
          });
          if (-1 !== e3) {
            const t3 = l2.videoCodecs.findIndex((e4) => {
              var t4;
              return "h264" === (null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLocaleLowerCase());
            });
            if (t3 < e3) {
              OE.debug("raising H264 baseline profile priority");
              const i3 = l2.videoCodecs[e3];
              l2.videoCodecs.splice(e3, 1), l2.videoCodecs.splice(t3, 0, i3);
            }
            -1 !== t3 && (u2.videoCodecs = u2.videoCodecs.filter((e4) => {
              var t4, i3;
              return !("h264" === (null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLocaleLowerCase()) && "42001f" !== (null === (i3 = e4.fmtp) || void 0 === i3 ? void 0 : i3.parameters["profile-level-id"]));
            })), -1 !== t3 && GE("FILTER_SEND_H264_BASELINE") && (d2.videoCodecs = d2.videoCodecs.filter((e4) => {
              var t4, i3;
              return !("h264" === (null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLocaleLowerCase()) && "42001f" !== (null === (i3 = e4.fmtp) || void 0 === i3 ? void 0 : i3.parameters["profile-level-id"]));
            }));
          }
        }
        try {
          o2.close();
        } catch (e3) {
        }
        return { send: d2, recv: u2, sendrecv: l2 };
      }
      function QO(e2, t2, i2, n2, r2, o2) {
        if ("videoExtensions" === i2 || "audioExtensions" === i2) {
          const s2 = [];
          return e2[i2].forEach((e3) => {
            t2[i2].some((t3, i3) => {
              if (e3.entry === t3.entry && e3.extensionName === t3.extensionName)
                return s2.push(i3), true;
            }) ? o2[i2].push(e3) : n2[i2].push(e3);
          }), void t2[i2].forEach((e3, t3) => {
            -1 === s2.indexOf(t3) && r2[i2].push(e3);
          });
        }
        if ("videoCodecs" === i2 || "audioCodecs" === i2) {
          const s2 = [];
          return e2[i2].forEach((e3) => {
            t2[i2].some((t3, i3) => {
              if (e3.payloadType === t3.payloadType && JSON.stringify(e3) === JSON.stringify(t3))
                return s2.push(i3), true;
            }) ? o2[i2].push(e3) : n2[i2].push(e3);
          }), void t2[i2].forEach((e3, t3) => {
            -1 === s2.indexOf(t3) && r2[i2].push(e3);
          });
        }
      }
      function ZO(e2) {
        const { send: t2, recv: i2, sendrecv: n2 } = e2;
        if (!n2) {
          if (!t2 || !i2)
            throw new Error("cannot merge rtp capabilities because one of send or recv is empty!");
          return { send: t2, recv: i2 };
        }
        let r2, o2;
        return t2 ? (r2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, r2.audioCodecs = [...t2.audioCodecs, ...n2.audioCodecs], r2.videoCodecs = [...t2.videoCodecs, ...n2.videoCodecs], r2.audioExtensions = [...t2.audioExtensions, ...n2.audioExtensions], r2.videoExtensions = [...t2.videoExtensions, ...n2.videoExtensions]) : r2 = n2, i2 ? (o2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, o2.audioCodecs = [...i2.audioCodecs, ...n2.audioCodecs], o2.videoCodecs = [...i2.videoCodecs, ...n2.videoCodecs], o2.audioExtensions = [...i2.audioExtensions, ...n2.audioExtensions], o2.videoExtensions = [...i2.videoExtensions, ...n2.videoExtensions]) : o2 = n2, { send: r2, recv: o2 };
      }
      function $O(e2) {
        if ("audio" !== e2.media.mediaType)
          return;
        e2.attributes.payloads.filter((e3) => {
          var t2;
          return "opus" === (null === (t2 = e3.rtpMap) || void 0 === t2 ? void 0 : t2.encodingName.toLowerCase());
        }).forEach((e3) => {
          e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters.stereo = "1", e3.fmtp.parameters["sprop-stereo"] = "1";
        });
      }
      function eN(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function tN(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? eN(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : eN(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      !function(e2, t2) {
        e2.exports = (() => {
          var e3 = { 8: (e4, t4, i3) => {
            i3.r(t4), i3.d(t4, { Parser: () => I2, Printer: () => O2, parse: () => D2, print: () => P2 });
            const n2 = "\n", r2 = "".concat("\r").concat(n2), o2 = " ";
            let s2;
            function a2(e5) {
              return e5 >= "0" && e5 <= "9";
            }
            function c2(e5) {
              return e5 >= "!" && e5 <= "~";
            }
            function d2(e5) {
              return c2(e5) || e5 >= "\x80" && e5 <= "\xFF";
            }
            function u2(e5) {
              return "!" === e5 || e5 >= "#" && e5 <= "'" || e5 >= "*" && e5 <= "+" || e5 >= "-" && e5 <= "." || e5 >= "0" && e5 <= "9" || e5 >= "A" && e5 <= "Z" || e5 >= "^" && e5 <= "~";
            }
            function l2(e5) {
              return e5 >= "1" && e5 <= "9";
            }
            function h2(e5) {
              return e5 >= "A" && e5 <= "Z" || e5 >= "a" && e5 <= "z";
            }
            function p2(e5) {
              return "d" === e5 || "h" === e5 || "m" === e5 || "s" === e5;
            }
            function _2(e5) {
              return e5 > "" && e5 < "	" || e5 > "\v" && e5 < "\f" || e5 > "" && e5 < "\xFF";
            }
            function E2(e5) {
              return h2(e5) || a2(e5) || "+" === e5 || "/" === e5;
            }
            function m2(e5) {
              return a2(e5) || h2(e5) || "+" === e5 || "/" === e5 || "-" === e5 || "_" === e5;
            }
            function f2(e5) {
              return h2(e5) || a2(e5) || "+" === e5 || "/" === e5;
            }
            function S2(e5, t5) {
              var i4 = Object.keys(e5);
              if (Object.getOwnPropertySymbols) {
                var n3 = Object.getOwnPropertySymbols(e5);
                t5 && (n3 = n3.filter(function(t6) {
                  return Object.getOwnPropertyDescriptor(e5, t6).enumerable;
                })), i4.push.apply(i4, n3);
              }
              return i4;
            }
            function T2(e5) {
              for (var t5 = 1; t5 < arguments.length; t5++) {
                var i4 = null != arguments[t5] ? arguments[t5] : {};
                t5 % 2 ? S2(Object(i4), true).forEach(function(t6) {
                  g2(e5, t6, i4[t6]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(i4)) : S2(Object(i4)).forEach(function(t6) {
                  Object.defineProperty(e5, t6, Object.getOwnPropertyDescriptor(i4, t6));
                });
              }
              return e5;
            }
            function g2(e5, t5, i4) {
              return t5 in e5 ? Object.defineProperty(e5, t5, { value: i4, enumerable: true, configurable: true, writable: true }) : e5[t5] = i4, e5;
            }
            !function(e5) {
              e5.VERSION = "v", e5.ORIGIN = "o", e5.SESSION_NAME = "s", e5.INFORMATION = "i", e5.URI = "u", e5.EMAIL = "e", e5.PHONE = "p", e5.CONNECTION = "c", e5.BANDWIDTH = "b", e5.TIME = "t", e5.REPEAT = "r", e5.ZONE_ADJUSTMENTS = "z", e5.KEY = "k", e5.ATTRIBUTE = "a", e5.MEDIA = "m";
            }(s2 || (s2 = {}));
            class R2 {
              consumeText(e5, t5) {
                let i4 = t5;
                for (; i4 < e5.length; ) {
                  const t6 = e5[i4];
                  if ("\0" === t6 || "\r" === t6 || t6 === n2)
                    break;
                  i4 += 1;
                }
                if (i4 - t5 == 0)
                  throw new Error("Invalid text, at ".concat(e5));
                return i4;
              }
              consumeUnicastAddress(e5, t5, i4) {
                return this.consumeTill(e5, t5, o2);
              }
              consumeOneOrMore(e5, t5, i4) {
                let n3 = t5;
                for (; i4(e5[n3]); )
                  n3++;
                if (n3 - t5 == 0)
                  throw new Error("Invalid rule at ".concat(t5, "."));
                return n3;
              }
              consumeSpace(e5, t5) {
                if (e5[t5] === o2)
                  return t5 + 1;
                throw new Error("Invalid space at ".concat(t5, "."));
              }
              consumeIP4Address(e5, t5) {
                let i4 = t5;
                for (let t6 = 0; t6 < 4; t6++)
                  if (i4 = this.consumeDecimalUChar(e5, i4), 3 !== t6) {
                    if ("." !== e5[i4])
                      throw new Error("Invalid IP4 address.");
                    i4++;
                  }
                return i4;
              }
              consumeDecimalUChar(e5, t5) {
                let i4 = t5;
                for (let t6 = 0; t6 < 3 && a2(e5[i4]); t6++, i4++)
                  ;
                if (i4 - t5 == 0)
                  throw new Error("Invalid decimal uchar.");
                const n3 = parseInt(e5.slice(t5, i4));
                if (n3 >= 0 && n3 <= 255)
                  return i4;
                throw new Error("Invalid decimal uchar");
              }
              consumeIP6Address(e5, t5) {
                let i4 = this.consumeHexpart(e5, t5);
                return ":" === e5[i4] ? (i4 += 1, i4 = this.consumeIP4Address(e5, i4), i4) : i4;
              }
              consumeHexpart(e5, t5) {
                let i4 = t5;
                if (":" === e5[i4] && ":" === e5[i4 + 1]) {
                  i4 += 2;
                  try {
                    i4 = this.consumeHexseq(e5, i4);
                  } catch (e6) {
                  }
                  return i4;
                }
                if (i4 = this.consumeHexseq(e5, i4), ":" === e5[i4] && ":" === e5[i4 + 1]) {
                  i4 += 2;
                  try {
                    i4 = this.consumeHexseq(e5, i4);
                  } catch (e6) {
                  }
                  return i4;
                }
                return i4;
              }
              consumeHexseq(e5, t5) {
                let i4 = t5;
                for (; i4 = this.consumeHex4(e5, i4), ":" === e5[i4] && ":" !== e5[i4 + 1]; )
                  i4 += 1;
                return i4;
              }
              consumeHex4(e5, t5) {
                let i4 = 0;
                for (; i4 < 4; i4++)
                  if (!((n3 = e5[t5 + i4]) >= "0" && n3 <= "9" || n3 >= "a" && n3 <= "f" || n3 >= "A" && n3 <= "F")) {
                    if (0 === i4)
                      throw new Error("Invalid hex 4");
                    break;
                  }
                var n3;
                return t5 + i4;
              }
              consumeFQDN(e5, t5) {
                let i4 = t5;
                for (; a2(e5[i4]) || h2(e5[i4]) || "-" === e5[i4] || "." === e5[i4]; )
                  i4 += 1;
                if (i4 - t5 < 4)
                  throw new Error("Invalid FQDN");
                return i4;
              }
              consumeExtnAddr(e5, t5) {
                return this.consumeOneOrMore(e5, t5, d2);
              }
              consumeMulticastAddress(e5, t5, i4) {
                switch (i4) {
                  case "IP4":
                  case "ip4":
                    return this.consumeIP4MulticastAddress(e5, t5);
                  case "IP6":
                  case "ip6":
                    return this.consumeIP6MulticastAddress(e5, t5);
                  default:
                    try {
                      return this.consumeFQDN(e5, t5);
                    } catch (i5) {
                      return this.consumeExtnAddr(e5, t5);
                    }
                }
              }
              consumeIP6MulticastAddress(e5, t5) {
                const i4 = this.consumeHexpart(e5, t5);
                return "/" === e5[i4] ? this.consumeInteger(e5, i4 + 1) : i4;
              }
              consumeIP4MulticastAddress(e5, t5) {
                let i4 = t5 + 3;
                const n3 = e5.slice(t5, i4), r3 = parseInt(n3);
                if (r3 < 224 || r3 > 239)
                  throw new Error("Invalid IP4 multicast address, IPv4 multicast addresses may be in the range 224.0.0.0 to 239.255.255.255.");
                for (let t6 = 0; t6 < 3; t6++) {
                  if ("." !== e5[i4])
                    throw new Error("Invalid IP4 multicast address.");
                  i4 += 1, i4 = this.consumeDecimalUChar(e5, i4);
                }
                return "/" === e5[i4] && (i4 += 1), i4 = this.consumeTTL(e5, i4), "/" === e5[i4] && (i4 = this.consumeInteger(e5, i4)), i4;
              }
              consumeInteger(e5, t5) {
                if (!l2(e5[t5]))
                  throw new Error("Invalid integer.");
                for (t5 += 1; a2(e5[t5]); )
                  t5 += 1;
                return t5;
              }
              consumeTTL(e5, t5) {
                if ("0" === e5[t5])
                  return t5 + 1;
                if (!l2(e5[t5]))
                  throw new Error("Invalid TTL.");
                t5 += 1;
                for (let i4 = 0; i4 < 2 && a2(e5[t5]); i4++)
                  t5 += 1;
                return t5;
              }
              consumeToken(e5, t5) {
                return this.consumeOneOrMore(e5, t5, u2);
              }
              consumeTime(e5, t5) {
                let i4 = t5;
                if ("0" === e5[i4])
                  return i4 + 1;
                for (l2(e5[i4]) && (i4 += 1); a2(e5[i4]); )
                  i4++;
                if (i4 - t5 < 10)
                  throw new Error("Invalid time");
                return i4;
              }
              consumeAddress(e5, t5) {
                return this.consumeTill(e5, t5, o2);
              }
              consumeTypedTime(e5, t5) {
                let i4 = t5;
                return i4 = this.consumeOneOrMore(e5, i4, a2), p2(e5[i4]) ? i4 + 1 : i4;
              }
              consumeRepeatInterval(e5, t5) {
                if (!l2(e5[t5]))
                  throw new Error("Invalid repeat interval");
                for (t5 += 1; a2(e5[t5]); )
                  t5 += 1;
                return p2(e5[t5]) && (t5 += 1), t5;
              }
              consumePort(e5, t5) {
                return this.consumeOneOrMore(e5, t5, a2);
              }
              consume(e5, t5, i4) {
                for (let n3 = 0; n3 < i4.length; n3++) {
                  if (t5 + n3 >= e5.length)
                    throw new Error("consume exceeding value length");
                  if (e5[t5 + n3] !== i4[n3])
                    throw new Error("consume ".concat(i4, " failed at ").concat(n3));
                }
                return t5 + i4.length;
              }
              consumeTill(e5, t5, i4) {
                let n3 = t5;
                for (; n3 < e5.length && ("string" != typeof i4 || e5[n3] !== i4) && ("function" != typeof i4 || !i4(e5[n3])); )
                  n3++;
                return n3;
              }
            }
            class I2 extends R2 {
              constructor() {
                super(), g2(this, "records", []), g2(this, "currentLine", 0);
              }
              parse(e5) {
                const t5 = this.probeEOL(e5);
                this.records = e5.split(t5).filter((e6) => !!e6.trim()).map(this.parseLine), this.currentLine = 0;
                const i4 = this.parseVersion(), n3 = this.parseOrigin(), r3 = this.parseSessionName(), o3 = this.parseInformation(), s3 = this.parseUri(), a3 = this.parseEmail(), c3 = this.parsePhone(), d3 = this.parseConnection(), u3 = this.parseBandWidth(), l3 = this.parseTimeFields(), h3 = this.parseKey(), p3 = this.parseSessionAttribute(), _3 = this.parseMediaDescription();
                if (this.currentLine !== this.records.length)
                  throw new Error("parsing failed, non exhaustive sdp lines.");
                return { version: i4, origin: n3, sessionName: r3, information: o3, uri: s3, emails: a3, phones: c3, connection: d3, bandwidths: u3, timeFields: l3, key: h3, attributes: p3, mediaDescriptions: _3 };
              }
              getCurrentRecord() {
                const e5 = this.records[this.currentLine];
                if (!e5)
                  throw new Error("Record doesn't exit.");
                return e5;
              }
              probeEOL(e5) {
                for (let t5 = 0; t5 < e5.length; t5++)
                  if (e5[t5] === n2)
                    return "\r" === e5[t5 - 1] ? r2 : n2;
                throw new Error("Invalid newline character.");
              }
              parseLine(e5, t5) {
                if (e5.length < 2)
                  throw new Error("Invalid sdp line, sdp line should be of form <type>=<value>.");
                const i4 = e5[0];
                if ("=" !== e5[1])
                  throw new Error('Invalid sdp line, <type> should be a single character followed by an "=" sign.');
                return { type: i4, value: e5.slice(2), line: t5, cur: 0 };
              }
              parseSessionAttribute() {
                const e5 = new v2();
                for (; this.currentLine < this.records.length; ) {
                  const t5 = this.getCurrentRecord();
                  if (t5.type !== s2.ATTRIBUTE)
                    break;
                  const i4 = { attField: this.extractOneOrMore(t5, (e6) => u2(e6) && ":" !== e6), _cur: 0 };
                  ":" === t5.value[t5.cur] && (t5.cur += 1, i4.attValue = this.extractOneOrMore(t5, _2)), e5.parse(i4), this.currentLine++;
                }
                return e5.digest();
              }
              parseMediaAttributes(e5) {
                const t5 = new y2(e5);
                for (; this.currentLine < this.records.length; ) {
                  const e6 = this.getCurrentRecord();
                  if (e6.type !== s2.ATTRIBUTE)
                    break;
                  const i4 = { attField: this.extractOneOrMore(e6, (e7) => u2(e7) && ":" !== e7), _cur: 0 };
                  ":" === e6.value[e6.cur] && (e6.cur += 1, i4.attValue = this.extractOneOrMore(e6, _2)), t5.parse(i4), this.currentLine++;
                }
                return t5.digest();
              }
              parseKey() {
                const e5 = this.getCurrentRecord();
                if (e5.type === s2.KEY) {
                  if ("prompt" === e5.value || "clear:" === e5.value || "base64:" === e5.value || "uri:" === e5.value)
                    return e5.value;
                  throw this.currentLine++, new Error("Invalid key.");
                }
              }
              parseZone() {
                const e5 = this.getCurrentRecord();
                if (e5.type === s2.ZONE_ADJUSTMENTS) {
                  const t5 = [];
                  for (; ; )
                    try {
                      const i4 = this.extract(e5, this.consumeTime);
                      this.consumeSpaceForRecord(e5);
                      let n3 = false;
                      "-" === e5.value[e5.cur] && (n3 = true, e5.cur += 1);
                      const r3 = this.extract(e5, this.consumeTypedTime);
                      t5.push({ time: i4, typedTime: r3, back: n3 });
                    } catch (e6) {
                      break;
                    }
                  if (0 === t5.length)
                    throw new Error("Invalid zone adjustments");
                  return this.currentLine++, t5;
                }
                return [];
              }
              parseRepeat() {
                const e5 = [];
                for (; ; ) {
                  const t5 = this.getCurrentRecord();
                  if (t5.type !== s2.REPEAT)
                    break;
                  {
                    const i4 = this.extract(t5, this.consumeRepeatInterval), n3 = this.parseTypedTime(t5);
                    e5.push({ repeatInterval: i4, typedTimes: n3 }), this.currentLine++;
                  }
                }
                return e5;
              }
              parseTypedTime(e5) {
                const t5 = [];
                for (; ; )
                  try {
                    this.consumeSpaceForRecord(e5), t5.push(this.extract(e5, this.consumeTypedTime));
                  } catch (e6) {
                    break;
                  }
                if (0 === t5.length)
                  throw new Error("Invalid typed time.");
                return t5;
              }
              parseTime() {
                const e5 = this.getCurrentRecord(), t5 = this.extract(e5, this.consumeTime);
                this.consumeSpaceForRecord(e5);
                const i4 = this.extract(e5, this.consumeTime);
                return this.currentLine++, { startTime: t5, stopTime: i4 };
              }
              parseBandWidth() {
                const e5 = [];
                for (; this.currentLine < this.records.length; ) {
                  const t5 = this.getCurrentRecord();
                  if (t5.type !== s2.BANDWIDTH)
                    break;
                  {
                    const i4 = this.extractOneOrMore(t5, u2);
                    if (":" !== t5.value[t5.cur])
                      throw new Error("Invalid bandwidth field.");
                    t5.cur++;
                    const n3 = this.extractOneOrMore(t5, a2);
                    e5.push({ bwtype: i4, bandwidth: n3 }), this.currentLine++;
                  }
                }
                return e5;
              }
              parseVersion() {
                const e5 = this.getCurrentRecord();
                if (e5.type !== s2.VERSION)
                  throw new Error("first sdp record must be version");
                const t5 = e5.value.slice(0, this.consumeOneOrMore(e5.value, 0, a2));
                if (t5.length !== e5.value.length)
                  throw new Error('invalid proto version, "v='.concat(e5.value, '"'));
                return this.currentLine++, t5;
              }
              parseOrigin() {
                const e5 = this.getCurrentRecord();
                if (e5.type !== s2.ORIGIN)
                  throw new Error("second line of sdp must be origin");
                const t5 = this.extractOneOrMore(e5, d2);
                this.consumeSpaceForRecord(e5);
                const i4 = this.extractOneOrMore(e5, a2);
                this.consumeSpaceForRecord(e5);
                const n3 = this.extractOneOrMore(e5, a2);
                this.consumeSpaceForRecord(e5);
                const r3 = this.extractOneOrMore(e5, u2);
                this.consumeSpaceForRecord(e5);
                const o3 = this.extractOneOrMore(e5, u2);
                this.consumeSpaceForRecord(e5);
                const c3 = this.extract(e5, this.consumeUnicastAddress);
                return this.currentLine++, { username: t5, sessId: i4, sessVersion: n3, nettype: r3, addrtype: o3, unicastAddress: c3 };
              }
              parseSessionName() {
                const e5 = this.getCurrentRecord();
                if (e5.type === s2.SESSION_NAME) {
                  const t5 = this.extract(e5, this.consumeText);
                  return this.currentLine++, t5;
                }
              }
              parseInformation() {
                const e5 = this.getCurrentRecord();
                if (e5.type !== s2.INFORMATION)
                  return;
                const t5 = this.extract(e5, this.consumeText);
                return this.currentLine++, t5;
              }
              parseUri() {
                const e5 = this.getCurrentRecord();
                if (e5.type === s2.URI)
                  return this.currentLine++, e5.value;
              }
              parseEmail() {
                const e5 = [];
                for (; ; ) {
                  const t5 = this.getCurrentRecord();
                  if (t5.type !== s2.EMAIL)
                    break;
                  e5.push(t5.value), this.currentLine++;
                }
                return e5;
              }
              parsePhone() {
                const e5 = [];
                for (; ; ) {
                  const t5 = this.getCurrentRecord();
                  if (t5.type !== s2.PHONE)
                    break;
                  e5.push(t5.value), this.currentLine++;
                }
                return e5;
              }
              parseConnection() {
                const e5 = this.getCurrentRecord();
                if (e5.type === s2.CONNECTION) {
                  const t5 = this.extractOneOrMore(e5, u2);
                  this.consumeSpaceForRecord(e5);
                  const i4 = this.extractOneOrMore(e5, u2);
                  this.consumeSpaceForRecord(e5);
                  const n3 = this.extract(e5, this.consumeAddress);
                  return this.currentLine++, { nettype: t5, addrtype: i4, address: n3 };
                }
              }
              parseMedia() {
                const e5 = this.getCurrentRecord(), t5 = this.extract(e5, this.consumeToken);
                this.consumeSpaceForRecord(e5);
                let i4 = this.extract(e5, this.consumePort);
                "/" === e5.value[e5.cur] && (e5.cur += 1, i4 += this.extract(e5, this.consumeInteger)), this.consumeSpaceForRecord(e5);
                const n3 = [];
                for (n3.push(this.extract(e5, this.consumeToken)); "/" === e5.value[e5.cur]; )
                  e5.cur += 1, n3.push(this.extract(e5, this.consumeToken));
                if (0 === n3.length)
                  throw new Error("Invalid proto");
                const r3 = this.parseFmt(e5);
                return this.currentLine++, { mediaType: t5, port: i4, protos: n3, fmts: r3 };
              }
              parseTimeFields() {
                const e5 = [];
                for (; this.getCurrentRecord().type === s2.TIME; ) {
                  const t5 = this.parseTime(), i4 = this.parseRepeat(), n3 = this.parseZone();
                  e5.push({ time: t5, repeats: i4, zones: n3 });
                }
                return e5;
              }
              parseMediaDescription() {
                const e5 = [];
                for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s2.MEDIA; ) {
                  const t5 = this.parseMedia(), i4 = this.parseInformation(), n3 = this.parseConnections(), r3 = this.parseBandWidth(), o3 = this.parseKey(), s3 = this.parseMediaAttributes(t5);
                  e5.push({ media: t5, information: i4, connections: n3, bandwidths: r3, key: o3, attributes: s3 });
                }
                return e5;
              }
              parseConnections() {
                const e5 = [];
                for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s2.CONNECTION; )
                  e5.push(this.parseConnection());
                return e5;
              }
              parseFmt(e5) {
                const t5 = [];
                for (; ; )
                  try {
                    this.consumeSpaceForRecord(e5), t5.push(this.extract(e5, this.consumeToken));
                  } catch (e6) {
                    break;
                  }
                if (0 === t5.length)
                  throw new Error("Invalid fmts");
                return t5;
              }
              extract(e5, t5, ...i4) {
                const n3 = t5.call(this, e5.value, e5.cur, ...i4), r3 = e5.value.slice(e5.cur, n3);
                return e5.cur = n3, r3;
              }
              extractOneOrMore(e5, t5) {
                const i4 = this.consumeOneOrMore(e5.value, e5.cur, t5), n3 = e5.value.slice(e5.cur, i4);
                return e5.cur = i4, n3;
              }
              consumeSpaceForRecord(e5) {
                if (e5.value[e5.cur] !== o2)
                  throw new Error("Invalid space at ".concat(e5.cur, "."));
                e5.cur += 1;
              }
            }
            class C2 extends R2 {
              constructor(...e5) {
                super(...e5), g2(this, "attributes", void 0), g2(this, "digested", false);
              }
              extractOneOrMore(e5, t5, i4) {
                const n3 = this.consumeOneOrMore(e5.attValue, e5._cur, t5), r3 = e5.attValue.slice(e5._cur, n3), [o3, s3] = i4 || [];
                if ("number" == typeof o3 && r3.length < o3)
                  throw new Error("error in length, should be more or equal than ".concat(o3, " characters."));
                if ("number" == typeof s3 && r3.length > s3)
                  throw new Error("error in length, should be less or equal than ".concat(s3, " characters."));
                return e5._cur = n3, r3;
              }
              consumeAttributeSpace(e5) {
                if (e5.attValue[e5._cur] !== o2)
                  throw new Error("Invalid space at ".concat(e5._cur, "."));
                e5._cur += 1;
              }
              extract(e5, t5, ...i4) {
                if (!e5.attValue)
                  throw new Error("Nothing to extract from attValue.");
                const n3 = t5.call(this, e5.attValue, e5._cur, ...i4), r3 = e5.attValue.slice(e5._cur, n3);
                return e5._cur = n3, r3;
              }
              atEnd(e5) {
                if (!e5.attValue)
                  throw new Error();
                return e5._cur >= e5.attValue.length;
              }
              peekChar(e5) {
                if (!e5.attValue)
                  throw new Error();
                return e5.attValue[e5._cur];
              }
              peek(e5, t5) {
                if (!e5.attValue)
                  throw new Error();
                for (let i4 = 0; i4 < t5.length; i4++)
                  if (t5[i4] !== e5.attValue[e5._cur + i4])
                    return false;
                return true;
              }
              parseIceUfrag(e5) {
                if (this.attributes.iceUfrag)
                  throw new Error("Invalid ice-ufrag, should be only a single line if 'a=ice-ufrag'");
                this.attributes.iceUfrag = this.extractOneOrMore(e5, E2, [4, 256]);
              }
              parseIcePwd(e5) {
                if (this.attributes.icePwd)
                  throw new Error("Invalid ice-pwd, should be only a single line if 'a=ice-pwd'");
                this.attributes.icePwd = this.extractOneOrMore(e5, E2, [22, 256]);
              }
              parseIceOptions(e5) {
                if (this.attributes.iceOptions)
                  throw new Error("Invalid ice-options, should be only one 'ice-options' line");
                const t5 = [];
                for (; !this.atEnd(e5); ) {
                  t5.push(this.extractOneOrMore(e5, E2));
                  try {
                    this.consumeAttributeSpace(e5);
                  } catch (t6) {
                    if (this.atEnd(e5))
                      break;
                    throw t6;
                  }
                }
                this.attributes.iceOptions = t5;
              }
              parseFingerprint(e5) {
                const t5 = this.extract(e5, this.consumeToken);
                this.consumeAttributeSpace(e5);
                const i4 = this.extract(e5, this.consumeTill);
                this.attributes.fingerprints.push({ hashFunction: t5, fingerprint: i4 });
              }
              parseExtmap(e5) {
                const t5 = this.extractOneOrMore(e5, a2);
                let i4;
                "/" === this.peekChar(e5) && (this.extract(e5, this.consume, "/"), i4 = this.extract(e5, this.consumeToken)), this.consumeAttributeSpace(e5);
                const n3 = this.extract(e5, this.consumeTill, o2), r3 = T2(T2({ entry: parseInt(t5, 10) }, i4 && { direction: i4 }), {}, { extensionName: n3 });
                this.peekChar(e5) === o2 && (this.consumeAttributeSpace(e5), r3.extensionAttributes = this.extract(e5, this.consumeTill)), this.attributes.extmaps.push(r3);
              }
              parseSetup(e5) {
                if (this.attributes.setup)
                  throw new Error("must only be one single 'a=setup' line.");
                const t5 = this.extract(e5, this.consumeTill);
                if ("active" !== t5 && "passive" !== t5 && "actpass" !== t5 && "holdconn" !== t5)
                  throw new Error("role must be one of 'active', 'passive', 'actpass', 'holdconn'.");
                this.attributes.setup = t5;
              }
            }
            class v2 extends C2 {
              constructor(...e5) {
                super(...e5), g2(this, "attributes", { unrecognized: [], groups: [], extmaps: [], fingerprints: [], identities: [] });
              }
              parse(e5) {
                if (this.digested)
                  throw new Error("already digested");
                try {
                  switch (e5.attField) {
                    case "group":
                      this.parseGroup(e5);
                      break;
                    case "ice-lite":
                      this.parseIceLite();
                      break;
                    case "ice-ufrag":
                      this.parseIceUfrag(e5);
                      break;
                    case "ice-pwd":
                      this.parseIcePwd(e5);
                      break;
                    case "ice-options":
                      this.parseIceOptions(e5);
                      break;
                    case "fingerprint":
                      this.parseFingerprint(e5);
                      break;
                    case "setup":
                      this.parseSetup(e5);
                      break;
                    case "tls-id":
                      this.parseTlsId(e5);
                      break;
                    case "identity":
                      this.parseIdentity(e5);
                      break;
                    case "extmap":
                      this.parseExtmap(e5);
                      break;
                    case "msid-semantic":
                      this.parseMsidSemantic(e5);
                      break;
                    default:
                      e5.ignored = true, this.attributes.unrecognized.push(e5);
                  }
                } catch (t5) {
                  throw console.error("parsing session attribute ".concat(e5.attField, ' error, "a=').concat(e5.attField, ":").concat(e5.attValue, '"')), t5;
                }
                if (!e5.ignored && e5.attValue && !this.atEnd(e5))
                  throw new Error("attribute parsing error");
              }
              digest() {
                return this.digested = true, this.attributes;
              }
              parseGroup(e5) {
                const t5 = this.extract(e5, this.consumeToken), i4 = [];
                for (; !this.atEnd(e5) && this.peekChar(e5) === o2; )
                  this.consumeAttributeSpace(e5), i4.push(this.extract(e5, this.consumeToken));
                this.attributes.groups.push({ semantic: t5, identificationTag: i4 });
              }
              parseIceLite() {
                if (this.attributes.iceLite)
                  throw new Error("Invalid ice-lite, should be only a single line of 'a=ice-lite'");
                this.attributes.iceLite = true;
              }
              parseTlsId(e5) {
                if (this.attributes.tlsId)
                  throw new Error("must be only one tld-id line");
                this.attributes.tlsId = this.extractOneOrMore(e5, m2);
              }
              parseIdentity(e5) {
                const t5 = this.extractOneOrMore(e5, f2), i4 = [];
                for (; !this.atEnd(e5) && this.peekChar(e5) === o2; ) {
                  this.consumeAttributeSpace(e5);
                  const t6 = this.extract(e5, this.consumeToken);
                  this.extract(e5, this.consume, "=");
                  const n3 = this.extractOneOrMore(e5, (e6) => e6 !== o2 && _2(e6));
                  i4.push({ name: t6, value: n3 });
                }
                this.attributes.identities.push({ assertionValue: t5, extensions: i4 });
              }
              parseMsidSemantic(e5) {
                this.peekChar(e5) === o2 && this.consumeAttributeSpace(e5);
                const t5 = { semantic: this.extract(e5, this.consumeToken), identifierList: [] };
                for (; ; ) {
                  try {
                    this.consumeAttributeSpace(e5);
                  } catch (e6) {
                    break;
                  }
                  if ("*" === this.peekChar(e5)) {
                    this.extract(e5, this.consume, "*"), t5.applyForAll = true;
                    break;
                  }
                  {
                    const i4 = this.extract(e5, this.consumeTill, o2);
                    t5.identifierList.push(i4);
                  }
                }
                this.attributes.msidSemantic = t5;
              }
            }
            class y2 extends C2 {
              constructor(e5) {
                super(), g2(this, "attributes", void 0), -1 !== e5.protos.indexOf("RTP") || e5.protos.indexOf("rtp"), this.attributes = { unrecognized: [], candidates: [], extmaps: [], fingerprints: [], imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: [], ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: [] };
              }
              parse(e5) {
                if (this.digested)
                  throw new Error("already digested");
                try {
                  switch (e5.attField) {
                    case "extmap":
                      this.parseExtmap(e5);
                      break;
                    case "setup":
                      this.parseSetup(e5);
                      break;
                    case "ice-ufrag":
                      this.parseIceUfrag(e5);
                      break;
                    case "ice-pwd":
                      this.parseIcePwd(e5);
                      break;
                    case "ice-options":
                      this.parseIceOptions(e5);
                      break;
                    case "candidate":
                      this.parseCandidate(e5);
                      break;
                    case "remote-candidate":
                      this.parseRemoteCandidate(e5);
                      break;
                    case "end-of-candidates":
                      this.parseEndOfCandidates();
                      break;
                    case "fingerprint":
                      this.parseFingerprint(e5);
                      break;
                    case "rtpmap":
                      this.parseRtpmap(e5);
                      break;
                    case "ptime":
                      this.parsePtime(e5);
                      break;
                    case "maxptime":
                      this.parseMaxPtime(e5);
                      break;
                    case "sendrecv":
                    case "recvonly":
                    case "sendonly":
                    case "inactive":
                      this.parseDirection(e5);
                      break;
                    case "ssrc":
                      this.parseSSRC(e5);
                      break;
                    case "fmtp":
                      this.parseFmtp(e5);
                      break;
                    case "rtcp-fb":
                      this.parseRtcpFb(e5);
                      break;
                    case "rtcp-mux":
                      this.parseRTCPMux();
                      break;
                    case "rtcp-mux-only":
                      this.parseRTCPMuxOnly();
                      break;
                    case "rtcp-rsize":
                      this.parseRTCPRsize();
                      break;
                    case "rtcp":
                      this.parseRTCP(e5);
                      break;
                    case "mid":
                      this.parseMid(e5);
                      break;
                    case "msid":
                      this.parseMsid(e5);
                      break;
                    case "imageattr":
                      this.parseImageAttr(e5);
                      break;
                    case "rid":
                      this.parseRid(e5);
                      break;
                    case "simulcast":
                      this.parseSimulcast(e5);
                      break;
                    case "sctp-port":
                      this.parseSctpPort(e5);
                      break;
                    case "max-message-size":
                      this.parseMaxMessageSize(e5);
                      break;
                    case "ssrc-group":
                      this.parseSSRCGroup(e5);
                      break;
                    default:
                      e5.ignored = true, this.attributes.unrecognized.push(e5);
                  }
                } catch (t5) {
                  throw console.error("parsing media attribute ".concat(e5.attField, ' error, "a=').concat(e5.attField, ":").concat(e5.attValue, '"')), t5;
                }
                if (!e5.ignored && e5.attValue && !this.atEnd(e5))
                  throw new Error("attribute parsing error");
              }
              parseCandidate(e5) {
                const t5 = this.extractOneOrMore(e5, E2, [1, 32]);
                this.consumeAttributeSpace(e5);
                const i4 = this.extractOneOrMore(e5, a2, [1, 5]);
                this.consumeAttributeSpace(e5);
                const n3 = this.extract(e5, this.consumeToken);
                this.consumeAttributeSpace(e5);
                const r3 = this.extractOneOrMore(e5, a2, [1, 10]);
                this.consumeAttributeSpace(e5);
                const s3 = this.extract(e5, this.consumeAddress);
                this.consumeAttributeSpace(e5);
                const d3 = this.extract(e5, this.consumePort);
                this.consumeAttributeSpace(e5), this.extract(e5, this.consume, "typ"), this.consumeAttributeSpace(e5);
                const u3 = { foundation: t5, componentId: i4, transport: n3, priority: r3, connectionAddress: s3, port: d3, type: this.extract(e5, this.consumeToken), extension: {} };
                for (this.peek(e5, " raddr") && (this.extract(e5, this.consume, " raddr"), this.consumeAttributeSpace(e5), u3.relAddr = this.extract(e5, this.consumeAddress)), this.peek(e5, " rport") && (this.extract(e5, this.consume, " rport"), this.consumeAttributeSpace(e5), u3.relPort = this.extract(e5, this.consumePort)); this.peekChar(e5) === o2; ) {
                  this.consumeAttributeSpace(e5);
                  const t6 = this.extract(e5, this.consumeToken);
                  this.consumeAttributeSpace(e5), u3.extension[t6] = this.extractOneOrMore(e5, c2);
                }
                this.attributes.candidates.push(u3);
              }
              parseRemoteCandidate(e5) {
                const t5 = [];
                for (; ; ) {
                  const i4 = this.extractOneOrMore(e5, a2, [1, 5]);
                  this.consumeAttributeSpace(e5);
                  const n3 = this.extract(e5, this.consumeAddress);
                  this.consumeAttributeSpace(e5);
                  const r3 = this.extract(e5, this.consumePort);
                  t5.push({ componentId: i4, connectionAddress: n3, port: r3 });
                  try {
                    this.consumeAttributeSpace(e5);
                  } catch (e6) {
                    break;
                  }
                }
                this.attributes.remoteCandidatesList.push(t5);
              }
              parseEndOfCandidates() {
                if (this.attributes.endOfCandidates)
                  throw new Error("must be only one line of end-of-candidates");
                this.attributes.endOfCandidates = true;
              }
              parseRtpmap(e5) {
                const t5 = this.extract(e5, this.consumeToken);
                this.consumeAttributeSpace(e5);
                const i4 = this.extract(e5, this.consumeTill, "/");
                this.extract(e5, this.consume, "/");
                const n3 = { encodingName: i4, clockRate: this.extractOneOrMore(e5, a2) };
                this.atEnd(e5) || "/" !== this.peekChar(e5) || (this.extract(e5, this.consume, "/"), n3.encodingParameters = parseInt(this.extract(e5, this.consumeTill), 10));
                const r3 = this.attributes.payloads.find((e6) => e6.payloadType === parseInt(t5, 10));
                r3 ? r3.rtpMap = n3 : this.attributes.payloads.push({ payloadType: parseInt(t5, 10), rtpMap: n3, rtcpFeedbacks: [] });
              }
              parsePtime(e5) {
                if (this.attributes.ptime)
                  throw new Error("must be only one line of ptime");
                this.attributes.ptime = this.extract(e5, this.consumeTill);
              }
              parseMaxPtime(e5) {
                if (this.attributes.maxPtime)
                  throw new Error("must be only one line of ptime");
                this.attributes.maxPtime = this.extract(e5, this.consumeTill);
              }
              parseDirection(e5) {
                if (this.attributes.direction)
                  throw new Error("must be only one line of direction info");
                this.attributes.direction = e5.attField;
              }
              parseSSRC(e5) {
                const t5 = this.extractOneOrMore(e5, a2);
                this.consumeAttributeSpace(e5);
                const i4 = this.extract(e5, this.consumeTill, ":");
                let n3;
                ":" === this.peekChar(e5) && (this.extract(e5, this.consume, ":"), n3 = this.extract(e5, this.consumeTill));
                const r3 = this.attributes.ssrcs.find((e6) => e6.ssrcId === parseInt(t5, 10));
                r3 ? r3.attributes[i4] = n3 : this.attributes.ssrcs.push({ ssrcId: parseInt(t5, 10), attributes: { [i4]: n3 } });
              }
              parseFmtp(e5) {
                const t5 = this.extract(e5, this.consumeTill, o2);
                this.consumeAttributeSpace(e5);
                const i4 = this.extract(e5, this.consumeTill), n3 = {};
                i4.split(";").forEach((e6) => {
                  let [t6, i5] = e6.split("=");
                  t6 = t6.trim();
                  const r4 = "string" == typeof i5 ? i5.trim() : null;
                  "string" == typeof t6 && t6.length > 0 && (n3[t6] = r4);
                });
                const r3 = this.attributes.payloads.find((e6) => e6.payloadType === parseInt(t5, 10));
                r3 ? r3.fmtp = { parameters: n3 } : this.attributes.payloads.push({ payloadType: parseInt(t5, 10), rtcpFeedbacks: [], fmtp: { parameters: n3 } });
              }
              parseFmtParameters(e5) {
                const t5 = {}, i4 = this.extract(e5, this.consumeTill, "=");
                e5._cur++;
                const n3 = this.extract(e5, this.consumeTill, ";");
                for (t5[i4] = n3; ";" === e5.attValue[e5._cur]; ) {
                  const i5 = this.extract(e5, this.consumeTill, "=");
                  e5._cur++;
                  const n4 = this.extract(e5, this.consumeTill, ";");
                  t5[i5] = n4;
                }
                return t5;
              }
              parseRtcpFb(e5) {
                let t5 = "";
                t5 = "*" === this.peekChar(e5) ? this.extract(e5, this.consume, "*") : this.extract(e5, this.consumeTill, o2), this.consumeAttributeSpace(e5);
                const i4 = this.extract(e5, this.consumeTill, o2);
                let n3;
                switch (i4) {
                  case "trr-int":
                    n3 = { type: i4, interval: this.extract(e5, this.consumeTill) };
                    break;
                  case "ack":
                  case "nack":
                  default: {
                    const t6 = { type: i4 };
                    this.peekChar(e5) === o2 && (this.consumeAttributeSpace(e5), t6.parameter = this.extract(e5, this.consumeToken), this.peekChar(e5) === o2 && (t6.additional = this.extract(e5, this.consumeTill))), n3 = t6;
                  }
                }
                if ("*" === t5)
                  this.attributes.rtcpFeedbackWildcards.push(n3);
                else {
                  const e6 = this.attributes.payloads.find((e7) => e7.payloadType === parseInt(t5, 10));
                  e6 ? e6.rtcpFeedbacks.push(n3) : this.attributes.payloads.push({ payloadType: parseInt(t5, 10), rtcpFeedbacks: [n3] });
                }
              }
              parseRTCPMux() {
                if (this.attributes.rtcpMux)
                  throw new Error("must be single line of rtcp-mux");
                this.attributes.rtcpMux = true;
              }
              parseRTCPMuxOnly() {
                if (this.attributes.rtcpMuxOnly)
                  throw new Error("must be single line of rtcp-only");
                this.attributes.rtcpMuxOnly = true;
              }
              parseRTCPRsize() {
                if (this.attributes.rtcpRsize)
                  throw new Error("must be single line of rtcp-rsize");
                this.attributes.rtcpRsize = true;
              }
              parseRTCP(e5) {
                if (this.attributes.rtcp)
                  throw new Error("must be single line of rtcp");
                const t5 = { port: this.extract(e5, this.consumePort) };
                this.peekChar(e5) === o2 && (this.consumeAttributeSpace(e5), t5.netType = this.extractOneOrMore(e5, u2), this.consumeAttributeSpace(e5), t5.addressType = this.extractOneOrMore(e5, u2), this.consumeAttributeSpace(e5), t5.address = this.extract(e5, this.consumeAddress)), this.attributes.rtcp = t5;
              }
              parseMsid(e5) {
                const t5 = { id: this.extractOneOrMore(e5, u2, [1, 64]) };
                this.peekChar(e5) === o2 && (this.consumeAttributeSpace(e5), t5.appdata = this.extractOneOrMore(e5, u2, [1, 64])), this.attributes.msids.push(t5);
              }
              parseImageAttr(e5) {
                this.attributes.imageattr.push(e5.attValue);
              }
              parseRid(e5) {
                const t5 = this.extractOneOrMore(e5, (e6) => h2(e6) || a2(e6) || "_" === e6 || "-" === e6);
                this.consumeAttributeSpace(e5);
                const i4 = { id: t5, direction: this.extract(e5, this.consumeToken), params: [] };
                if (this.peekChar(e5) === o2) {
                  if (this.consumeAttributeSpace(e5), this.peek(e5, "pt=")) {
                    this.extract(e5, this.consume, "pt=");
                    const t6 = [];
                    for (; ; ) {
                      const i5 = this.extract(e5, this.consumeToken);
                      t6.push(i5);
                      try {
                        this.extract(e5, this.consume, ",");
                      } catch (e6) {
                        break;
                      }
                    }
                    i4.payloads = t6, this.peekChar(e5) === o2 && this.extract(e5, this.consume, o2);
                  }
                  for (; ; ) {
                    const t6 = this.extract(e5, this.consumeToken);
                    switch (t6) {
                      case "depend": {
                        const n3 = { type: t6, rids: this.extract(e5, this.consume, "=").split(",") };
                        i4.params.push(n3);
                        break;
                      }
                      case "max-width":
                      case "height-width":
                      case "max-fps":
                      case "max-fs":
                      case "max-br":
                      case "max-pps":
                      case "max-bpp":
                      default: {
                        const n3 = { type: t6 };
                        "=" === this.peekChar(e5) && (this.extract(e5, this.consume, "="), n3.val = this.extract(e5, this.consumeTill, ";")), i4.params.push(n3);
                      }
                    }
                    try {
                      this.extract(e5, this.consume, ";");
                    } catch (e6) {
                      break;
                    }
                  }
                }
                this.attributes.rids.push(i4);
              }
              parseSimulcast(e5) {
                if (this.attributes.simulcast)
                  throw new Error("must be single line of simulcast");
                this.attributes.simulcast = e5.attValue, this.extract(e5, this.consumeTill);
              }
              parseSctpPort(e5) {
                this.attributes.sctpPort = this.extractOneOrMore(e5, a2, [1, 5]);
              }
              parseMaxMessageSize(e5) {
                this.attributes.maxMessageSize = this.extractOneOrMore(e5, a2, [1, void 0]);
              }
              digest() {
                return this.digested = true, this.attributes;
              }
              parseMid(e5) {
                this.attributes.mid = this.extract(e5, this.consumeToken);
              }
              parseSSRCGroup(e5) {
                const t5 = this.extract(e5, this.consumeToken), i4 = [];
                for (; ; )
                  try {
                    this.consumeAttributeSpace(e5);
                    const t6 = this.extract(e5, this.consumeInteger);
                    i4.push(parseInt(t6, 10));
                  } catch (e6) {
                    break;
                  }
                this.attributes.ssrcGroups.push({ semantic: t5, ssrcIds: i4 });
              }
            }
            function A2(e5, t5, i4) {
              return t5 in e5 ? Object.defineProperty(e5, t5, { value: i4, enumerable: true, configurable: true, writable: true }) : e5[t5] = i4, e5;
            }
            class O2 {
              constructor() {
                A2(this, "eol", r2);
              }
              print(e5, t5) {
                let i4 = "";
                return t5 && (this.eol = t5), i4 += this.printVersion(e5.version), i4 += this.printOrigin(e5.origin), i4 += this.printSessionName(e5.sessionName), i4 += this.printInformation(e5.information), i4 += this.printUri(e5.uri), i4 += this.printEmail(e5.emails), i4 += this.printPhone(e5.phones), i4 += this.printConnection(e5.connection), i4 += this.printBandwidth(e5.bandwidths), i4 += this.printTimeFields(e5.timeFields), i4 += this.printKey(e5.key), i4 += this.printSessionAttributes(e5.attributes), i4 += this.printMediaDescription(e5.mediaDescriptions), i4;
              }
              printVersion(e5) {
                return "v=".concat(e5).concat(this.eol);
              }
              printOrigin(e5) {
                return "o=".concat(e5.username, " ").concat(e5.sessId, " ").concat(e5.sessVersion, " ").concat(e5.nettype, " ").concat(e5.addrtype, " ").concat(e5.unicastAddress).concat(this.eol);
              }
              printSessionName(e5) {
                return e5 ? "s=".concat(e5).concat(this.eol) : "";
              }
              printInformation(e5) {
                return e5 ? "i=".concat(e5).concat(this.eol) : "";
              }
              printUri(e5) {
                return e5 ? "u=".concat(e5).concat(this.eol) : "";
              }
              printEmail(e5) {
                let t5 = "";
                for (const i4 of e5)
                  t5 += "e=".concat(i4).concat(this.eol);
                return t5;
              }
              printPhone(e5) {
                let t5 = "";
                for (const i4 of e5)
                  t5 += "e=".concat(i4).concat(this.eol);
                return t5;
              }
              printConnection(e5) {
                return e5 ? "c=".concat(e5.nettype, " ").concat(e5.addrtype, " ").concat(e5.address).concat(this.eol) : "";
              }
              printBandwidth(e5) {
                let t5 = "";
                for (const i4 of e5)
                  t5 += "b=".concat(i4.bwtype, ":").concat(i4.bandwidth).concat(this.eol);
                return t5;
              }
              printTimeFields(e5) {
                let t5 = "";
                for (const i4 of e5) {
                  t5 += "t=".concat(i4.time.startTime, " ").concat(i4.time.startTime).concat(this.eol);
                  for (const e6 of i4.repeats)
                    t5 += "r=".concat(e6.repeatInterval, " ").concat(e6.typedTimes.join(" ")).concat(this.eol);
                  i4.zoneAdjustments && (t5 += "z=", t5 += "z=".concat(i4.zoneAdjustments.map((e6) => "".concat(e6.time, " ").concat(e6.back ? "-" : "", " ").concat(e6.typedTime)).join(" ")).concat(this.eol), t5 += this.eol);
                }
                return t5;
              }
              printKey(e5) {
                return e5 ? "k=".concat(e5).concat(this.eol) : "";
              }
              printAttributes(e5) {
                let t5 = "";
                for (const i4 of e5)
                  t5 += "a=".concat(i4.attField).concat(i4.attValue ? ":".concat(i4.attValue) : "").concat(this.eol);
                return t5;
              }
              printMediaDescription(e5) {
                let t5 = "";
                for (const i4 of e5)
                  t5 += this.printMedia(i4.media), t5 += this.printInformation(i4.information), t5 += this.printConnections(i4.connections), t5 += this.printBandwidth(i4.bandwidths), t5 += this.printKey(i4.key), t5 += this.printMediaAttributes(i4);
                return t5;
              }
              printConnections(e5) {
                let t5 = "";
                for (const i4 of e5)
                  t5 += this.printConnection(i4);
                return t5;
              }
              printMedia(e5) {
                return "m=".concat(e5.mediaType, " ").concat(e5.port, " ").concat(e5.protos.join("/"), " ").concat(e5.fmts.join(" ")).concat(this.eol);
              }
              printSessionAttributes(e5) {
                return new b2(this.eol).print(e5);
              }
              printMediaAttributes(e5) {
                return new w2(this.eol).print(e5);
              }
            }
            class N2 {
              constructor(e5) {
                A2(this, "eol", void 0), this.eol = e5;
              }
              printIceUfrag(e5) {
                return void 0 === e5 ? "" : "a=ice-ufrag:".concat(e5).concat(this.eol);
              }
              printIcePwd(e5) {
                return void 0 === e5 ? "" : "a=ice-pwd:".concat(e5).concat(this.eol);
              }
              printIceOptions(e5) {
                return void 0 === e5 ? "" : "a=ice-options:".concat(e5.join(o2)).concat(this.eol);
              }
              printFingerprints(e5) {
                return e5.length > 0 ? e5.map((e6) => "a=fingerprint:".concat(e6.hashFunction).concat(o2).concat(e6.fingerprint)).join(this.eol) + this.eol : "";
              }
              printExtmap(e5) {
                return e5.map((e6) => "a=extmap:".concat(e6.entry).concat(e6.direction ? "/".concat(e6.direction) : "").concat(o2).concat(e6.extensionName).concat(e6.extensionAttributes ? "".concat(o2).concat(e6.extensionAttributes) : "").concat(this.eol)).join("");
              }
              printSetup(e5) {
                return void 0 === e5 ? "" : "a=setup:".concat(e5).concat(this.eol);
              }
              printUnrecognized(e5) {
                return e5.map((e6) => "a=".concat(e6.attField).concat(e6.attValue ? ":".concat(e6.attValue) : "").concat(this.eol)).join("");
              }
            }
            class b2 extends N2 {
              print(e5) {
                let t5 = "";
                return t5 += this.printGroups(e5.groups), t5 += this.printMsidSemantic(e5.msidSemantic), t5 += this.printIceLite(e5.iceLite), t5 += this.printIceUfrag(e5.iceUfrag), t5 += this.printIcePwd(e5.icePwd), t5 += this.printIceOptions(e5.iceOptions), t5 += this.printFingerprints(e5.fingerprints), t5 += this.printSetup(e5.setup), t5 += this.printTlsId(e5.tlsId), t5 += this.printIdentity(e5.identities), t5 += this.printExtmap(e5.extmaps), t5 += this.printUnrecognized(e5.unrecognized), t5;
              }
              printGroups(e5) {
                let t5 = "";
                return e5.length > 0 && (t5 += e5.map((e6) => "a=group:".concat(e6.semantic).concat(e6.identificationTag.map((e7) => "".concat(o2).concat(e7)).join("")).concat(this.eol)).join("")), t5;
              }
              printIceLite(e5) {
                return void 0 === e5 ? "" : "a=ice-lite" + this.eol;
              }
              printTlsId(e5) {
                return e5 ? "a=tls-id:".concat(e5).concat(this.eol) : "";
              }
              printIdentity(e5) {
                return 0 === e5.length ? "" : e5.map((e6) => "a=identity:".concat(e6.assertionValue).concat(e6.extensions.map((e7) => "".concat(o2).concat(e7.name).concat(e7.value ? "=".concat(e7.value) : "")))).join(this.eol) + this.eol;
              }
              printMsidSemantic(e5) {
                if (!e5)
                  return "";
                let t5 = "a=msid-semantic:".concat(e5.semantic);
                return e5.applyForAll ? t5 += "".concat(o2, "*") : e5.identifierList.length > 0 && (t5 += e5.identifierList.map((e6) => "".concat(o2).concat(e6))), t5 + this.eol;
              }
            }
            class w2 extends N2 {
              print(e5) {
                const t5 = e5.attributes;
                let i4 = "";
                return i4 += this.printRTCP(t5.rtcp), i4 += this.printIceUfrag(t5.iceUfrag), i4 += this.printIcePwd(t5.icePwd), i4 += this.printIceOptions(t5.iceOptions), i4 += this.printCandidates(t5.candidates), i4 += this.printRemoteCandidatesList(t5.remoteCandidatesList), i4 += this.printEndOfCandidates(t5.endOfCandidates), i4 += this.printFingerprints(t5.fingerprints), i4 += this.printSetup(t5.setup), i4 += this.printMid(t5.mid), i4 += this.printExtmap(t5.extmaps), i4 += this.printRTPRelated(t5), i4 += this.printPtime(t5.ptime), i4 += this.printMaxPtime(t5.maxPtime), i4 += this.printDirection(t5.direction), i4 += this.printSSRCGroups(t5.ssrcGroups), i4 += this.printSSRC(t5.ssrcs), i4 += this.printRTCPMux(t5.rtcpMux), i4 += this.printRTCPMuxOnly(t5.rtcpMuxOnly), i4 += this.printRTCPRsize(t5.rtcpRsize), i4 += this.printMSId(t5.msids), i4 += this.printImageattr(t5.imageattr), i4 += this.printRid(t5.rids), i4 += this.printSimulcast(t5.simulcast), i4 += this.printSCTPPort(t5.sctpPort), i4 += this.printMaxMessageSize(t5.maxMessageSize), i4 += this.printUnrecognized(t5.unrecognized), i4;
              }
              printCandidates(e5) {
                return e5.map((e6) => "a=candidate:".concat(e6.foundation).concat(o2).concat(e6.componentId).concat(o2).concat(e6.transport).concat(o2).concat(e6.priority).concat(o2).concat(e6.connectionAddress).concat(o2).concat(e6.port).concat(o2, "typ").concat(o2).concat(e6.type).concat(e6.relAddr ? "".concat(o2, "raddr").concat(o2).concat(e6.relAddr) : "").concat(e6.relPort ? "".concat(o2, "rport").concat(o2).concat(e6.relPort) : "").concat(Object.keys(e6.extension).map((t5) => "".concat(o2).concat(t5).concat(o2).concat(e6.extension[t5])).join("")).concat(this.eol)).join("");
              }
              printRemoteCandidatesList(e5) {
                return e5.map((e6) => "a=remote-candidates:".concat(e6.join(o2)).concat(this.eol)).join("");
              }
              printEndOfCandidates(e5) {
                return void 0 === e5 ? "" : "a=end-of-candidates" + this.eol;
              }
              printRTPRelated(e5) {
                if (!e5.payloads)
                  return "";
                const t5 = e5.payloads;
                let i4 = "";
                i4 += e5.rtcpFeedbackWildcards.map((e6) => this.printRTCPFeedback("*", e6)).join("");
                for (const e6 of t5)
                  i4 += this.printRtpMap(e6.payloadType, e6.rtpMap), i4 += this.printFmtp(e6.payloadType, e6.fmtp), i4 += e6.rtcpFeedbacks.map((t6) => this.printRTCPFeedback(e6.payloadType, t6)).join("");
                return i4;
              }
              printFmtp(e5, t5) {
                if (!t5)
                  return "";
                const i4 = Object.keys(t5.parameters);
                return 1 === i4.length && null === t5.parameters[i4[0]] ? "a=fmtp:".concat(e5).concat(o2).concat(i4[0]).concat(this.eol) : "a=fmtp:".concat(e5).concat(o2).concat(Object.keys(t5.parameters).map((e6) => "".concat(e6, "=").concat(t5.parameters[e6])).join(";")).concat(this.eol);
              }
              printRtpMap(e5, t5) {
                return t5 ? "a=rtpmap:".concat(e5).concat(o2).concat(t5.encodingName, "/").concat(t5.clockRate).concat(t5.encodingParameters ? "/".concat(t5.encodingParameters) : "").concat(this.eol) : "";
              }
              printRTCPFeedback(e5, t5) {
                let i4 = "a=rtcp-fb:".concat(e5).concat(o2), n3 = t5;
                switch (n3.type) {
                  case "trr-int":
                    i4 += "ttr-int".concat(o2).concat(n3.interval);
                    break;
                  case "ack":
                  case "nack":
                  default:
                    n3 = n3, i4 += "".concat(n3.type), n3.parameter && (i4 += "".concat(o2).concat(n3.parameter), n3.additional && (i4 += "".concat(o2).concat(n3.additional)));
                }
                return i4 + this.eol;
              }
              printPtime(e5) {
                return void 0 === e5 ? "" : "a=ptime:".concat(e5).concat(this.eol);
              }
              printMaxPtime(e5) {
                return void 0 === e5 ? "" : "a=maxptime:".concat(e5).concat(this.eol);
              }
              printDirection(e5) {
                return void 0 === e5 ? "" : "a=".concat(e5).concat(this.eol);
              }
              printSSRC(e5) {
                return e5.map((e6) => Object.keys(e6.attributes).map((t5) => "a=ssrc:".concat(e6.ssrcId.toString(10)).concat(o2).concat(t5).concat(e6.attributes[t5] ? ":".concat(e6.attributes[t5]) : "").concat(this.eol)).join("")).join("");
              }
              printRTCPMux(e5) {
                return void 0 === e5 ? "" : "a=rtcp-mux".concat(this.eol);
              }
              printRTCPMuxOnly(e5) {
                return void 0 === e5 ? "" : "a=rtcp-mux-only".concat(this.eol);
              }
              printRTCPRsize(e5) {
                return void 0 === e5 ? "" : "a=rtcp-rsize".concat(this.eol);
              }
              printRTCP(e5) {
                if (void 0 === e5)
                  return "";
                let t5 = "a=rtcp:".concat(e5.port);
                return e5.netType && (t5 += "".concat(o2).concat(e5.netType)), e5.addressType && (t5 += "".concat(o2).concat(e5.addressType)), e5.address && (t5 += "".concat(o2).concat(e5.address)), t5 + this.eol;
              }
              printMSId(e5) {
                return e5.map((e6) => "a=msid:".concat(e6.id).concat(e6.appdata ? "".concat(o2).concat(e6.appdata) : "").concat(this.eol)).join("");
              }
              printImageattr(e5) {
                return e5.map((e6) => "a=imageattr:".concat(e6).concat(this.eol)).join("");
              }
              printRid(e5) {
                return e5.map((e6) => {
                  let t5 = "a=rid:".concat(e6.id).concat(o2).concat(e6.direction);
                  return e6.payloads && (t5 += "".concat(o2, "pt=").concat(e6.payloads.join(","))), e6.params.length > 0 && (t5 += "".concat(o2).concat(e6.params.map((e7) => "depend" === e7.type ? "depend=".concat(e7.rids.join(",")) : "".concat(e7.type, "=").concat(e7.val)).join(";"))), t5 + this.eol;
                }).join("");
              }
              printSimulcast(e5) {
                return void 0 === e5 ? "" : "a=simulcast:".concat(e5).concat(this.eol);
              }
              printSCTPPort(e5) {
                return void 0 === e5 ? "" : "a=sctp-port:".concat(e5).concat(this.eol);
              }
              printMaxMessageSize(e5) {
                return void 0 === e5 ? "" : "a=max-message-size:".concat(e5).concat(this.eol);
              }
              printMid(e5) {
                return void 0 === e5 ? "" : "a=mid:".concat(e5).concat(this.eol);
              }
              printSSRCGroups(e5) {
                return e5.map((e6) => "a=ssrc-group:".concat(e6.semantic).concat(e6.ssrcIds.map((e7) => "".concat(o2).concat(e7.toString(10))).join("")).concat(this.eol)).join("");
              }
            }
            function D2(e5) {
              return new I2().parse(e5);
            }
            function P2(e5, t5) {
              return new O2().print(e5, t5);
            }
          } }, t3 = {};
          function i2(n2) {
            if (t3[n2])
              return t3[n2].exports;
            var r2 = t3[n2] = { exports: {} };
            return e3[n2](r2, r2.exports, i2), r2.exports;
          }
          return i2.d = (e4, t4) => {
            for (var n2 in t4)
              i2.o(t4, n2) && !i2.o(e4, n2) && Object.defineProperty(e4, n2, { enumerable: true, get: t4[n2] });
          }, i2.o = (e4, t4) => Object.prototype.hasOwnProperty.call(e4, t4), i2.r = (e4) => {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e4, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e4, "__esModule", { value: true });
          }, i2(8);
        })();
      }(UO);
      class iN {
        constructor(e2) {
          _p(this, "sessionDesc", void 0), _p(this, "localCapabilities", void 0), _p(this, "rtpCapabilities", void 0), _p(this, "candidates", void 0), _p(this, "iceParameters", void 0), _p(this, "dtlsParameters", void 0), _p(this, "setup", void 0), _p(this, "currentMidIndex", void 0), _p(this, "cname", void 0), e2 = uC(e2);
          const { remoteIceParameters: t2, remoteDtlsParameters: i2, candidates: n2, remoteRTPCapabilities: r2, remoteSetup: o2, localCapabilities: s2, sdkCodec: a2, cname: c2 } = e2, d2 = UO.exports.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE audio video\na=msid-semantic: WMS\na=ice-lite\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:audio\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:video\n");
          this.rtpCapabilities = r2, this.candidates = n2, this.iceParameters = t2, this.dtlsParameters = i2, this.setup = o2, this.localCapabilities = s2, this.cname = c2;
          for (let e3 = 0; e3 < d2.mediaDescriptions.length; e3++) {
            const s3 = d2.mediaDescriptions[e3];
            s3.attributes.iceUfrag = t2.iceUfrag, s3.attributes.icePwd = t2.icePwd, s3.attributes.fingerprints = i2.fingerprints, s3.attributes.candidates = n2, s3.attributes.setup = o2, "video" === s3.media.mediaType && (s3.media.fmts = r2.videoCodecs.map((e4) => e4.payloadType.toString(10)), s3.attributes.payloads = r2.videoCodecs, s3.attributes.extmaps = r2.videoExtensions), "audio" === s3.media.mediaType && (s3.media.fmts = r2.audioCodecs.map((e4) => e4.payloadType.toString(10)), s3.attributes.payloads = r2.audioCodecs, s3.attributes.extmaps = r2.audioExtensions), d2.mediaDescriptions[e3] = this.mungMediaDesc(s3);
          }
          this.sessionDesc = d2, this.currentMidIndex = d2.mediaDescriptions.length - 1;
        }
        toString() {
          return UO.exports.print(this.sessionDesc);
        }
        send(e2, t2, i2) {
          const { ssrcs: n2, ssrcGroups: r2 } = WO(t2, this.cname), o2 = this.sessionDesc.mediaDescriptions.find((t3) => e2 === AS.VIDEO ? "video" === t3.media.mediaType : "audio" === t3.media.mediaType), s2 = n2[0].attributes.label, a2 = n2[0].attributes.mslabel;
          return o2.attributes.ssrcs = o2.attributes.ssrcs.concat(n2), o2.attributes.ssrcGroups = o2.attributes.ssrcGroups.concat(r2), { id: s2, mslabel: a2 };
        }
        batchSend(e2) {
          return e2.map((e3) => {
            let { kind: t2, ssrcMsg: i2 } = e3;
            return this.send(t2, i2, void 0);
          });
        }
        stopSending(e2) {
          this.sessionDesc.mediaDescriptions.forEach((t2) => {
            const i2 = [], n2 = [], r2 = [];
            t2.attributes.ssrcs.forEach((t3) => {
              e2.includes(t3.attributes.label || "") ? r2.push(t3) : i2.push(t3);
            }), t2.attributes.ssrcGroups.forEach((e3) => {
              r2.map((e4) => e4.ssrcId).includes(e3.ssrcIds[0]) || n2.push(e3);
            }), t2.attributes.ssrcs = i2, t2.attributes.ssrcGroups = n2;
          });
        }
        mute(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2);
          if (!t2)
            throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.mute."));
          t2.attributes.direction = "inactive";
        }
        unmute(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2);
          if (!t2)
            throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.unmute."));
          t2.attributes.direction = "sendonly";
        }
        receive(e2, t2, i2) {
          e2.forEach((e3, t3) => {
            const i3 = e3._mediaStreamTrack, n2 = this.sessionDesc.mediaDescriptions.findIndex((e4) => e4.attributes.mid === i3.kind), r2 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[n2], e3);
            this.sessionDesc.mediaDescriptions[n2] = r2;
          });
        }
        stopReceiving(e2) {
        }
        updateCandidates(e2) {
          e2 === OS.TCP ? this.candidates.forEach((e3) => {
            -1 === this.candidates.findIndex((t2) => "tcp" === t2.transport && t2.connectionAddress === e3.connectionAddress && t2.port === e3.port) && this.candidates.push(tN(tN({}, e3), {}, { foundation: "tcpcandidate", priority: Number(e3.priority) - 1 + "", transport: "tcp", port: Number(e3.port) + 90 + "" }));
          }) : this.candidates = this.candidates.filter((e3) => "tcp" !== e3.transport);
          for (const e3 of this.sessionDesc.mediaDescriptions)
            e3.attributes.candidates = this.candidates;
        }
        restartICE(e2) {
          e2 = uC(e2), this.iceParameters = e2, this.sessionDesc.mediaDescriptions.forEach((t2) => {
            t2.attributes.iceUfrag = e2.iceUfrag, t2.attributes.icePwd = e2.icePwd;
          });
        }
        predictReceivingMids(e2) {
          const t2 = [];
          for (let i2 = 0; i2 < e2; i2++)
            t2.push((this.currentMidIndex + i2 + 1).toString(10));
          return t2;
        }
        mungRecvMediaDsec(e2, t2) {
          const i2 = uC(e2);
          return HO(i2, t2), YO(i2, t2), i2;
        }
        updateRecvMedia(e2, t2) {
          const i2 = this.sessionDesc.mediaDescriptions.findIndex((t3) => t3.attributes.mid === e2);
          if (-1 !== i2) {
            const e3 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i2], t2);
            this.sessionDesc.mediaDescriptions[i2] = e3;
          }
        }
        bumpMid(e2) {
          this.currentMidIndex += e2;
        }
        updateTrackLabel(e2, t2, i2) {
          const n2 = this.sessionDesc.mediaDescriptions.find((t3) => e2 === AS.VIDEO ? "video" === t3.attributes.mid : "audio" === t3.attributes.mid);
          if (n2) {
            const e3 = n2.attributes.ssrcs.find((e4) => e4.attributes.label === t2);
            var r2;
            if (e3)
              e3.attributes.label = i2, null === (r2 = e3.attributes.msid) || void 0 === r2 || r2.replace(t2, i2);
          }
        }
        mungMediaDesc(e2) {
          const t2 = uC(e2);
          return KO(t2), function(e3) {
            const t3 = e3.attributes.extmaps.find((e4) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e4.extensionName);
            t3 && e3.attributes.extmaps.splice(e3.attributes.extmaps.indexOf(t3), 1), e3.attributes.payloads.forEach((e4) => {
              const t4 = e4.rtcpFeedbacks.findIndex((e5) => "transport-cc" === e5.type);
              -1 !== t4 && e4.rtcpFeedbacks.splice(t4, 1);
            });
          }(t2), t2;
        }
        getSSRC(e2) {
          for (const t2 of this.sessionDesc.mediaDescriptions)
            for (const i2 of t2.attributes.ssrcs)
              if (i2.attributes.label === e2)
                return [i2];
        }
      }
      function nN(e2) {
        if (Array.isArray(e2))
          return e2.map((e3) => e3);
        if (!rN(e2))
          return e2;
        const t2 = {};
        for (const i2 in e2)
          rN(e2[i2]) || Array.isArray(e2[i2]) ? t2[i2] = nN(e2[i2]) : t2[i2] = e2[i2];
        return t2;
      }
      function rN(e2) {
        return !("object" != typeof e2 || Array.isArray(e2) || !e2);
      }
      function oN() {
        const e2 = navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]*/i);
        return e2 && e2[0] ? Number(e2[0].split("/")[1]) : null;
      }
      function sN(e2) {
        if (!window.RTCStatsReport)
          return false;
        return e2.getStats() instanceof Sl;
      }
      class aN {
        constructor(e2) {
          _p(this, "input", []), _p(this, "size", void 0), this.size = e2;
        }
        add(e2) {
          this.input.push(e2), this.input.length > this.size && this.input.splice(0, 1);
        }
        diffMean() {
          return 0 === this.input.length ? 0 : (this.input[this.input.length - 1] - this.input[0]) / this.input.length;
        }
      }
      const cN = { address: "unknown", candidateType: "unknown", id: "unknown", port: 0, priority: 0, protocol: "unknown", type: "unknown" }, dN = { timestamp: 0, bitrate: { actualEncoded: 0, transmit: 0 }, sendPacketLossRate: 0, recvPacketLossRate: 0, videoRecv: [], videoSend: [], audioRecv: [], audioSend: [], selectedCandidatePair: { id: "unknown", localCandidate: cN, remoteCandidate: cN } }, uN = { firsCount: 0, nacksCount: 0, plisCount: 0, framesDecodeCount: 0, framesDecodeInterval: 0, framesDecodeFreezeTime: 0, decodeFrameRate: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packets: 0, ssrc: 0, qpSumPerFrame: 0 }, lN = { firsCount: 0, nacksCount: 0, plisCount: 0, frameCount: 0, bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0, qpSumPerFrame: 0 }, hN = { bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0 }, pN = { jitterBufferMs: 0, jitterMs: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packets: 0, ssrc: 0, receivedFrames: 0, droppedFrames: 0, concealedSamples: 0 };
      function _N(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function EN(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? _N(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : _N(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class mN {
        constructor(e2, t2) {
          _p(this, "onFirstVideoReceived", void 0), _p(this, "onFirstVideoDecoded", void 0), _p(this, "onFirstAudioReceived", void 0), _p(this, "onFirstVideoDecodedTimeout", void 0), _p(this, "onFirstAudioDecoded", void 0), _p(this, "onSelectedLocalCandidateChanged", void 0), _p(this, "onSelectedRemoteCandidateChanged", void 0), _p(this, "videoIsReady", false), _p(this, "videoIsReady2", {}), _p(this, "pc", void 0), _p(this, "options", void 0), _p(this, "intervalTimer", void 0), _p(this, "stats", nN(dN)), _p(this, "isFirstVideoReceived", {}), _p(this, "isFirstVideoDecoded", {}), _p(this, "isFirstAudioReceived", {}), _p(this, "isFirstAudioDecoded", {}), _p(this, "isFirstVideoDecodedTimeout", {}), _p(this, "lossRateWindowStats", []), this.pc = e2, this.options = t2, this.intervalTimer = window.setInterval(async () => {
            this.updateStats();
          }, this.options.updateInterval);
        }
        getStats() {
          return this.stats;
        }
        getSelectedCandidatePair() {
          return new Sl((e2) => {
            e2({ local: EN({}, cN), remote: EN({}, cN) });
          });
        }
        setVideoIsReady(e2) {
          this.videoIsReady = e2;
        }
        setVideoIsReady2(e2, t2) {
          this.videoIsReady2[e2] = t2;
        }
        getVideoIsReady(e2) {
          return this.videoIsReady2[e2] || false;
        }
        setIsFirstAudioDecoded(e2) {
        }
        destroy() {
          window.clearInterval(this.intervalTimer), this.pc = void 0;
        }
        calcLossRate(e2) {
          this.lossRateWindowStats.push(e2), this.lossRateWindowStats.length > this.options.lossRateInterval && this.lossRateWindowStats.splice(0, 1);
          const t2 = this.lossRateWindowStats.length, i2 = ["videoSend", "audioSend", "videoRecv", "audioRecv"];
          let n2 = 0, r2 = 0, o2 = 0, s2 = 0;
          for (const a2 of i2)
            e2[a2].forEach((e3, i3) => {
              if (!this.lossRateWindowStats[t2 - 1][a2][i3] || !this.lossRateWindowStats[0][a2][i3])
                return;
              const c2 = this.lossRateWindowStats[t2 - 1][a2][i3].packets - this.lossRateWindowStats[0][a2][i3].packets, d2 = this.lossRateWindowStats[t2 - 1][a2][i3].packetsLost - this.lossRateWindowStats[0][a2][i3].packetsLost;
              "videoSend" === a2 || "audioSend" === a2 ? (n2 += c2, o2 += d2) : (r2 += c2, s2 += d2), Number.isNaN(c2) || Number.isNaN(c2) ? e3.packetLostRate = 0 : e3.packetLostRate = c2 <= 0 || d2 <= 0 ? 0 : d2 / (c2 + d2);
            });
          e2.sendPacketLossRate = n2 <= 0 || o2 <= 0 ? 0 : o2 / (n2 + o2), e2.recvPacketLossRate = r2 <= 0 || s2 <= 0 ? 0 : s2 / (r2 + s2);
        }
      }
      function fN(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function SN(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? fN(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : fN(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class TN extends mN {
        constructor() {
          super(...arguments), _p(this, "_stats", dN), _p(this, "lastDecodeVideoReceiverStats", /* @__PURE__ */ new Map());
        }
        async updateStats() {
          const e2 = await this._getStats(), t2 = this.statsResponsesToObjects(e2);
          this._stats = nN(dN);
          const i2 = t2.filter((e3) => "ssrc" === e3.type);
          this.processSSRCStats(i2);
          const n2 = t2.find((e3) => "VideoBwe" === e3.type);
          n2 && this.processBandwidthStats(n2), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats;
        }
        processBandwidthStats(e2) {
          this._stats.bitrate = { actualEncoded: Number(e2.googActualEncBitrate), targetEncoded: Number(e2.googTargetEncBitrate), retransmit: Number(e2.googRetransmitBitrate), transmit: Number(e2.googTransmitBitrate) }, this._stats.sendBandwidth = Number(e2.googAvailableSendBandwidth);
        }
        processSSRCStats(e2) {
          e2.forEach((e3) => {
            const t2 = e3.id.includes("send");
            switch ("".concat(e3.mediaType, "_").concat(t2 ? "send" : "recv")) {
              case "video_send": {
                const t3 = nN(lN);
                t3.codec = e3.googCodecName, t3.adaptionChangeReason = "none", e3.googCpuLimitedResolution && (t3.adaptionChangeReason = "cpu"), e3.googBandwidthLimitedResolution && (t3.adaptionChangeReason = "bandwidth"), t3.avgEncodeMs = Number(e3.googAvgEncodeMs), t3.inputFrame = { width: Number(e3.googFrameWidthInput) || Number(e3.googFrameWidthSent), height: Number(e3.googFrameHeightInput) || Number(e3.googFrameHeightSent), frameRate: Number(e3.googFrameRateInput) }, t3.sentFrame = { width: Number(e3.googFrameWidthSent), height: Number(e3.googFrameHeightSent), frameRate: Number(e3.googFrameRateInput) }, t3.firsCount = Number(e3.googFirReceived), t3.nacksCount = Number(e3.googNacksReceived), t3.plisCount = Number(e3.googPlisReceived), t3.frameCount = Number(e3.framesEncoded), t3.bytes = Number(e3.bytesSent), t3.packets = Number(e3.packetsSent), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.rttMs = Number(e3.googRtt || 0), this._stats.videoSend.push(t3), this._stats.rtt = t3.rttMs;
                break;
              }
              case "video_recv": {
                const t3 = nN(uN), i2 = this.lastDecodeVideoReceiverStats.get(Number(e3.ssrc));
                if (t3.codec = e3.googCodecName, t3.targetDelayMs = Number(e3.googTargetDelayMs), t3.renderDelayMs = Number(e3.googRenderDelayMs), t3.currentDelayMs = Number(e3.googCurrentDelayMs), t3.minPlayoutDelayMs = Number(e3.googMinPlayoutDelayMs), t3.decodeMs = Number(e3.googDecodeMs), t3.maxDecodeMs = Number(e3.googMaxDecodeMs), t3.receivedFrame = { width: Number(e3.googFrameWidthReceived), height: Number(e3.googFrameHeightReceived), frameRate: Number(e3.googFrameRateReceived) }, t3.decodedFrame = { width: Number(e3.googFrameWidthReceived), height: Number(e3.googFrameHeightReceived), frameRate: Number(e3.googFrameRateDecoded) }, t3.decodeFrameRate = Number(e3.googFrameRateDecoded), t3.outputFrame = { width: Number(e3.googFrameWidthReceived), height: Number(e3.googFrameHeightReceived), frameRate: Number(e3.googFrameRateOutput) }, t3.jitterBufferMs = Number(e3.googJitterBufferMs), t3.firsCount = Number(e3.googFirsSent), t3.nacksCount = Number(e3.googNacksSent), t3.plisCount = Number(e3.googPlisSent), t3.framesDecodeCount = Number(e3.framesDecoded), t3.bytes = Number(e3.bytesReceived), t3.packets = Number(e3.packetsReceived), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.packets > 0 && !this.isFirstVideoReceived[t3.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t3.ssrc), this.isFirstVideoReceived[t3.ssrc] = true), t3.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t3.ssrc] && (this.onFirstVideoDecoded && this.onFirstVideoDecoded(t3.ssrc, t3.decodedFrame.width, t3.decodedFrame.height), this.isFirstVideoDecoded[t3.ssrc] = true), i2) {
                  const n2 = i2.stats, r2 = Date.now() - i2.lts;
                  t3.framesDecodeFreezeTime = n2.framesDecodeFreezeTime, t3.framesDecodeInterval = n2.framesDecodeInterval, t3.framesDecodeCount > n2.framesDecodeCount && this.isFirstVideoDecoded[t3.ssrc] ? (i2.lts = Date.now(), t3.framesDecodeInterval = r2, t3.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e3.ssrc, 10)) ? t3.framesDecodeFreezeTime += t3.framesDecodeInterval : this.setVideoIsReady2(parseInt(e3.ssrc, 10), true))) : t3.framesDecodeCount < i2.stats.framesDecodeCount && (t3.framesDecodeInterval = 0);
                }
                this.lastDecodeVideoReceiverStats.set(t3.ssrc, { stats: SN({}, t3), lts: Date.now() }), this._stats.videoRecv.push(t3);
                break;
              }
              case "audio_recv": {
                const t3 = nN(pN);
                t3.codec = e3.googCodecName, t3.outputLevel = Math.abs(Number(e3.audioOutputLevel)) / 32767, t3.decodingCNG = Number(e3.googDecodingCNG), t3.decodingCTN = Number(e3.googDecodingCTN), t3.decodingCTSG = Number(e3.googDecodingCTSG), t3.decodingNormal = Number(e3.googDecodingNormal), t3.decodingPLC = Number(e3.googDecodingPLC), t3.decodingPLCCNG = Number(e3.googDecodingPLCCNG), t3.expandRate = Number(e3.googExpandRate), t3.accelerateRate = Number(e3.googAccelerateRate), t3.preemptiveExpandRate = Number(e3.googPreemptiveExpandRate), t3.secondaryDecodedRate = Number(e3.googSecondaryDecodedRate), t3.speechExpandRate = Number(e3.googSpeechExpandRate), t3.preferredJitterBufferMs = Number(e3.googPreferredJitterBufferMs), t3.jitterBufferMs = Number(e3.googJitterBufferMs), t3.jitterMs = Number(e3.googJitterReceived), t3.bytes = Number(e3.bytesReceived), t3.packets = Number(e3.packetsReceived), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.receivedFrames = Number(e3.googDecodingCTN) || Number(e3.packetsReceived), t3.droppedFrames = Number(e3.googDecodingPLC) + Number(e3.googDecodingPLCCNG) || Number(e3.packetsLost), t3.receivedFrames > 0 && !this.isFirstAudioReceived[t3.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t3.ssrc), this.isFirstAudioReceived[t3.ssrc] = true), t3.decodingNormal > 0 && !this.isFirstAudioDecoded[t3.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t3.ssrc), this.isFirstAudioDecoded[t3.ssrc] = true), this._stats.audioRecv.push(t3);
                break;
              }
              case "audio_send": {
                const t3 = nN(hN);
                t3.codec = e3.googCodecName, t3.inputLevel = Math.abs(Number(e3.audioInputLevel)) / 32767, t3.aecReturnLoss = Number(e3.googEchoCancellationReturnLoss || 0), t3.aecReturnLossEnhancement = Number(e3.googEchoCancellationReturnLossEnhancement || 0), t3.residualEchoLikelihood = Number(e3.googResidualEchoLikelihood || 0), t3.residualEchoLikelihoodRecentMax = Number(e3.googResidualEchoLikelihoodRecentMax || 0), t3.bytes = Number(e3.bytesSent), t3.packets = Number(e3.packetsSent), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.rttMs = Number(e3.googRtt || 0), this._stats.rtt = t3.rttMs, this._stats.audioSend.push(t3);
                break;
              }
            }
          });
        }
        _getStats() {
          return new Sl((e2, t2) => {
            this.pc.getStats(e2, t2);
          });
        }
        statsResponsesToObjects(e2) {
          const t2 = [];
          return e2.result().forEach((e3) => {
            const i2 = { id: e3.id, timestamp: e3.timestamp.valueOf().toString(), type: e3.type };
            e3.names().forEach((t3) => {
              i2[t3] = e3.stat(t3);
            }), t2.push(i2);
          }), t2;
        }
      }
      function gN(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function RN(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? gN(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : gN(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class IN extends mN {
        constructor() {
          super(...arguments), _p(this, "_stats", dN), _p(this, "report", void 0), _p(this, "lastDecodeVideoReceiverStats", /* @__PURE__ */ new Map()), _p(this, "lastVideoFramesRecv", /* @__PURE__ */ new Map()), _p(this, "lastVideoFramesSent", /* @__PURE__ */ new Map()), _p(this, "lastVideoFramesDecode", /* @__PURE__ */ new Map()), _p(this, "lastVideoJBDelay", /* @__PURE__ */ new Map()), _p(this, "lastAudioJBDelay", /* @__PURE__ */ new Map()), _p(this, "mediaBytesSent", /* @__PURE__ */ new Map()), _p(this, "mediaBytesRetransmit", /* @__PURE__ */ new Map()), _p(this, "mediaBytesTargetEncode", /* @__PURE__ */ new Map()), _p(this, "lastEncoderMs", /* @__PURE__ */ new Map());
        }
        async updateStats() {
          this.report = await this.pc.getStats(), this._stats = nN(dN), this.report.forEach((e2) => {
            switch (e2.type) {
              case kh.OUTBOUND:
                "audio" === e2.mediaType ? this.processAudioOutboundStats(e2) : "video" === e2.mediaType && this.processVideoOutboundStats(e2);
                break;
              case kh.INBOUND:
                "audio" === e2.mediaType ? this.processAudioInboundStats(e2) : "video" === e2.mediaType && this.processVideoInboundStats(e2);
                break;
              case kh.TRANSPORT: {
                const t2 = this.report.get(e2.selectedCandidatePairId);
                t2 && this.processCandidatePairStats(t2);
                break;
              }
              case kh.CANDIDATE_PAIR:
                e2.selected && this.processCandidatePairStats(e2);
            }
          }), this.updateSendBitrate(), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats;
        }
        async getSelectedCandidatePair() {
          const e2 = await this.pc.getStats(), t2 = { local: RN({}, cN), remote: RN({}, cN) };
          return e2.forEach((i2) => {
            let n2;
            if (i2.type === kh.TRANSPORT && (n2 = e2.get(i2.selectedCandidatePairId)), i2.type === kh.CANDIDATE_PAIR && i2.selected && (n2 = i2), n2) {
              const i3 = (e3, t3) => {
                e3.type = t3.type, e3.id = t3.id, t3.address && (e3.address = t3.address), t3.candidateType && (e3.candidateType = t3.candidateType), t3.port && (e3.port = t3.port), t3.priority && (e3.priority = t3.priority), t3.protocol && (e3.protocol = t3.protocol), t3.relayProtocol && (e3.relayProtocol = t3.relayProtocol);
              };
              if (n2.localCandidateId) {
                const r2 = e2.get(n2.localCandidateId);
                r2 && i3(t2.local, r2);
              }
              if (n2.remoteCandidateId) {
                const r2 = e2.get(n2.remoteCandidateId);
                r2 && i3(t2.remote, r2);
              }
            }
          }), t2;
        }
        processCandidatePairStats(e2) {
          if (this._stats.sendBandwidth = e2.availableOutgoingBitrate || 0, e2.currentRoundTripTime && (this._stats.rtt = 1e3 * e2.currentRoundTripTime), this._stats.videoSend.forEach((t2) => {
            e2.currentRoundTripTime && (t2.rttMs = 1e3 * e2.currentRoundTripTime);
          }), this._stats.audioSend.forEach((t2) => {
            e2.currentRoundTripTime && (t2.rttMs = 1e3 * e2.currentRoundTripTime);
          }), this._stats.selectedCandidatePair.id = e2.id, e2.localCandidateId) {
            const t2 = this.report.get(e2.localCandidateId);
            t2 && this.processCandidateStats(t2);
          }
          if (e2.remoteCandidateId) {
            const t2 = this.report.get(e2.remoteCandidateId);
            t2 && this.processCandidateStats(t2);
          }
        }
        processCandidateStats(e2) {
          let t2;
          e2.type === kh.LOCAL_CANDIDATE && (t2 = this._stats.selectedCandidatePair.localCandidate), e2.type === kh.REMOTE_CANDIDATE && (t2 = this._stats.selectedCandidatePair.remoteCandidate), t2 && (t2.type = e2.type, t2.id = e2.id, e2.address && (t2.address = e2.address), e2.candidateType && (t2.candidateType = e2.candidateType), e2.port && (t2.port = e2.port), e2.priority && (t2.priority = e2.priority), e2.protocol && (t2.protocol = e2.protocol), e2.relayProtocol && (t2.relayProtocol = e2.relayProtocol), e2.type === kh.LOCAL_CANDIDATE && this.stats.selectedCandidatePair.localCandidate.id !== t2.id && this.onSelectedLocalCandidateChanged && this.onSelectedLocalCandidateChanged(RN({}, t2), RN({}, this.stats.selectedCandidatePair.localCandidate)), e2.type === kh.REMOTE_CANDIDATE && this.stats.selectedCandidatePair.remoteCandidate.id !== t2.id && this.onSelectedRemoteCandidateChanged && this.onSelectedRemoteCandidateChanged(RN({}, t2), RN({}, this.stats.selectedCandidatePair.remoteCandidate)));
        }
        processAudioInboundStats(e2) {
          let t2 = this._stats.audioRecv.find((t3) => t3.ssrc === e2.ssrc);
          t2 || (t2 = nN(pN), this._stats.audioRecv.push(t2)), t2.ssrc = e2.ssrc, t2.packets = e2.packetsReceived, t2.packetsLost = e2.packetsLost, t2.bytes = e2.bytesReceived, t2.jitterMs = 1e3 * e2.jitter, this.processAudioTrackReceiverStats(e2, e2.trackId, t2), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), t2.receivedFrames || (t2.receivedFrames = e2.packetsReceived), t2.droppedFrames || (t2.droppedFrames = e2.packetsLost), t2.receivedFrames > 0 && !this.isFirstAudioReceived[t2.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t2.ssrc), this.isFirstAudioReceived[t2.ssrc] = true), t2.outputLevel && t2.outputLevel > 0 && !this.isFirstAudioDecoded[t2.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t2.ssrc), this.isFirstAudioDecoded[t2.ssrc] = true), "number" == typeof e2.concealedSamples && (t2.concealedSamples = e2.concealedSamples);
        }
        processVideoInboundStats(e2) {
          let t2 = this._stats.videoRecv.find((t3) => t3.ssrc === e2.ssrc);
          t2 || (t2 = nN(uN), this._stats.videoRecv.push(t2)), t2.ssrc = e2.ssrc, t2.packets = e2.packetsReceived, t2.packetsLost = e2.packetsLost, t2.bytes = e2.bytesReceived, t2.firsCount = e2.firCount, t2.nacksCount = e2.nackCount, t2.plisCount = e2.pliCount, t2.framesDecodeCount = e2.framesDecoded, t2.totalInterFrameDelay = e2.totalInterFrameDelay, t2.totalSquaredInterFrameDelay = e2.totalSquaredInterFrameDelay;
          const i2 = this.lastDecodeVideoReceiverStats.get(t2.ssrc), n2 = this.lastVideoFramesDecode.get(t2.ssrc), r2 = Date.now();
          if (t2.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t2.ssrc]) {
            const e3 = t2.decodedFrame ? t2.decodedFrame.width : 0, i3 = t2.decodedFrame ? t2.decodedFrame.height : 0;
            this.onFirstVideoDecoded && this.onFirstVideoDecoded(t2.ssrc, e3, i3), this.isFirstVideoDecoded[t2.ssrc] = true;
          }
          if (i2) {
            const n3 = i2.stats, o2 = r2 - i2.lts;
            t2.framesDecodeFreezeTime = n3.framesDecodeFreezeTime, t2.framesDecodeInterval = n3.framesDecodeInterval, !this.isFirstVideoDecoded[t2.ssrc] && o2 > this.options.firstVideoDecodedTimeout && !this.isFirstVideoDecodedTimeout[t2.ssrc] && (this.onFirstVideoDecodedTimeout && this.onFirstVideoDecodedTimeout(t2.ssrc), this.isFirstVideoDecodedTimeout[t2.ssrc] = true), t2.framesDecodeCount > n3.framesDecodeCount && this.isFirstVideoDecoded[t2.ssrc] ? (i2.lts = Date.now(), t2.framesDecodeInterval = o2, t2.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e2.ssrc)) ? t2.framesDecodeFreezeTime += t2.framesDecodeInterval : this.setVideoIsReady2(parseInt(e2.ssrc, 10), true))) : t2.framesDecodeCount < n3.framesDecodeCount && (t2.framesDecodeInterval = 0), e2.framesDecoded && e2.qpSum && (i2.stats.framesDecodeCount > e2.framesDecoded ? t2.qpSumPerFrame = e2.qpSum / e2.framesDecoded : t2.qpSumPerFrame = (e2.qpSum - i2.qpSum) / (e2.framesDecoded - i2.stats.framesDecodeCount));
          }
          n2 && r2 - n2.lts >= 800 ? (t2.decodeFrameRate = Math.round((t2.framesDecodeCount - n2.count) / ((r2 - n2.lts) / 1e3)), this.lastVideoFramesDecode.set(t2.ssrc, { count: t2.framesDecodeCount, lts: r2, rate: t2.decodeFrameRate })) : n2 ? t2.decodeFrameRate = n2.rate : this.lastVideoFramesDecode.set(t2.ssrc, { count: t2.framesDecodeCount, lts: r2, rate: 0 }), e2.totalDecodeTime && (t2.decodeMs = 1e3 * e2.totalDecodeTime), this.processVideoTrackReceiverStats(e2, e2.trackId, t2), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), e2.framerateMean && (t2.framesRateFirefox = e2.framerateMean), t2.packets > 0 && !this.isFirstVideoReceived[t2.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t2.ssrc), this.isFirstVideoReceived[t2.ssrc] = true), this.lastDecodeVideoReceiverStats.set(t2.ssrc, { stats: RN({}, t2), lts: i2 ? i2.lts : Date.now(), qpSum: e2.qpSum });
        }
        processVideoOutboundStats(e2) {
          let t2 = this._stats.videoSend.find((t3) => t3.ssrc === e2.ssrc);
          t2 || (t2 = nN(lN), this._stats.videoSend.push(t2));
          const i2 = this.mediaBytesSent.get(e2.ssrc);
          if (i2)
            i2.add(e2.bytesSent);
          else {
            const t3 = new aN(10);
            t3.add(e2.bytesSent), this.mediaBytesSent.set(e2.ssrc, t3);
          }
          if (void 0 !== e2.retransmittedBytesSent) {
            const t3 = this.mediaBytesRetransmit.get(e2.ssrc);
            if (t3)
              t3.add(e2.retransmittedBytesSent);
            else {
              const t4 = new aN(10);
              t4.add(e2.retransmittedBytesSent), this.mediaBytesRetransmit.set(e2.ssrc, t4);
            }
          }
          if (e2.totalEncodedBytesTarget) {
            const t3 = this.mediaBytesTargetEncode.get(e2.ssrc);
            if (t3)
              t3.add(e2.totalEncodedBytesTarget);
            else {
              const t4 = new aN(10);
              t4.add(e2.totalEncodedBytesTarget), this.mediaBytesTargetEncode.set(e2.ssrc, t4);
            }
          }
          if (t2.ssrc = e2.ssrc, t2.bytes = e2.bytesSent, t2.packets = e2.packetsSent, t2.firsCount = e2.firCount, t2.nacksCount = e2.nackCount, t2.plisCount = e2.pliCount, t2.frameCount = e2.framesEncoded, t2.adaptionChangeReason = e2.qualityLimitationReason, t2.scalabilityMode = e2.scalabilityMode, e2.totalEncodeTime && e2.framesEncoded) {
            const i3 = this.lastEncoderMs.get(e2.ssrc);
            if (!i3 || i3.lastFrameCount > e2.framesEncoded)
              t2.avgEncodeMs = 1e3 * e2.totalEncodeTime / e2.framesEncoded;
            else {
              const n2 = e2.framesEncoded - i3.lastFrameCount, r2 = e2.totalEncodeTime - i3.lastEncoderTime;
              t2.avgEncodeMs = 1e3 * r2 / n2;
            }
          }
          if (e2.framesEncoded && e2.qpSum) {
            const i3 = this.lastEncoderMs.get(e2.ssrc);
            !i3 || i3.lastFrameCount > e2.framesEncoded ? t2.qpSumPerFrame = e2.qpSum / e2.framesEncoded : t2.qpSumPerFrame = (e2.qpSum - i3.lastQpSum) / (e2.framesEncoded - i3.lastFrameCount);
          }
          if (this.lastEncoderMs.set(e2.ssrc, { lastFrameCount: e2.framesEncoded, lastEncoderTime: e2.totalEncodeTime, lastQpSum: e2.qpSum, lts: Date.now() }), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), e2.mediaSourceId && this.processVideoMediaSource(e2.mediaSourceId, t2), this.processVideoTrackSenderStats(e2, e2.trackId, t2), e2.remoteId)
            this.processRemoteInboundStats(e2.remoteId, t2);
          else {
            const i3 = this.findRemoteStatsId(e2.ssrc, kh.REMOTE_INBOUND);
            i3 && this.processRemoteInboundStats(i3, t2);
          }
        }
        processAudioOutboundStats(e2) {
          let t2 = this._stats.audioSend.find((t3) => t3.ssrc === e2.ssrc);
          if (t2 || (t2 = nN(hN), this._stats.audioSend.push(t2)), t2.ssrc = e2.ssrc, t2.packets = e2.packetsSent, t2.bytes = e2.bytesSent, e2.mediaSourceId && this.processAudioMediaSource(e2.mediaSourceId, t2), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), this.processAudioTrackSenderStats(e2, e2.trackId, t2), e2.remoteId)
            this.processRemoteInboundStats(e2.remoteId, t2);
          else {
            const i2 = this.findRemoteStatsId(e2.ssrc, kh.REMOTE_INBOUND);
            i2 && this.processRemoteInboundStats(i2, t2);
          }
        }
        findRemoteStatsId(e2, t2) {
          var i2;
          const n2 = Array.from(IR(i2 = this.report).call(i2)).find((i3) => i3.type === t2 && i3.ssrc === e2);
          return n2 ? n2.id : null;
        }
        processVideoMediaSource(e2, t2) {
          const i2 = this.report.get(e2);
          i2 && i2.width && i2.height && i2.framesPerSecond && (t2.inputFrame = { width: i2.width, height: i2.height, frameRate: i2.framesPerSecond });
        }
        processAudioMediaSource(e2, t2) {
          const i2 = this.report.get(e2);
          i2 && (t2.inputLevel = i2.audioLevel);
        }
        processVideoTrackSenderStats(e2, t2, i2) {
          var n2, r2, o2;
          const s2 = t2 ? this.report.get(t2) : void 0, a2 = null !== (n2 = null == s2 ? void 0 : s2.framesSent) && void 0 !== n2 ? n2 : e2.framesSent;
          let c2 = null !== (r2 = null == s2 ? void 0 : s2.frameWidth) && void 0 !== r2 ? r2 : e2.frameWidth, d2 = null !== (o2 = null == s2 ? void 0 : s2.frameHeight) && void 0 !== o2 ? o2 : e2.frameHeight;
          if ("number" != typeof a2)
            return;
          "number" == typeof c2 && "number" == typeof d2 || (c2 = 0, d2 = 0);
          let u2 = 0;
          const l2 = Date.now(), h2 = this.lastVideoFramesSent.get(i2.ssrc);
          h2 && l2 - h2.lts >= 800 ? (u2 = Math.round((a2 - h2.count) / ((l2 - h2.lts) / 1e3)), this.lastVideoFramesSent.set(i2.ssrc, { count: a2, lts: l2, rate: u2 })) : h2 ? u2 = h2.rate : this.lastVideoFramesSent.set(i2.ssrc, { count: a2, lts: l2, rate: 0 }), i2.sentFrame = { width: c2, height: d2, frameRate: Math.max(0, u2) };
        }
        processVideoTrackReceiverStats(e2, t2, i2) {
          var n2, r2, o2, s2, a2;
          const c2 = t2 ? this.report.get(t2) : void 0, d2 = null !== (n2 = null == c2 ? void 0 : c2.framesReceived) && void 0 !== n2 ? n2 : e2.framesReceived, u2 = null !== (r2 = null == c2 ? void 0 : c2.frameWidth) && void 0 !== r2 ? r2 : e2.frameWidth, l2 = null !== (o2 = null == c2 ? void 0 : c2.frameHeight) && void 0 !== o2 ? o2 : e2.frameHeight, h2 = null !== (s2 = null == c2 ? void 0 : c2.jitterBufferDelay) && void 0 !== s2 ? s2 : e2.jitterBufferDelay, p2 = null !== (a2 = null == c2 ? void 0 : c2.jitterBufferEmittedCount) && void 0 !== a2 ? a2 : e2.jitterBufferEmittedCount;
          if ("number" == typeof d2) {
            const e3 = this.lastVideoFramesRecv.get(i2.ssrc), t3 = Date.now();
            i2.framesReceivedCount = d2;
            let n3 = 0;
            e3 && t3 - e3.lts >= 800 ? (n3 = Math.round((d2 - e3.count) / ((t3 - e3.lts) / 1e3)), this.lastVideoFramesRecv.set(i2.ssrc, { count: d2, lts: t3, rate: n3 })) : e3 ? n3 = e3.rate : this.lastVideoFramesRecv.set(i2.ssrc, { count: d2, lts: t3, rate: 0 }), i2.receivedFrame = { width: u2 || 0, height: l2 || 0, frameRate: n3 || 0 }, i2.decodedFrame = { width: u2 || 0, height: l2 || 0, frameRate: i2.decodeFrameRate || 0 }, i2.outputFrame = { width: u2 || 0, height: l2 || 0, frameRate: i2.decodeFrameRate || 0 };
          }
          if (h2 && p2) {
            let e3 = this.lastVideoJBDelay.get(i2.ssrc);
            this.lastVideoJBDelay.set(i2.ssrc, { jitterBufferDelay: h2, jitterBufferEmittedCount: p2 }), e3 || (e3 = { jitterBufferDelay: 0, jitterBufferEmittedCount: 0 });
            const t3 = 1e3 * (h2 - e3.jitterBufferDelay) / (p2 - e3.jitterBufferEmittedCount);
            i2.jitterBufferMs = t3, i2.currentDelayMs = Math.round(t3);
          }
        }
        processAudioTrackSenderStats(e2, t2, i2) {
          var n2, r2, o2, s2;
          const a2 = t2 ? this.report.get(t2) : void 0, c2 = null !== (n2 = null !== (r2 = null == a2 ? void 0 : a2.echoReturnLoss) && void 0 !== r2 ? r2 : e2.echoReturnLoss) && void 0 !== n2 ? n2 : 0, d2 = null !== (o2 = null !== (s2 = null == a2 ? void 0 : a2.echoReturnLossEnhancement) && void 0 !== s2 ? s2 : e2.echoReturnLossEnhancement) && void 0 !== o2 ? o2 : 0;
          i2.aecReturnLoss = c2, i2.aecReturnLossEnhancement = d2;
        }
        processAudioTrackReceiverStats(e2, t2, i2) {
          var n2, r2, o2, s2, a2, c2, d2;
          const u2 = t2 ? this.report.get(t2) : void 0, l2 = null !== (n2 = null == u2 ? void 0 : u2.removedSamplesForAcceleration) && void 0 !== n2 ? n2 : e2.removedSamplesForAcceleration, h2 = null !== (r2 = null == u2 ? void 0 : u2.totalSamplesReceived) && void 0 !== r2 ? r2 : e2.totalSamplesReceived, p2 = null !== (o2 = null == u2 ? void 0 : u2.jitterBufferDelay) && void 0 !== o2 ? o2 : e2.jitterBufferDelay, _2 = null !== (s2 = null == u2 ? void 0 : u2.jitterBufferEmittedCount) && void 0 !== s2 ? s2 : e2.jitterBufferEmittedCount, E2 = null !== (a2 = null == u2 ? void 0 : u2.audioLevel) && void 0 !== a2 ? a2 : null == e2 ? void 0 : e2.audioLevel, m2 = null !== (c2 = null == u2 ? void 0 : u2.totalSamplesDuration) && void 0 !== c2 ? c2 : null == e2 ? void 0 : e2.totalSamplesDuration, f2 = null !== (d2 = null == u2 ? void 0 : u2.concealedSamples) && void 0 !== d2 ? d2 : e2.concealedSamples;
          if (l2 && h2 && (i2.accelerateRate = l2 / h2), p2 && _2) {
            let e3 = this.lastAudioJBDelay.get(i2.ssrc);
            this.lastAudioJBDelay.set(i2.ssrc, { jitterBufferDelay: p2, jitterBufferEmittedCount: _2 }), e3 || (e3 = { jitterBufferDelay: 0, jitterBufferEmittedCount: 0 });
            const t3 = 1e3 * (p2 - e3.jitterBufferDelay) / (_2 - e3.jitterBufferEmittedCount);
            i2.jitterBufferMs = Math.round(t3);
          }
          i2.outputLevel = E2;
          let S2 = 1920;
          m2 && h2 && (S2 = h2 / m2 / 50, i2.receivedFrames = Math.round(h2 / S2)), f2 && (i2.droppedFrames = Math.round(f2 / S2));
        }
        processRemoteInboundStats(e2, t2) {
          const i2 = this.report.get(e2);
          i2 && (t2.packetsLost = i2.packetsLost, i2.roundTripTime && (t2.rttMs = 1e3 * i2.roundTripTime));
        }
        getCodecFromCodecStats(e2) {
          const t2 = this.report.get(e2);
          if (!t2)
            return "";
          const i2 = t2.mimeType.match(/\/(.*)$/);
          return i2 && i2[1] ? i2[1] : "";
        }
        updateSendBitrate() {
          let e2 = 0, t2 = null, i2 = null;
          this.mediaBytesSent.forEach((t3) => {
            e2 += t3.diffMean();
          }), this.mediaBytesRetransmit.forEach((e3) => {
            t2 = null === t2 ? e3.diffMean() : t2 + e3.diffMean();
          }), this.mediaBytesTargetEncode.forEach((e3) => {
            i2 = null === i2 ? e3.diffMean() : i2 + e3.diffMean();
          });
          const n2 = null !== t2 ? e2 - t2 : e2;
          this._stats.bitrate = { actualEncoded: 8 * n2 / (this.options.updateInterval / 1e3), transmit: 8 * e2 / (this.options.updateInterval / 1e3) }, null !== t2 && (this._stats.bitrate.retransmit = 8 * t2 / (this.options.updateInterval / 1e3)), null !== i2 && (this._stats.bitrate.targetEncoded = 8 * i2 / (this.options.updateInterval / 1e3));
        }
      }
      class CN extends mN {
        updateStats() {
          return Sl.resolve();
        }
      }
      function vN(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 250, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 8, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 500, r2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1e4;
        const o2 = oN();
        return o2 ? o2 < 76 ? new TN(e2, { updateInterval: t2, lossRateInterval: i2, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 }) : new IN(e2, { updateInterval: t2, lossRateInterval: i2, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 }) : sN(e2) ? new IN(e2, { updateInterval: t2, lossRateInterval: i2, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 }) : new CN(e2, { updateInterval: t2, lossRateInterval: i2, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 });
      }
      var yN;
      function AN(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function ON(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? AN(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : AN(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      let NN = (ag((yN = class e2 extends YS {
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        constructor(t2, i2) {
          super(t2, i2), _p(this, "store", void 0), _p(this, "peerConnection", void 0), _p(this, "remoteSDP", void 0), _p(this, "initialOffer", void 0), _p(this, "statsFilter", void 0), _p(this, "useRTX", false), _p(this, "localCapabilities", void 0), _p(this, "localCandidateCount", 0), _p(this, "allCandidatesReceived", false), _p(this, "establishPromise", void 0), _p(this, "mutex", new Ug("P2PConnection-mutex")), this.store = i2, this.peerConnection = new RTCPeerConnection(e2.resolvePCConfiguration(t2), { optional: [{ googDscp: true }] }), this.statsFilter = vN(this.peerConnection, GE("STATS_UPDATE_INTERVAL"), void 0, Kh() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();
        }
        async establish() {
          try {
            const e3 = await this.peerConnection.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
            if (!e3.sdp)
              throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
            const t2 = FO(e3.sdp), i2 = jO(e3.sdp, !this.useRTX, GE("FILTER_VIDEO_FEC"), GE("FILTER_AUDIO_FEC"), ["opus"]);
            return this.localCapabilities = i2, this.initialOffer = e3, ON(ON({}, t2), {}, { rtpCapabilities: { send: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, recv: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, sendrecv: i2 }, offerSDP: e3.sdp });
          } catch (e3) {
            throw new SE(fE.GET_LOCAL_CONNECTION_PARAMS_FAILED, e3.toString());
          }
        }
        async connect(e3, t2, i2, n2, r2, o2) {
          try {
            if (!this.initialOffer)
              throw new Error("Cannot establish P2PConnection without initial offer.");
            this.remoteSDP = new iN({ remoteIceParameters: e3, remoteDtlsParameters: t2, candidates: i2, remoteRTPCapabilities: n2.send, remoteSetup: r2, localCapabilities: this.localCapabilities, sdkCodec: this.store.codec, cname: o2 });
            const s2 = this.remoteSDP.toString();
            await this.peerConnection.setLocalDescription(this.initialOffer), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: s2 });
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e4.toString()));
          }
        }
        send(e3, t2) {
          var i2 = this;
          return DO(function* () {
            const n2 = yield PO(i2.mutex.lock());
            try {
              if (!i2.remoteSDP)
                throw new Error("Cannot call P2PConnection.send before remote SDP created");
              const r2 = e3.map((e4) => i2.peerConnection.addTrack(e4._mediaStreamTrack)), o2 = yield PO(i2.peerConnection.createOffer()), s2 = UO.exports.parse(o2.sdp), a2 = e3.map((e4) => {
                const t3 = e4._mediaStreamTrack, n3 = s2.mediaDescriptions.find((e5) => e5.attributes.mid === t3.kind);
                if (!n3)
                  throw new Error("Cannot extract ssrc from mediaDescription.");
                return function(e5, t4, i3) {
                  const n4 = e5.attributes.ssrcs.filter((e6) => e6.attributes.label === t4), r3 = e5.attributes.ssrcGroups;
                  if (0 === n4.length)
                    throw new Error("Cannot extract ssrc from plan-b SDP.");
                  if (r3 && n4.length > 1) {
                    const e6 = r3.find((e7) => -1 !== e7.ssrcIds.indexOf(n4[0].ssrcId));
                    return e6 ? [{ ssrcId: e6.ssrcIds[0], rtx: i3 ? e6.ssrcIds[1] : void 0 }] : [{ ssrcId: n4[0].ssrcId }];
                  }
                  return [{ ssrcId: n4[0].ssrcId }];
                }(n3, t3.id, i2.useRTX);
              });
              let c2;
              try {
                c2 = yield a2;
              } catch (e4) {
                throw r2.forEach((e5) => {
                  Hh() && e5.replaceTrack(null), i2.peerConnection.removeTrack(e5);
                }), e4;
              }
              const d2 = i2.mungSendOfferSDP(o2.sdp, e3);
              i2.remoteSDP.receive(e3, t2, c2);
              const u2 = i2.remoteSDP.toString();
              return yield PO(i2.peerConnection.setLocalDescription({ type: "offer", sdp: d2 })), yield PO(i2.applySendEncodings(r2, e3)), yield PO(i2.peerConnection.setRemoteDescription({ type: "answer", sdp: u2 })), e3.map((e4, t3) => {
                const i3 = e4._mediaStreamTrack.id;
                return { localSSRC: a2[t3], id: i3 };
              });
            } catch (e4) {
              throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e4.toString()));
            } finally {
              n2();
            }
          })();
        }
        async stopSending(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
            const t2 = this.peerConnection.getSenders().filter((t3) => {
              var i3;
              return -1 !== e3.indexOf((null === (i3 = t3.track) || void 0 === i3 ? void 0 : i3.id) || "");
            });
            if (t2.length !== e3.length)
              throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
            t2.map((e4) => {
              Hh() && e4.replaceTrack(null), this.peerConnection.removeTrack(e4);
            });
            const i2 = await this.peerConnection.createOffer();
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.stopReceiving(e3);
            const n2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e4.toString()));
          }
        }
        async receive(e3, t2, i2, n2) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.receive ".concat(e3, " before remoteSDP created."));
            const { id: i3, mslabel: r2 } = this.remoteSDP.send(e3, t2, n2), o2 = new Sl((t3, n3) => {
              const o3 = setTimeout(() => {
                n3(new Error("Cannot receive track, id: ".concat(i3)));
              }, 1e4), s3 = (n4) => {
                const a3 = xh();
                if (("Safari" === a3.name && 11 === Number(a3.version) || Yh()) && n4.track.id !== i3 && n4.streams[0].id === r2) {
                  var c2;
                  const r3 = n4.streams[0].getTracks()[0];
                  return null === (c2 = this.remoteSDP) || void 0 === c2 || c2.updateTrackLabel(e3, i3, n4.track.id), this.peerConnection.removeEventListener("track", s3), clearTimeout(o3), void t3(r3);
                }
                if (n4.track.id === i3)
                  return this.peerConnection.removeEventListener("track", s3), clearTimeout(o3), void t3(n4.track);
              };
              this.peerConnection.addEventListener("track", s3);
            }), s2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: s2 });
            const a2 = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(a2);
            return { track: await o2, id: i3 };
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async stopReceiving(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
            this.remoteSDP.stopSending(e3);
            const t2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const i2 = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(i2);
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e4.toString()));
          }
        }
        async muteRemote(e3) {
        }
        async unmuteRemote(e3) {
        }
        async muteLocal(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
            const t2 = this.peerConnection.getSenders().filter((t3) => {
              var i2;
              return -1 !== e3.indexOf((null === (i2 = t3.track) || void 0 === i2 ? void 0 : i2.id) || "");
            });
            if (t2.length !== e3.length)
              throw new Error("sender' length doesn't match mids' length.");
            t2.map((e4) => {
              if (Hh() && e4.track)
                e4.track.enabled = false;
              else {
                const t3 = e4.getParameters();
                t3.encodings.forEach((e5) => e5.active = false), e4.setParameters(t3);
              }
            });
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e4.toString()));
          }
        }
        async unmuteLocal(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
            const t2 = this.peerConnection.getSenders().filter((t3) => {
              var i3;
              return -1 !== e3.indexOf((null === (i3 = t3.track) || void 0 === i3 ? void 0 : i3.id) || "");
            });
            if (t2.length !== e3.length)
              throw new Error("Senders' length doesn't match mids' length.");
            t2.map(async (e4) => {
              if (Hh() && e4.track)
                e4.track.enabled = true;
              else {
                const t3 = e4.getParameters();
                t3.encodings.forEach((e5) => e5.active = true), await e4.setParameters(t3);
              }
            });
            const i2 = await this.peerConnection.createOffer();
            await this.peerConnection.setLocalDescription(i2);
            const n2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e4.toString()));
          }
        }
        restartICE(e3) {
          var t2 = this;
          return DO(function* () {
            const i2 = yield PO(t2.mutex.lock("From P2PConnection.restartICE"));
            try {
              if (!t2.remoteSDP)
                throw new Error("Cannot restartICE before remoteSDP created.");
              if (JS().supportPCSetConfiguration) {
                const i3 = t2.peerConnection.getConfiguration(), n3 = e3 === OS.RELAY ? "relay" : "all";
                i3.iceTransportPolicy !== n3 && (OE.debug("[".concat(t2.store.clientId, "] restartICE change iceTransportPolicy from [").concat(i3.iceTransportPolicy, "] to [").concat(n3, "]")), i3.iceTransportPolicy = n3, t2.peerConnection.setConfiguration(i3));
              } else if (e3 === OS.RELAY)
                return;
              e3 !== OS.RELAY && t2.remoteSDP.updateCandidates(e3);
              const n2 = yield PO(t2.peerConnection.createOffer({ iceRestart: true }));
              if (!n2.sdp)
                throw new Error("Cannot restartICE because restart offer SDP does not exist.");
              const r2 = FO(n2.sdp), { remoteIceParameters: o2 } = yield r2.iceParameters;
              t2.remoteSDP.restartICE(o2);
              const s2 = t2.remoteSDP.toString();
              yield PO(t2.peerConnection.setLocalDescription(n2)), yield PO(t2.peerConnection.setRemoteDescription({ type: "answer", sdp: s2 }));
            } catch (e4) {
              OE.warning("[".concat(t2.store.clientId, "] restart ICE failed, abort operation"), e4);
            } finally {
              i2();
            }
          })();
        }
        close() {
          var e3;
          this.peerConnection.close(), null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, "closed"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.statsFilter.destroy();
        }
        getStats() {
          return this.statsFilter.getStats();
        }
        getRemoteVideoIsReady(e3) {
          return this.statsFilter.getVideoIsReady(e3);
        }
        async updateEncoderConfig(e3, t2) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
            const e4 = await this.peerConnection.createOffer(), i2 = this.mungSendOfferSDP(e4.sdp, [t2]);
            this.remoteSDP.updateRecvMedia(t2._mediaStreamTrack.kind, t2);
            const n2 = this.remoteSDP.toString();
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: i2 }), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, e4.toString());
          }
        }
        async updateSendParameters(e3, t2) {
          const i2 = this.peerConnection.getSenders().filter((t3) => {
            var i3;
            return (null === (i3 = t3.track) || void 0 === i3 ? void 0 : i3.id) === e3;
          });
          1 === i2.length && await this.applySendEncodings(i2, [t2]);
        }
        setStatsRemoteVideoIsReady(e3, t2) {
          this.statsFilter.setVideoIsReady2(e3, t2);
        }
        async replaceTrack(e3, t2) {
          const i2 = this.peerConnection.getSenders().find((e4) => {
            var i3;
            return (null === (i3 = e4.track) || void 0 === i3 ? void 0 : i3.id) === t2;
          });
          i2 && await i2.replaceTrack(e3._mediaStreamTrack);
        }
        bindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = () => {
            var e3;
            null === (e3 = this.onICEConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.iceConnectionState);
          }, this.peerConnection.onconnectionstatechange = () => {
            var e3;
            null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.connectionState);
          }, this.peerConnection.onicecandidate = (e3) => {
            e3.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, OE.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
          }, setTimeout(() => {
            this.allCandidatesReceived || (this.allCandidatesReceived = true, OE.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
          }, GE("CANDIDATE_TIMEOUT"));
        }
        unbindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
        }
        static resolvePCConfiguration(t2) {
          const i2 = { iceServers: [], sdpSemantics: "plan-b" };
          return t2.iceServers ? i2.iceServers = t2.iceServers : t2.turnServer && "off" !== t2.turnServer.mode && (Uf(t2.turnServer.servers) ? i2.iceServers = t2.turnServer.servers : (i2.iceServers && i2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.servers)), GE("USE_TURN_SERVER_OF_GATEWAY") && i2.iceServers && t2.turnServer.serversFromGateway && i2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.serversFromGateway)), t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach((e3) => {
            e3.forceturn && (i2.iceTransportPolicy = "relay");
          }))), i2;
        }
        static turnServerConfigToIceServers(e3) {
          const t2 = [];
          return e3.forEach((e4) => {
            e4.security ? e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }) : (e4.udpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.udpport, "?transport=udp") }), e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }));
          }), t2;
        }
        async applySendEncodings(e3, t2) {
          try {
            if (!JS().supportSetRtpSenderParameters)
              return;
            if (e3.length !== t2.length)
              return;
            for (let n2 = 0; n2 < e3.length; n2++) {
              var i2;
              const r2 = e3[n2], o2 = t2[n2];
              if (!o2)
                continue;
              const s2 = {}, a2 = {};
              if (o2 instanceof Cy)
                switch (o2._optimizationMode) {
                  case "motion":
                    s2.degradationPreference = "maintain-framerate";
                    break;
                  case "detail":
                    s2.degradationPreference = "maintain-resolution";
                    break;
                  default:
                    s2.degradationPreference = "balanced";
                }
              if (GE("DSCP_TYPE") && rp()) {
                const e4 = GE("DSCP_TYPE");
                ["very-low", "low", "medium", "high"].includes(e4) && (a2.networkPriority = e4);
              }
              const c2 = r2.getParameters(), d2 = null === (i2 = c2.encodings) || void 0 === i2 ? void 0 : i2[0];
              d2 && Object.assign(d2, a2), Object.assign(c2, s2), await r2.setParameters(c2);
            }
          } catch (e4) {
            OE.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
          }
        }
        mungSendOfferSDP(e3, t2) {
          const i2 = UO.exports.parse(e3);
          return t2.forEach((e4, t3) => {
            const n2 = e4._mediaStreamTrack, r2 = i2.mediaDescriptions.find((e5) => e5.attributes.mid === n2.kind);
            r2 && HO(r2, e4);
          }), UO.exports.print(i2);
        }
        bindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = (e3) => {
            var t2;
            null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoReceived = (e3) => {
            var t2;
            null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstAudioDecoded = (e3) => {
            var t2;
            null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoDecoded = (e3, t2, i2) => {
            var n2;
            null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e3, t2, i2);
          }, this.statsFilter.onSelectedLocalCandidateChanged = (e3, t2) => {
            var i2;
            null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 || i2.call(this, e3, t2);
          }, this.statsFilter.onSelectedRemoteCandidateChanged = (e3, t2) => {
            var i2;
            null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 || i2.call(this, e3, t2);
          };
        }
        unbindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0;
        }
        async batchReceive(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
            const t2 = this.remoteSDP.batchSend(e3).map((t3, i3) => {
              let { id: n3, mslabel: r2 } = t3;
              const { kind: o2 } = e3[i3];
              return new Sl((e4, t4) => {
                const i4 = setTimeout(() => {
                  t4(new Error("Cannot receive track, id: ".concat(n3)));
                }, 1e4), s2 = (t5) => {
                  const a2 = xh();
                  if ("Safari" === a2.name && 11 === Number(a2.version) && t5.track.id !== n3 && t5.streams[0].id === r2) {
                    var c2;
                    const r3 = t5.streams[0].getTracks()[0];
                    return null === (c2 = this.remoteSDP) || void 0 === c2 || c2.updateTrackLabel(o2, n3, t5.track.id), this.peerConnection.removeEventListener("track", s2), clearTimeout(i4), void e4({ track: r3, id: n3 });
                  }
                  if (t5.track.id === n3)
                    return this.peerConnection.removeEventListener("track", s2), clearTimeout(i4), void e4({ track: t5.track, id: n3 });
                };
                this.peerConnection.addEventListener("track", s2);
              });
            }), i2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: i2 });
            const n2 = await this.peerConnection.createAnswer();
            return await this.peerConnection.setLocalDescription(n2), await Sl.all(t2);
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async getRemoteSSRC(e3) {
          if (!this.remoteSDP)
            return;
          const t2 = this.remoteSDP.getSSRC(e3);
          return null == t2 ? void 0 : t2[0].ssrcId;
        }
        setConfiguration(t2) {
          if (JS().supportPCSetConfiguration) {
            const i2 = e2.resolvePCConfiguration(t2);
            this.peerConnection.setConfiguration(i2);
          }
        }
      }).prototype, "connect", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "connect"), yN.prototype), ag(yN.prototype, "stopSending", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "stopSending"), yN.prototype), ag(yN.prototype, "receive", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "receive"), yN.prototype), ag(yN.prototype, "stopReceiving", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "stopReceiving"), yN.prototype), ag(yN.prototype, "muteRemote", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "muteRemote"), yN.prototype), ag(yN.prototype, "unmuteRemote", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "unmuteRemote"), yN.prototype), ag(yN.prototype, "muteLocal", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "muteLocal"), yN.prototype), ag(yN.prototype, "unmuteLocal", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "unmuteLocal"), yN.prototype), ag(yN.prototype, "close", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "close"), yN.prototype), ag(yN.prototype, "updateEncoderConfig", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "updateEncoderConfig"), yN.prototype), ag(yN.prototype, "updateSendParameters", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "updateSendParameters"), yN.prototype), ag(yN.prototype, "replaceTrack", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "replaceTrack"), yN.prototype), ag(yN.prototype, "getRemoteSSRC", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "getRemoteSSRC"), yN.prototype), yN);
      function bN(e2, t2, i2) {
        const n2 = e2[t2];
        if ("function" != typeof n2)
          throw new Error("Cannot use mutex on object property.");
        return i2.value = async function() {
          const e3 = this.mutex, i3 = await e3.lock("Locking from P2PConnection.".concat(t2));
          try {
            for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++)
              o2[s2] = arguments[s2];
            return await n2.apply(this, o2);
          } finally {
            i3();
          }
        }, i2;
      }
      function wN(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function DN(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? wN(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : wN(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      const PN = "9", LN = 4e4;
      class kN {
        get localCapabilities() {
          return uC(this._localCapabilities);
        }
        get rtpCapabilities() {
          return uC(this._rtpCapabilities);
        }
        get candidates() {
          return uC(this._candidates);
        }
        get iceParameters() {
          return uC(this._iceParameters);
        }
        get dtlsParameters() {
          return uC(this._dtlsParameters);
        }
        constructor(e2) {
          _p(this, "sessionDesc", void 0), _p(this, "_localCapabilities", void 0), _p(this, "_rtpCapabilities", void 0), _p(this, "_candidates", void 0), _p(this, "_iceParameters", void 0), _p(this, "_dtlsParameters", void 0), _p(this, "setup", void 0), _p(this, "currentMidIndex", void 0), _p(this, "cname", void 0), _p(this, "firefoxSsrcMidMap", /* @__PURE__ */ new Map()), e2 = uC(e2);
          const { remoteIceParameters: t2, remoteDtlsParameters: i2, candidates: n2, remoteRTPCapabilities: r2, remoteSetup: o2, localCapabilities: s2, cname: a2 } = e2, c2 = UO.exports.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=ice-lite\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n");
          this._rtpCapabilities = r2, this._candidates = n2, this._iceParameters = t2, this._dtlsParameters = i2, this._localCapabilities = s2, this.setup = o2, this.cname = a2;
          const d2 = this.rtpCapabilities.send;
          for (const e3 of c2.mediaDescriptions) {
            if (e3.attributes.iceUfrag = t2.iceUfrag, e3.attributes.icePwd = t2.icePwd, e3.attributes.fingerprints = i2.fingerprints, e3.attributes.candidates = n2, e3.attributes.setup = o2, "video" === e3.media.mediaType && (e3.media.fmts = d2.videoCodecs.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = d2.videoCodecs, e3.attributes.extmaps = d2.videoExtensions, GE("PRELOAD_MEDIA_COUNT") > 0)) {
              const { ssrcs: t3, ssrcGroups: i3 } = WO([{ ssrcId: LN, rtx: GE("USE_SUB_RTX") ? 40001 : void 0 }], this.cname);
              e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = i3;
            }
            if ("audio" === e3.media.mediaType && (e3.media.fmts = d2.audioCodecs.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = d2.audioCodecs, e3.attributes.extmaps = d2.audioExtensions, $O(e3), GE("PRELOAD_MEDIA_COUNT") > 0)) {
              const { ssrcs: t3, ssrcGroups: i3 } = WO([{ ssrcId: 2e4 }], this.cname);
              e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = i3;
            }
          }
          this.sessionDesc = c2, this.currentMidIndex = c2.mediaDescriptions.length - 1;
        }
        preloadRemoteMedia() {
          const e2 = GE("PRELOAD_MEDIA_COUNT");
          this.rtpCapabilities;
          const t2 = this.candidates, i2 = this.dtlsParameters, n2 = this.iceParameters, r2 = this.rtpCapabilities.send;
          for (let o2 = 1; o2 < e2; o2++) {
            const e3 = 2 * o2 + 2e4, s2 = 2 * o2 + LN, { ssrcs: a2, ssrcGroups: c2 } = WO([{ ssrcId: e3 }], this.cname), { ssrcs: d2, ssrcGroups: u2 } = WO([{ ssrcId: s2, rtx: GE("USE_SUB_RTX") ? s2 + 1 : void 0 }], this.cname);
            this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "video", port: PN, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r2.videoCodecs.map((e4) => e4.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: n2.iceUfrag, icePwd: n2.icePwd, unrecognized: [], candidates: t2, extmaps: r2.videoExtensions, fingerprints: i2.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: d2, ssrcGroups: u2, rtcpFeedbackWildcards: [], payloads: r2.videoCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(2 * o2) } }), this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "audio", port: PN, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r2.audioCodecs.map((e4) => e4.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: n2.iceUfrag, icePwd: n2.icePwd, unrecognized: [], candidates: t2, extmaps: r2.audioExtensions, fingerprints: i2.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: a2, ssrcGroups: c2, rtcpFeedbackWildcards: [], payloads: r2.audioCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(2 * o2 + 1) } }), this.currentMidIndex += 2;
          }
          this.updateBundleMids();
        }
        toString() {
          return UO.exports.print(this.sessionDesc);
        }
        send(e2, t2, i2, n2) {
          const { ssrcs: r2, ssrcGroups: o2 } = WO(t2, this.cname, GE("SYNC_GROUP") ? i2 : void 0), s2 = this.findPreloadMediaDesc(r2);
          if (s2) {
            if (Kh() && this.firefoxSsrcMidMap.set(r2[0].ssrcId, s2.attributes.mid), n2 && (n2.twcc || n2.remb)) {
              const e3 = this.sessionDesc.mediaDescriptions.indexOf(s2);
              return this.sessionDesc.mediaDescriptions[e3] = this.mungSendMediaDesc(s2, n2), { mid: s2.attributes.mid, needExchangeSDP: true };
            }
            return { mid: s2.attributes.mid, needExchangeSDP: false };
          }
          {
            const t3 = this.findAvailableMediaIndex(e2, r2);
            let i3;
            return -1 === t3 || 1 === t3 && (Hh() || zh()) || 0 === t3 && GE("USE_SUB_RTX") || Qh() ? (i3 = this.createOrRecycleSendMedia(e2, r2, o2, "sendonly", n2), this.updateBundleMids()) : (i3 = uC(this.sessionDesc.mediaDescriptions[t3]), i3.attributes.direction = "sendonly", i3.attributes.ssrcs = r2, i3.attributes.ssrcGroups = o2, this.sessionDesc.mediaDescriptions[t3] = this.mungSendMediaDesc(i3, n2)), Kh() && this.firefoxSsrcMidMap.set(r2[0].ssrcId, i3.attributes.mid), { mid: i3.attributes.mid, needExchangeSDP: true };
          }
        }
        batchSend(e2) {
          const t2 = e2.map((e3) => {
            let { kind: t3, ssrcMsg: i3, mslabel: n3 } = e3;
            return this.send(t3, i3, n3);
          }), i2 = [];
          let n2 = false;
          return t2.forEach((e3) => {
            let { mid: t3, needExchangeSDP: r2 } = e3;
            r2 && (n2 = true), i2.push(t3);
          }), { mids: i2, needExchangeSDP: n2 };
        }
        stopSending(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => t3.attributes.mid && -1 !== e2.indexOf(t3.attributes.mid));
          if (t2.length !== e2.length)
            throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
          t2.forEach((e3) => {
            "0" === e3.attributes.mid || Kh() || Qh() ? e3.attributes.ssrcs = [] : (e3.attributes.ssrcs = [], e3.attributes.direction = "inactive", e3.media.port = "0");
          }), this.updateBundleMids();
        }
        mute(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2);
          if (!t2)
            throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.mute."));
          t2.attributes.direction = "inactive";
        }
        unmute(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2);
          if (!t2)
            throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.unmute."));
          t2.attributes.direction = "sendonly";
        }
        muteRemote(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => e2.includes(t3.attributes.mid || ""));
          if (t2.length !== e2.length)
            throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
          t2.forEach((e3) => {
            e3.attributes.direction = "inactive";
          });
        }
        unmuteRemote(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => e2.includes(t3.attributes.mid || ""));
          if (t2.length !== e2.length)
            throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
          t2.forEach((e3) => {
            e3.attributes.direction = "recvonly";
          });
        }
        receive(e2, t2, i2, n2) {
          e2.forEach((e3, r2) => {
            this.createOrRecycleRecvMedia(e3, [], "recvonly", t2, i2, n2[r2]);
          }), this.updateBundleMids();
        }
        stopReceiving(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => -1 !== e2.indexOf(t3.attributes.mid));
          if (t2.length !== e2.length)
            throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
          t2.forEach((e3) => {
            e3.media.port = "0", e3.attributes.direction = "inactive";
          }), this.updateBundleMids();
        }
        updateCandidates(e2) {
          e2 === OS.TCP ? this._candidates.forEach((e3) => {
            -1 === this._candidates.findIndex((t2) => "tcp" === t2.transport && t2.connectionAddress === e3.connectionAddress && t2.port === e3.port) && this._candidates.push(DN(DN({}, e3), {}, { foundation: "tcpcandidate", priority: Number(e3.priority) - 1 + "", transport: "tcp", port: Number(e3.port) + 90 + "" }));
          }) : this._candidates = this._candidates.filter((e3) => "tcp" !== e3.transport);
          for (const e3 of this.sessionDesc.mediaDescriptions)
            e3.attributes.candidates = this.candidates;
        }
        restartICE(e2) {
          e2 = uC(e2), this._iceParameters = e2, this.sessionDesc.mediaDescriptions.forEach((t2) => {
            t2.attributes.iceUfrag = e2.iceUfrag, t2.attributes.icePwd = e2.icePwd;
          });
        }
        predictReceivingMids(e2) {
          const t2 = [];
          for (let i2 = 0; i2 < e2; i2++)
            t2.push((this.currentMidIndex + i2 + 1).toString(10));
          return t2;
        }
        findAvailableMediaIndex(e2, t2) {
          return this.sessionDesc.mediaDescriptions.findIndex((i2) => {
            const n2 = i2.media.mediaType === e2 && "0" !== i2.media.port && ("sendonly" === i2.attributes.direction || "sendrecv" === i2.attributes.direction) && 0 === i2.attributes.ssrcs.length;
            if (Kh()) {
              if (n2) {
                const e3 = this.firefoxSsrcMidMap.get(t2[0].ssrcId);
                return !(e3 || "0" !== i2.attributes.mid && "1" !== i2.attributes.mid) || !(!e3 || e3 !== i2.attributes.mid);
              }
              return false;
            }
            return n2;
          });
        }
        createOrRecycleRecvMedia(e2, t2, i2, n2, r2, o2) {
          const s2 = e2._mediaStreamTrack.kind, a2 = this.rtpCapabilities.recv, c2 = this.localCapabilities.send;
          let d2 = [];
          if (s2 === AS.VIDEO) {
            var u2, l2;
            if (GE("H264_PROFILE_LEVEL_ID") && "h264" === n2 && (d2 = a2.videoCodecs.filter((e3) => {
              var t3, i3;
              return ((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "").includes(n2) && (null == e3 || null === (i3 = e3.fmtp) || void 0 === i3 ? void 0 : i3.parameters["profile-level-id"]) === GE("H264_PROFILE_LEVEL_ID");
            })), !d2 || 0 === (null === (u2 = d2) || void 0 === u2 ? void 0 : u2.length)) {
              const e3 = c2.videoCodecs.filter((e4) => {
                var t3;
                return ((null === (t3 = e4.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "").includes(n2);
              });
              0 !== e3.length && (d2 = a2.videoCodecs.filter((t3) => e3.some((e4) => e4.payloadType === t3.payloadType)));
            }
            if (GE("USE_PUB_RTX")) {
              const e3 = d2.map((e4) => e4.payloadType.toString()), t3 = a2.videoCodecs.filter((t4) => {
                var i3, n3;
                return "rtx" === (null === (i3 = t4.rtpMap) || void 0 === i3 ? void 0 : i3.encodingName) && e3.includes((null === (n3 = t4.fmtp) || void 0 === n3 ? void 0 : n3.parameters.apt) || "");
              });
              d2 = [...d2, ...t3];
            }
            if (0 === d2.length)
              OE.warning("codec ".concat(n2, " not included in rtpCapabilities, fallback to default payloads: ").concat(null === (l2 = a2.videoCodecs[0].rtpMap) || void 0 === l2 ? void 0 : l2.encodingName)), d2 = a2.videoCodecs;
          } else
            d2 = a2.audioCodecs.filter((e3) => {
              var t3;
              return ((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "").includes(r2);
            }), 0 === d2.length && (OE.warning("codec ".concat(r2, " not included in rtpCapabilities, fallback to opus")), d2 = a2.audioCodecs.filter((e3) => {
              var t3;
              return ((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "").includes("opus");
            }));
          const h2 = s2 === AS.VIDEO ? a2.videoExtensions : a2.audioExtensions;
          this.currentMidIndex += 1;
          const p2 = "".concat(this.currentMidIndex);
          let _2 = { media: { mediaType: s2, port: PN, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: d2.map((e3) => e3.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: h2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: d2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i2, rtcpMux: true, rtcpRsize: true, mid: "".concat(p2) } };
          _2 = this.mungRecvMediaDsec(_2, e2, o2);
          const E2 = this.findFirstClosedMedia(s2);
          if (E2) {
            const e3 = this.sessionDesc.mediaDescriptions.indexOf(E2);
            this.sessionDesc.mediaDescriptions[e3] = _2;
          } else
            this.sessionDesc.mediaDescriptions.push(_2);
          return _2;
        }
        createOrRecycleSendMedia(e2, t2, i2, n2, r2) {
          const o2 = this.rtpCapabilities.send, s2 = e2 === AS.VIDEO ? o2.videoCodecs : o2.audioCodecs, a2 = e2 === AS.VIDEO ? o2.videoExtensions : o2.audioExtensions;
          this.currentMidIndex += 1;
          const c2 = "".concat(this.currentMidIndex);
          let d2 = { media: { mediaType: e2, port: PN, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: s2.map((e3) => e3.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: a2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: i2, rtcpFeedbackWildcards: [], payloads: s2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: n2, rtcpMux: true, rtcpRsize: true, mid: "".concat(c2) } };
          d2 = this.mungSendMediaDesc(d2, r2);
          const u2 = this.findFirstClosedMedia(e2);
          if (u2) {
            const e3 = this.sessionDesc.mediaDescriptions.indexOf(u2);
            this.sessionDesc.mediaDescriptions[e3] = d2;
          } else
            this.sessionDesc.mediaDescriptions.push(d2);
          return d2;
        }
        updateBundleMids() {
          this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter((e2) => "0" !== e2.media.port).map((e2) => e2.attributes.mid);
        }
        mungRecvMediaDsec(e2, t2, i2) {
          const n2 = uC(e2);
          return KO(n2), HO(n2, t2), YO(n2, t2), qO(n2), JO(n2, i2, this.localCapabilities.send), n2;
        }
        mungSendMediaDesc(e2, t2) {
          const i2 = uC(e2);
          return JO(i2, t2, this.localCapabilities.recv), $O(i2), i2;
        }
        updateRecvMedia(e2, t2) {
          const i2 = this.sessionDesc.mediaDescriptions.findIndex((t3) => t3.attributes.mid === e2);
          if (-1 !== i2) {
            const e3 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i2], t2);
            this.sessionDesc.mediaDescriptions[i2] = e3;
          }
        }
        bumpMid(e2) {
          this.currentMidIndex += e2;
        }
        findFirstClosedMedia(e2) {
          return this.sessionDesc.mediaDescriptions.find((t2) => Kh() ? "0" === t2.media.port && t2.media.mediaType === e2 : "0" === t2.media.port);
        }
        findPreloadMediaDesc(e2) {
          return this.sessionDesc.mediaDescriptions.find((t2) => {
            var i2, n2;
            return (null === (i2 = t2.attributes) || void 0 === i2 || null === (n2 = i2.ssrcs[0]) || void 0 === n2 ? void 0 : n2.ssrcId) === e2[0].ssrcId;
          });
        }
        getSSRC(e2) {
          var t2;
          return null === (t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2)) || void 0 === t2 ? void 0 : t2.attributes.ssrcs;
        }
      }
      var MN;
      function UN(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function xN(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? UN(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : UN(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      let VN = (ag((MN = class e2 extends YS {
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        get dtlsTransportState() {
          var e3, t2, i2;
          return null !== (e3 = null === (t2 = this.peerConnection.getReceivers()[0]) || void 0 === t2 || null === (i2 = t2.transport) || void 0 === i2 ? void 0 : i2.state) && void 0 !== e3 ? e3 : null;
        }
        constructor(t2, i2) {
          super(t2, i2), _p(this, "store", void 0), _p(this, "peerConnection", void 0), _p(this, "remoteSDP", void 0), _p(this, "initialOffer", void 0), _p(this, "transportEventReceiver", void 0), _p(this, "statsFilter", void 0), _p(this, "localCapabilities", void 0), _p(this, "localCandidateCount", 0), _p(this, "allCandidatesReceived", false), _p(this, "selectedCandidatePairTimer", void 0), _p(this, "establishPromise", void 0), _p(this, "mutex", new Ug("P2PConnection-mutex")), this.store = i2, this.peerConnection = new RTCPeerConnection(e2.resolvePCConfiguration(t2), { optional: [{ googDscp: true }] }), this.statsFilter = vN(this.peerConnection, GE("STATS_UPDATE_INTERVAL"), void 0, Kh() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();
        }
        async establish() {
          try {
            this.peerConnection.addTransceiver("video", { direction: "recvonly" }), this.peerConnection.addTransceiver("audio", { direction: "recvonly" });
            const e3 = await this.peerConnection.createOffer();
            if (!e3.sdp)
              throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
            const t2 = FO(e3.sdp), i2 = await zO(!GE("USE_PUB_RTX") && !GE("USE_SUB_RTX"), GE("FILTER_VIDEO_FEC"), GE("FILTER_AUDIO_FEC"));
            return this.localCapabilities = ZO(i2), this.initialOffer = e3, xN(xN({}, t2), {}, { rtpCapabilities: i2, offerSDP: e3.sdp });
          } catch (e3) {
            throw new SE(fE.GET_LOCAL_CONNECTION_PARAMS_FAILED, e3.toString());
          }
        }
        async connect(e3, t2, i2, n2, r2, o2) {
          try {
            if (!this.initialOffer)
              throw new Error("Cannot establish P2PConnection without initial offer.");
            this.remoteSDP = new kN({ remoteIceParameters: e3, remoteDtlsParameters: t2, candidates: i2, remoteRTPCapabilities: n2, remoteSetup: r2, localCapabilities: this.localCapabilities, cname: o2 });
            const s2 = this.remoteSDP.toString(), a2 = UO.exports.parse(this.initialOffer.sdp), c2 = a2.mediaDescriptions.find((e4) => "audio" === e4.media.mediaType);
            c2 && $O(c2);
            const d2 = UO.exports.print(a2), u2 = this.logSDPExchange(d2 || "", "offer", "local", "connect");
            this.store.descriptionStart(), await this.peerConnection.setLocalDescription({ type: "offer", sdp: d2 }), null == u2 || u2(s2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: s2 });
            const l2 = this.peerConnection.getTransceivers()[0];
            if (null != l2 && l2.receiver && this.tryBindTransportEvents(l2.receiver), GE("PRELOAD_MEDIA_COUNT") > 0) {
              this.remoteSDP.preloadRemoteMedia();
              const e4 = this.remoteSDP.toString();
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e4 });
              const t3 = await this.peerConnection.createAnswer();
              await this.peerConnection.setLocalDescription(t3);
            }
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e4.toString()));
          }
        }
        send(e3, t2, i2) {
          var n2 = this;
          return DO(function* () {
            const r2 = yield PO(n2.mutex.lock("From P2PConnection.send"));
            try {
              if (!n2.remoteSDP)
                throw new Error("Cannot call P2PConnection.send before remote SDP created");
              const o2 = [];
              e3.forEach((e4) => {
                const t3 = n2.peerConnection.addTransceiver(e4._mediaStreamTrack, { direction: "sendonly" });
                o2.push(t3), e4._updateRtpTransceiver(t3);
              }), Kh() && true === GE("SIMULCAST") && (yield PO(n2.applySimulcastForFirefox(o2, e3)));
              const s2 = yield PO(n2.peerConnection.createOffer()), a2 = n2.remoteSDP.predictReceivingMids(e3.length), c2 = n2.mungSendOfferSDP(s2.sdp, e3, a2), d2 = UO.exports.parse(c2), u2 = a2.map((e4) => {
                const t3 = d2.mediaDescriptions.find((t4) => t4.attributes.mid === e4);
                if (!t3)
                  throw new Error("Cannot extract ssrc from mediaDescription.");
                return BO(t3, GE("USE_PUB_RTX"));
              });
              let l2;
              try {
                l2 = yield u2;
              } catch (r3) {
                l2 = [], n2.remoteSDP.receive(e3, t2, i2, l2);
                const o3 = n2.remoteSDP.toString();
                throw yield PO(n2.peerConnection.setLocalDescription({ type: "offer", sdp: c2 })), yield PO(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: o3 })), yield PO(n2.stopSending(a2, true)), r3;
              }
              n2.remoteSDP.receive(e3, t2, i2, l2);
              const h2 = n2.remoteSDP.toString(), p2 = n2.logSDPExchange(c2, "offer", "local", "send");
              return yield PO(n2.peerConnection.setLocalDescription({ type: "offer", sdp: c2 })), yield PO(n2.applySimulcastEncodings(o2, e3)), yield PO(n2.applySendEncodings(o2, e3)), null == p2 || p2(h2), yield PO(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: h2 })), o2.map((e4, t3) => {
                const i3 = a2[t3];
                return { localSSRC: u2[t3], id: i3, transceiver: e4 };
              });
            } catch (e4) {
              throw e4 instanceof SE ? e4 : new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e4.toString()));
            } finally {
              r2();
            }
          })();
        }
        async stopSending(e3, t2) {
          const i2 = t2 ? void 0 : await this.mutex.lock("From P2PConnection.stopSending");
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
            const t3 = this.peerConnection.getTransceivers().filter((t4) => -1 !== e3.indexOf(t4.mid));
            if (t3.length !== e3.length)
              throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
            t3.map((e4) => {
              var t4;
              e4.direction = "inactive", null === (t4 = e4.stop) || void 0 === t4 || t4.call(e4);
            });
            const n2 = await this.peerConnection.createOffer(), r2 = this.logSDPExchange(n2.sdp || "", "offer", "local", "stopSending");
            await this.peerConnection.setLocalDescription(n2), this.remoteSDP.stopReceiving(e3);
            const o2 = this.remoteSDP.toString();
            null == r2 || r2(o2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o2 });
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e4.toString()));
          } finally {
            i2 && i2();
          }
        }
        async receive(e3, t2, i2, n2) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.receive ".concat(e3, " before remoteSDP created."));
            const { mid: r2, needExchangeSDP: o2 } = this.remoteSDP.send(e3, t2, i2, n2);
            if (o2) {
              const t3 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t3, "offer", "remote", "receive");
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t3 });
              const n3 = await this.peerConnection.createAnswer(), o3 = this.mungReceiveAnswerSDP(n3.sdp, r2, e3);
              null == i3 || i3(o3 || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: o3 }), OE.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " by exchanging SDP."));
            } else
              OE.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " no need to exchange SDP."));
            const s2 = this.peerConnection.getTransceivers().find((e4) => e4.mid === r2);
            if (!s2)
              throw new Error("Cannot get transceiver after setLocalDescription.");
            return { track: s2.receiver.track, id: r2, transceiver: s2 };
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async batchReceive(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
            const { mids: t2, needExchangeSDP: i2 } = this.remoteSDP.batchSend(e3);
            if (i2) {
              const e4 = this.remoteSDP.toString(), t3 = this.logSDPExchange(e4, "offer", "remote", "receive");
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e4 });
              const i3 = await this.peerConnection.createAnswer();
              null == t3 || t3(i3.sdp || ""), await this.peerConnection.setLocalDescription(i3), OE.debug("[".concat(this.store.clientId, "] [P2PConnection] batchReceive by exchanging SDP."));
            } else
              OE.debug("[".concat(this.store.clientId, "] [P2PConnection] batchReceive no need to exchange SDP."));
            return t2.map((e4) => {
              const t3 = this.peerConnection.getTransceivers().find((t4) => t4.mid === e4);
              if (!t3)
                throw new Error("Cannot get transceiver after setLocalDescription.");
              return { track: t3.receiver.track, id: e4, transceiver: t3 };
            });
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async stopReceiving(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
            this.remoteSDP.stopSending(e3);
            const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "stopReceiving");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e4.toString()));
          }
        }
        async muteRemote(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.muteRemote mid=".concat(e3, " before remote SDP created."));
            this.remoteSDP.mute(e3);
            const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "muteRemote");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.muteRemote failed; ".concat(e4.toString()));
          }
        }
        async unmuteRemote(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.unmuteRemote mid=".concat(e3, " before remote SDP created."));
            this.remoteSDP.unmute(e3);
            const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "unmuteRemote");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteRemote failed; ".concat(e4.toString()));
          }
        }
        async muteLocal(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
            const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e3.indexOf(t3.mid));
            if (t2.length !== e3.length)
              throw new Error("Transceivers' length doesn't match mids' length.");
            t2.map((e4) => {
              e4.direction = "inactive";
            });
            const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "muteLocal");
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.muteRemote(e3);
            const r2 = this.remoteSDP.toString();
            null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e4.toString()));
          }
        }
        async unmuteLocal(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
            const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e3.indexOf(t3.mid));
            if (t2.length !== e3.length)
              throw new Error("Transceivers' length doesn't match mids' length.");
            t2.map(async (e4, t3) => {
              e4.direction = "sendonly";
            });
            const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "unmuteLocal");
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.unmuteRemote(e3);
            const r2 = this.remoteSDP.toString();
            null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e4.toString()));
          }
        }
        restartICE(e3) {
          var t2 = this;
          return DO(function* () {
            const i2 = yield PO(t2.mutex.lock("From P2PConnection.restartICE"));
            try {
              if (!t2.remoteSDP)
                throw new Error("Cannot restartICE before remoteSDP created.");
              if (JS().supportPCSetConfiguration) {
                const i3 = t2.peerConnection.getConfiguration(), n3 = e3 === OS.RELAY ? "relay" : "all";
                i3.iceTransportPolicy !== n3 && (OE.debug("[".concat(t2.store.clientId, "] restartICE change iceTransportPolicy from [").concat(i3.iceTransportPolicy, "] to [").concat(n3, "]")), i3.iceTransportPolicy = n3, t2.peerConnection.setConfiguration(i3));
              } else if (e3 === OS.RELAY)
                return;
              e3 !== OS.RELAY && t2.remoteSDP.updateCandidates(e3);
              const n2 = yield PO(t2.peerConnection.createOffer({ iceRestart: true }));
              if (!n2.sdp)
                throw new Error("Cannot restartICE because restart offer SDP does not exist.");
              const r2 = FO(n2.sdp), { remoteIceParameters: o2 } = yield r2.iceParameters;
              t2.remoteSDP.restartICE(o2);
              const s2 = t2.remoteSDP.toString(), a2 = t2.logSDPExchange(n2.sdp || "", "offer", "local", "restartICE");
              t2.store.descriptionStart(), yield PO(t2.peerConnection.setLocalDescription(n2)), null == a2 || a2(s2), yield PO(t2.peerConnection.setRemoteDescription({ type: "answer", sdp: s2 }));
            } catch (e4) {
              OE.warning("[".concat(t2.store.clientId, "] restart ICE failed, abort operation"), e4);
            } finally {
              i2();
            }
          })();
        }
        close() {
          var e3;
          this.peerConnection.close(), null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, "closed"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy();
        }
        getStats() {
          return this.statsFilter.getStats();
        }
        getRemoteVideoIsReady(e3) {
          return this.statsFilter.getVideoIsReady(e3);
        }
        async updateEncoderConfig(e3, t2) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
            const i2 = await this.peerConnection.createOffer(), n2 = this.mungSendOfferSDP(i2.sdp, [t2], [e3]);
            this.remoteSDP.updateRecvMedia(e3, t2);
            const r2 = this.remoteSDP.toString(), o2 = this.logSDPExchange(n2, "offer", "local", "updateEncoderConfig");
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: n2 }), null == o2 || o2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, e4.toString());
          }
        }
        async updateSendParameters(e3, t2) {
          const i2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid === e3);
          1 === i2.length && (this.isVP8Simulcast(t2) ? Kh() || await this.applySimulcastEncodings(i2, [t2]) : await this.applySendEncodings(i2, [t2]));
        }
        setStatsRemoteVideoIsReady(e3, t2) {
          this.statsFilter.setVideoIsReady2(e3, t2);
        }
        async replaceTrack(e3, t2) {
          const i2 = this.peerConnection.getTransceivers().find((e4) => e4.mid === t2);
          i2 && await i2.sender.replaceTrack(e3._mediaStreamTrack);
        }
        async getSelectedCandidatePair() {
          const e3 = this.peerConnection.getReceivers();
          if (e3.length > 0 && e3[0].transport && e3[0].transport.iceTransport && e3[0].transport.iceTransport.getSelectedCandidatePair && e3[0].transport.iceTransport.getSelectedCandidatePair()) {
            const t2 = e3[0].transport.iceTransport, { local: i2, remote: n2 } = t2.getSelectedCandidatePair();
            return { local: xN(xN({}, cN), {}, { candidateType: i2.type, protocol: i2.protocol, address: i2.address, port: i2.port }), remote: xN(xN({}, cN), {}, { candidateType: n2.type, protocol: n2.protocol, address: n2.address, port: n2.port }) };
          }
          return this.statsFilter.getSelectedCandidatePair();
        }
        bindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = () => {
            var e3;
            null === (e3 = this.onICEConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.iceConnectionState);
          }, this.peerConnection.onconnectionstatechange = () => {
            var e3;
            null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.connectionState);
          }, this.peerConnection.onicecandidate = (e3) => {
            e3.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, OE.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
          }, setTimeout(() => {
            this.allCandidatesReceived || (this.allCandidatesReceived = true, OE.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
          }, GE("CANDIDATE_TIMEOUT"));
        }
        unbindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
        }
        static resolvePCConfiguration(t2) {
          const i2 = { iceServers: [] };
          return t2.iceServers ? i2.iceServers = t2.iceServers : t2.turnServer && "off" !== t2.turnServer.mode && (Uf(t2.turnServer.servers) ? i2.iceServers = t2.turnServer.servers : (i2.iceServers && i2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.servers)), GE("USE_TURN_SERVER_OF_GATEWAY") && i2.iceServers && t2.turnServer.serversFromGateway && i2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.serversFromGateway)), GE("FORCE_TURN_TCP") ? i2.iceTransportPolicy = "relay" : t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach((e3) => {
            e3.forceturn && (i2.iceTransportPolicy = "relay");
          }))), GE("ENABLE_ENCODED_TRANSFORM") && JS().supportWebRTCEncodedTransform && (i2.encodedInsertableStreams = true), i2;
        }
        static turnServerConfigToIceServers(e3) {
          const t2 = [];
          return e3.forEach((e4) => {
            e4.security ? e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(VI(e4.turnServerURL), ":").concat(e4.tcpport, "?transport=tcp") }) : (e4.udpport && !GE("FORCE_TURN_TCP") && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.udpport, "?transport=udp") }), e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }));
          }), t2;
        }
        tryBindTransportEvents(e3) {
          const t2 = e3.transport;
          if (t2) {
            this.transportEventReceiver = e3, t2.onstatechange = () => {
              var e4;
              null != t2 && t2.state && (null === (e4 = this.onDTLSTransportStateChange) || void 0 === e4 || e4.call(this, t2.state));
            }, t2.onerror = (e4) => {
              var t3;
              null === (t3 = this.onDTLSTransportError) || void 0 === t3 || t3.call(this, "error" in e4 ? e4.error : e4);
            };
            const i2 = t2.iceTransport;
            i2 && (i2.onstatechange = () => {
              const e4 = null == t2 ? void 0 : t2.iceTransport.state;
              var i3;
              e4 && (null === (i3 = this.onICETransportStateChange) || void 0 === i3 || i3.call(this, e4));
            }, i2.getSelectedCandidatePair && (i2.onselectedcandidatepairchange = () => {
              if (i2.getSelectedCandidatePair()) {
                const { local: e4, remote: t3 } = i2.getSelectedCandidatePair();
                OE.info("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] selectedcandidatepairchange: local ").concat(JSON.stringify({ candidateType: e4.type, protocol: e4.protocol }), ", remote ").concat(JSON.stringify({ candidateType: t3.type, protocol: t3.protocol, address: t3.address, port: t3.port }), " )"));
              }
            }));
          }
        }
        tryUnbindTransportEvents() {
          this.transportEventReceiver && this.transportEventReceiver.transport && (this.transportEventReceiver.transport.onstatechange = null, this.transportEventReceiver.transport.onerror = null, this.transportEventReceiver.transport.iceTransport && (this.transportEventReceiver.transport.iceTransport.onstatechange = null));
        }
        async applySendEncodings(e3, t2) {
          try {
            if (!JS().supportSetRtpSenderParameters)
              return;
            if (e3.length !== t2.length)
              return;
            for (let c2 = 0; c2 < e3.length; c2++) {
              const d2 = e3[c2], u2 = t2[c2];
              if (u2 && u2 instanceof Cy) {
                var i2, n2;
                if (this.isVP8Simulcast(u2))
                  continue;
                const e4 = {}, t3 = {};
                switch (u2._optimizationMode) {
                  case "motion":
                    e4.degradationPreference = "maintain-framerate";
                    break;
                  case "detail":
                    e4.degradationPreference = "maintain-resolution";
                    break;
                  default:
                    e4.degradationPreference = "balanced";
                }
                var r2, o2, s2, a2;
                if (null !== (i2 = u2._encoderConfig) && void 0 !== i2 && i2.bitrateMax)
                  t3.maxBitrate = 1e3 * (null === (r2 = u2._encoderConfig) || void 0 === r2 ? void 0 : r2.bitrateMax);
                if (u2._hints.includes(lS.LOW_STREAM))
                  null !== (o2 = u2._encoderConfig) && void 0 !== o2 && o2.frameRate && (t3.maxFramerate = FI(u2._encoderConfig.frameRate)), null !== (s2 = u2._encoderConfig) && void 0 !== s2 && s2.scaleResolutionDownBy && (null === (a2 = u2._encoderConfig) || void 0 === a2 ? void 0 : a2.scaleResolutionDownBy) > 1 && (t3.scaleResolutionDownBy = u2._encoderConfig.scaleResolutionDownBy);
                if (GE("DSCP_TYPE") && rp()) {
                  const e5 = GE("DSCP_TYPE");
                  ["very-low", "low", "medium", "high"].includes(e5) && (t3.networkPriority = e5);
                }
                const c3 = d2.sender.getParameters(), l2 = null === (n2 = c3.encodings) || void 0 === n2 ? void 0 : n2[0];
                Kh() && !l2 && (e4.encodings = [t3]), l2 && Object.assign(l2, t3), Object.assign(c3, e4), await d2.sender.setParameters(c3);
              }
            }
          } catch (e4) {
            OE.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
          }
        }
        mungSendOfferSDP(e3, t2, i2) {
          const n2 = UO.exports.parse(e3);
          return t2.forEach((e4, t3) => {
            const r2 = i2[t3], o2 = n2.mediaDescriptions.find((e5) => e5.attributes.mid === r2);
            o2 && (HO(o2, e4), XO(o2, e4, this.store.codec));
          }), UO.exports.print(n2);
        }
        mungReceiveAnswerSDP(e3, t2, i2) {
          const n2 = UO.exports.parse(e3), r2 = n2.mediaDescriptions.find((e4) => e4.attributes.mid === t2);
          return r2 && i2 === AS.AUDIO && "audio" === r2.media.mediaType && $O(r2), UO.exports.print(n2);
        }
        bindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = (e3) => {
            var t2;
            null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoReceived = (e3) => {
            var t2;
            null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstAudioDecoded = (e3) => {
            var t2;
            null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoDecoded = (e3, t2, i2) => {
            var n2;
            null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e3, t2, i2);
          }, this.statsFilter.onSelectedLocalCandidateChanged = (e3, t2) => {
            var i2;
            null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 || i2.call(this, e3, t2);
          }, this.statsFilter.onSelectedRemoteCandidateChanged = (e3, t2) => {
            var i2;
            null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 || i2.call(this, e3, t2);
          }, this.statsFilter.onFirstVideoDecodedTimeout = (e3) => {
            var t2;
            null === (t2 = this.onFirstVideoDecodedTimeout) || void 0 === t2 || t2.call(this, e3);
          };
        }
        unbindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
        }
        async applySimulcastForFirefox(e3, t2) {
          if (e3.length === t2.length)
            for (let s2 = 0; s2 < e3.length; s2++) {
              var i2, n2, r2, o2;
              const a2 = e3[s2], c2 = t2[s2];
              if (c2 instanceof Cy && !c2._hints.includes(lS.LOW_STREAM) && null !== (i2 = c2._encoderConfig) && void 0 !== i2 && i2.bitrateMax && (null === (n2 = c2._encoderConfig) || void 0 === n2 ? void 0 : n2.bitrateMax) > 200 && null !== (r2 = c2._scalabiltyMode) && void 0 !== r2 && r2.numSpatialLayers && (null === (o2 = c2._scalabiltyMode) || void 0 === o2 ? void 0 : o2.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
                const e4 = {}, t3 = { high: 1e3 * (c2._encoderConfig.bitrateMax - 50), medium: 5e4 };
                e4.encodings = [{ rid: "m", active: true, maxBitrate: t3.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: t3.high }];
                const i3 = a2.sender.getParameters();
                await a2.sender.setParameters(Object.assign(i3, e4));
              }
            }
        }
        async applySimulcastEncodings(e3, t2) {
          if (!Kh() && e3.length === t2.length)
            for (let i2 = 0; i2 < e3.length; i2++) {
              const n2 = t2[i2];
              if (n2 instanceof Cy && this.isVP8Simulcast(n2)) {
                const t3 = e3[i2], r2 = {}, o2 = { high: 1e3 * (n2._encoderConfig.bitrateMax - 50), medium: 5e4 };
                r2.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: o2.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: o2.medium, scaleResolutionDownBy: 4 }];
                const s2 = t3.sender.getParameters();
                await t3.sender.setParameters(Object.assign(s2, r2));
              }
            }
        }
        isVP8Simulcast(e3) {
          var t2, i2, n2, r2;
          return !!(e3 instanceof Cy && GE("SIMULCAST") && "vp8" === this.store.codec && !e3._hints.includes(lS.LOW_STREAM) && null !== (t2 = e3._encoderConfig) && void 0 !== t2 && t2.bitrateMax && (null === (i2 = e3._encoderConfig) || void 0 === i2 ? void 0 : i2.bitrateMax) > 200 && null !== (n2 = e3._scalabiltyMode) && void 0 !== n2 && n2.numSpatialLayers && (null === (r2 = e3._scalabiltyMode) || void 0 === r2 ? void 0 : r2.numSpatialLayers) > 1);
        }
        logSDPExchange(e3, t2, i2, n2) {
          if (GE("SDP_LOGGING"))
            return OE.upload("[".concat(this.store.clientId, "] exchanging ").concat(i2, " ").concat(t2, " SDP during P2PConnection.").concat(n2, "\n"), e3), "offer" === t2 ? (e4) => {
              this.logSDPExchange(e4, "answer", "local" === i2 ? "remote" : "local", n2);
            } : void 0;
        }
        async getRemoteSSRC(e3) {
          if (!this.remoteSDP)
            return;
          const t2 = this.remoteSDP.getSSRC(e3);
          return null == t2 ? void 0 : t2[0].ssrcId;
        }
        setConfiguration(t2) {
          if (JS().supportPCSetConfiguration) {
            const i2 = e2.resolvePCConfiguration(t2);
            this.peerConnection.setConfiguration(i2);
          }
        }
      }).prototype, "connect", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "connect"), MN.prototype), ag(MN.prototype, "receive", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "receive"), MN.prototype), ag(MN.prototype, "batchReceive", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "batchReceive"), MN.prototype), ag(MN.prototype, "stopReceiving", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "stopReceiving"), MN.prototype), ag(MN.prototype, "muteRemote", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "muteRemote"), MN.prototype), ag(MN.prototype, "unmuteRemote", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "unmuteRemote"), MN.prototype), ag(MN.prototype, "muteLocal", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "muteLocal"), MN.prototype), ag(MN.prototype, "unmuteLocal", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "unmuteLocal"), MN.prototype), ag(MN.prototype, "close", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "close"), MN.prototype), ag(MN.prototype, "updateEncoderConfig", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "updateEncoderConfig"), MN.prototype), ag(MN.prototype, "updateSendParameters", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "updateSendParameters"), MN.prototype), ag(MN.prototype, "replaceTrack", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "replaceTrack"), MN.prototype), ag(MN.prototype, "getRemoteSSRC", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "getRemoteSSRC"), MN.prototype), MN);
      function jN(e2, t2, i2) {
        const n2 = e2[t2];
        if ("function" != typeof n2)
          throw new Error("Cannot use mutex on object property.");
        return i2.value = async function() {
          const e3 = this.mutex, i3 = await e3.lock("From P2PConnection.".concat(t2));
          try {
            for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++)
              o2[s2] = arguments[s2];
            return await n2.apply(this, o2);
          } finally {
            i3();
          }
        }, i2;
      }
      function FN(e2, t2) {
        let i2 = document.createElement("video"), n2 = document.createElement("canvas");
        i2.setAttribute("style", "display:none"), n2.setAttribute("style", "display:none"), i2.setAttribute("muted", ""), i2.muted = true, i2.setAttribute("autoplay", ""), i2.autoplay = true, i2.setAttribute("playsinline", ""), n2.width = FI(t2.width), n2.height = FI(t2.height);
        const r2 = FI(t2.framerate || 15);
        document.body.append(i2), document.body.append(n2);
        let o2 = e2._mediaStreamTrack;
        i2.srcObject = new MediaStream([o2]), i2.play();
        const s2 = n2.getContext("2d");
        if (!s2)
          throw new SE(fE.UNEXPECTED_ERROR, "can not get canvas context");
        const a2 = JS(), c2 = n2.captureStream(a2.supportRequestFrame ? 0 : r2).getVideoTracks()[0], d2 = Jg(() => (() => {
          if (i2.paused && i2.play(), i2.videoHeight > 2 && i2.videoWidth > 2) {
            const e3 = i2.videoWidth, t3 = i2.videoHeight / e3, r3 = n2.width * t3;
            Math.abs(r3 - n2.height) >= 2 && (OE.debug("adjust low stream resolution", "".concat(n2.width, "x").concat(n2.height, " -> ").concat(n2.width, "x").concat(r3)), n2.height = r3);
          }
          s2.drawImage(i2, 0, 0, n2.width, n2.height), c2.requestFrame && c2.requestFrame(), o2 !== e2._mediaStreamTrack && (o2 = e2._mediaStreamTrack, i2.srcObject = new MediaStream([o2]));
        })(), r2), u2 = c2.stop;
        return c2.stop = () => {
          u2.call(c2), d2(), i2 && (i2.remove(), i2 = null), n2 && (n2.width = 0, n2.remove(), n2 = null), OE.debug("clean low stream renderer");
        }, c2;
      }
      var BN, GN, WN, HN, KN, YN, qN, JN, XN, zN, QN, ZN;
      function $N(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function eb(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? $N(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : $N(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class tb extends Lg {
        getUserId() {
          return this._userId;
        }
        constructor(e2, t2, i2, n2) {
          super(e2, "track-".concat(e2.kind, "-").concat(t2, "-").concat(n2.clientId, "_").concat(ZI(5, ""))), _p(this, "_userId", void 0), _p(this, "_uintId", void 0), _p(this, "_isDestroyed", false), _p(this, "store", void 0), _p(this, "processor", void 0), _p(this, "processorContext", void 0), this._userId = t2, this._uintId = i2, this.store = n2;
        }
        _updateOriginMediaStreamTrack(e2) {
          this._originMediaStreamTrack = e2, this._mediaStreamTrack = e2, this._updatePlayerSource(), this.processor && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext });
        }
        _destroy() {
          this._isDestroyed = true, OE.info("[".concat(this.getTrackId(), "] is destroyed")), this.stop(), super.close();
        }
        getProcessorStats() {
          return this.processorContext.gatherStats();
        }
        getProcessorUsage() {
          return this.processorContext.gatherUsage();
        }
      }
      let ib = (BN = Dg({ argsMap: (e2, t2, i2) => [e2.getTrackId(), "string" == typeof t2 ? t2 : t2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement", i2] }), GN = Dg({ argsMap: (e2) => [e2.getTrackId()] }), WN = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), HN = Dg({ argsMap: (e2) => [e2.getTrackId()] }), ag((KN = class extends tb {
        get isPlaying() {
          return !(!this._player || this._player.videoElementStatus !== sf.PLAYING);
        }
        get __className__() {
          return "RemoteVideoTrack";
        }
        constructor(e2, t2, i2, n2) {
          super(e2, t2, i2, n2), _p(this, "_videoVisibleTimer", null), _p(this, "_previousVideoVisibleStatus", void 0), _p(this, "_clearPreviousVideoVisibleStatus", () => this._previousVideoVisibleStatus = void 0), _p(this, "trackMediaType", "video"), _p(this, "_videoWidth", void 0), _p(this, "_videoHeight", void 0), _p(this, "_player", void 0), _p(this, "processorDestination", void 0), _p(this, "processorContext", void 0), this.updateMediaStreamTrackResolution(), this.processorContext = new AR(this.getTrackId(), "remote"), this.processorDestination = new yR(this.processorContext), this.bindProcessorDestinationEvents();
        }
        getStats() {
          hC(() => {
            OE.warning("[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead");
          }, "remoteVideoTrackGetStatsWarning");
          return oC(this, uS.GET_STATS) || eb({}, Wf);
        }
        play(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          if ("string" == typeof e2) {
            const t3 = document.getElementById(e2);
            t3 ? e2 = t3 : (OE.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e2, '" element, use document.body')), e2 = document.body);
          }
          OE.debug("[".concat(this.getTrackId(), "] start video playback in ").concat(e2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement"), JSON.stringify(t2));
          const i2 = eb(eb({ fit: "cover" }, t2), {}, { trackId: this.getTrackId(), element: e2 });
          this._player ? this._player.updateConfig(i2) : (e2 instanceof HTMLVideoElement ? this._player = new Pv(i2) : this._player = new kv(i2), this._player.updateVideoTrack(this._mediaStreamTrack), this._player.onFirstVideoFrameDecoded = () => {
            this.store.subscribe(this.getUserId(), "video", void 0, void 0, Date.now()), this.safeEmit(fS.FIRST_FRAME_DECODED);
          }), this._player.play(this.store.sessionId || void 0), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {
            try {
              const e3 = this.getVideoElementVisibleStatus();
              this.safeEmit(fS.VIDEO_ELEMENT_VISIBLE_STATUS, e3);
            } catch (e3) {
            }
          }, GE("CHECK_VIDEO_VISIBLE_INTERVAL"));
        }
        stop() {
          this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, OE.debug("[".concat(this.getTrackId(), "] stop video playback")));
        }
        getCurrentFrameData() {
          return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);
        }
        updateMediaStreamTrackResolution() {
          tC(this._originMediaStreamTrack).then((e2) => {
            let [t2, i2] = e2;
            this._videoHeight = i2, this._videoWidth = t2;
          }).catch(eC);
        }
        _updatePlayerSource() {
          OE.debug("[".concat(this.getTrackId(), "] update player source track")), this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
        }
        getVideoElementVisibleStatus() {
          try {
            var e2, t2;
            const i2 = null == this || null === (e2 = this._player) || void 0 === e2 ? void 0 : e2.getContainerElement(), n2 = { track: this, element: null == this || null === (t2 = this._player) || void 0 === t2 ? void 0 : t2.getVideoElement(), slot: null == i2 ? void 0 : i2.parentElement }, { element: r2, slot: o2 } = n2;
            if (this.isPlaying && r2 instanceof HTMLVideoElement && o2 instanceof HTMLElement) {
              const e3 = gy.checkOneElementVisible(r2), t3 = Object.assign({}, e3);
              if (t3.visible !== this._previousVideoVisibleStatus) {
                this._previousVideoVisibleStatus = t3.visible;
                const e4 = Pg.reportApiInvoke(null, { tag: Ef.TRACER, name: _f.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] });
                t3.visible ? e4.onSuccess("Video is visible") : e4.onSuccess("Invisible because of ".concat(t3.reason));
              }
              return t3;
            }
            return;
          } catch (e3) {
            throw new SE(fE.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e3.message);
          }
        }
        pipe(e2) {
          if (this.processor === e2)
            return e2;
          if (e2._source)
            throw new SE(fE.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), e2;
        }
        unpipe() {
          if (!this.processor)
            return;
          const e2 = this.processor;
          this.processor._source = void 0, this.processor = void 0, e2.reset();
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(kS.ON_TRACK, async (e2) => {
            e2 ? e2 !== this._mediaStreamTrack && (this._mediaStreamTrack = e2, this._updatePlayerSource()) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());
          });
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(kS.ON_TRACK);
        }
        _destroy() {
          super._destroy(), this.unbindProcessorDestinationEvents();
        }
      }).prototype, "play", [BN], Object.getOwnPropertyDescriptor(KN.prototype, "play"), KN.prototype), ag(KN.prototype, "stop", [GN], Object.getOwnPropertyDescriptor(KN.prototype, "stop"), KN.prototype), ag(KN.prototype, "pipe", [WN], Object.getOwnPropertyDescriptor(KN.prototype, "pipe"), KN.prototype), ag(KN.prototype, "unpipe", [HN], Object.getOwnPropertyDescriptor(KN.prototype, "unpipe"), KN.prototype), KN), nb = (YN = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2], throttleTime: 300 }), qN = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), JN = Dg({ argsMap: (e2) => [e2.getTrackId()] }), XN = Dg({ argsMap: (e2) => [e2.getTrackId()] }), zN = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), QN = Dg({ argsMap: (e2) => [e2.getTrackId()] }), ag((ZN = class extends tb {
        get isPlaying() {
          return this._useAudioElement ? pR.isPlaying(this.getTrackId()) : this._source.isPlayed;
        }
        get __className__() {
          return "RemoteAudioTrack";
        }
        constructor(e2, t2, i2, n2) {
          super(e2, t2, i2, n2), _p(this, "trackMediaType", "audio"), _p(this, "_source", void 0), _p(this, "_useAudioElement", true), _p(this, "_volume", 100), _p(this, "processorContext", void 0), _p(this, "processorDestination", void 0), _p(this, "_played", false), _p(this, "_bypassWebAudio", false), GE("DISABLE_WEBAUDIO") ? (this._source = new bR(), this._bypassWebAudio = true, this._useAudioElement = true) : (this._source = new Qg(e2, true), GE("REMOTE_AUDIO_TRACK_USES_WEB_AUDIO") && (this._useAudioElement = false)), this._source.once(Lf.RECEIVE_TRACK_BUFFER, () => {
            this.safeEmit(fS.FIRST_FRAME_DECODED);
          }), this.processorContext = new NR(this._source.context, this.getTrackId(), "remote"), this.processorDestination = new OR(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(Lf.UPDATE_SOURCE, () => {
            this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: this.processorContext });
          });
        }
        setAudioFrameCallback(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;
          if (!e2)
            return this._source.removeAllListeners(Lf.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
          this._source.startGetAudioBuffer(t2), this._source.removeAllListeners(Lf.ON_AUDIO_BUFFER), this._source.on(Lf.ON_AUDIO_BUFFER, (t3) => e2(t3));
        }
        setVolume(e2) {
          this._volume = e2, this._useAudioElement ? pR.setVolume(this.getTrackId(), e2) : this._source.setVolume(e2 / 100);
        }
        async setPlaybackDevice(e2) {
          if (!this._useAudioElement)
            throw new SE(fE.NOT_SUPPORTED, "your browser does not support setting the audio output device");
          await pR.setSinkID(this.getTrackId(), e2);
        }
        getVolumeLevel() {
          return this._source.getAccurateVolumeLevel();
        }
        getStats() {
          hC(() => {
            OE.warning("[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead");
          }, "remoteAudioTrackGetStatsWarning");
          return oC(this, uS.GET_STATS) || eb({}, Bf);
        }
        play() {
          OE.debug("[".concat(this.getTrackId(), "] start audio playback")), this._played = true, this._useAudioElement ? (OE.debug("[".concat(this.getTrackId(), "] use audio element to play")), pR.play(this._mediaStreamTrack, this.getTrackId(), this._volume, this.store.sessionId || void 0)) : this._source.play();
        }
        stop() {
          OE.debug("[".concat(this.getTrackId(), "] stop audio playback")), this._played = false, this._useAudioElement ? pR.stop(this.getTrackId()) : this._source.stop();
        }
        _destroy() {
          super._destroy(), this._played = false, this.unbindProcessorDestinationEvents(), this._source.destroy();
        }
        _isFreeze() {
          return this._source.isFreeze;
        }
        _updatePlayerSource() {
          let e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
          OE.debug("[".concat(this.getTrackId(), "] update player source track")), e2 && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && pR.updateTrack(this.getTrackId(), this._mediaStreamTrack);
        }
        pipe(e2) {
          if (this._bypassWebAudio)
            throw new SE(fE.NOT_SUPPORTED, "can not pipe extension when WebAudio disabled");
          if (this.processor === e2)
            return e2;
          if (e2._source)
            throw new SE(fE.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), e2;
        }
        unpipe() {
          var e2;
          if (this._bypassWebAudio)
            throw new SE(fE.NOT_SUPPORTED, "can not unpipe extension when WebAudio disabled");
          if (!this.processor)
            return;
          const t2 = this.processor;
          null === (e2 = this._source.processSourceNode) || void 0 === e2 || e2.disconnect(), this.processor._source = false, this.processor = void 0, t2.reset();
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(kS.ON_TRACK, async (e2) => {
            e2 ? e2 !== this._mediaStreamTrack && (this._mediaStreamTrack = e2, this._updatePlayerSource(false), this._source.processedNode = this._source.createMediaStreamSourceNode(e2)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());
          }), this.processorDestination.on(kS.ON_NODE, (e2) => {
            this._source.processedNode = e2;
            const t2 = !e2;
            this._useAudioElement !== t2 && (this._played ? (this.stop(), this._useAudioElement = t2, this.play()) : this._useAudioElement = t2);
          });
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(kS.ON_TRACK), this.processorDestination.removeAllListeners(kS.ON_NODE);
        }
      }).prototype, "setVolume", [YN], Object.getOwnPropertyDescriptor(ZN.prototype, "setVolume"), ZN.prototype), ag(ZN.prototype, "setPlaybackDevice", [qN], Object.getOwnPropertyDescriptor(ZN.prototype, "setPlaybackDevice"), ZN.prototype), ag(ZN.prototype, "play", [JN], Object.getOwnPropertyDescriptor(ZN.prototype, "play"), ZN.prototype), ag(ZN.prototype, "stop", [XN], Object.getOwnPropertyDescriptor(ZN.prototype, "stop"), ZN.prototype), ag(ZN.prototype, "pipe", [zN], Object.getOwnPropertyDescriptor(ZN.prototype, "pipe"), ZN.prototype), ag(ZN.prototype, "unpipe", [QN], Object.getOwnPropertyDescriptor(ZN.prototype, "unpipe"), ZN.prototype), ZN);
      function rb(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function ob(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? rb(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : rb(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      class sb extends EE {
        constructor() {
          super(), _p(this, "uplinkStatsUploadInterval", void 0), _p(this, "uplinkRelatedStatsUploadInterval", void 0), _p(this, "uplinkDenoiserStatsUploadInterval", void 0), _p(this, "transportStatsUploadInterval", void 0), _p(this, "uplinkExtensionStatsUploadInterval", void 0), _p(this, "downlinkExtensionStatsUploadInterval", void 0), _p(this, "extensionUsageStatsUploadInterval", void 0), _p(this, "downlinkStatsUploadInterval", void 0), _p(this, "downlinkRelatedStatsUploadInterval", void 0), _p(this, "lastStats", void 0), _p(this, "uploadUnplinkStarted", false), _p(this, "uploadDownlinkStarted", false), _p(this, "uploadTransportStarted", false), _p(this, "uploadExtensionUsageStarted", false), _p(this, "requestStats", void 0), _p(this, "requestLocalMedia", void 0), _p(this, "requestRemoteMedia", void 0), _p(this, "requestAllTracks", void 0), _p(this, "requestVideoIsReady", void 0), _p(this, "requestUpload", void 0);
        }
        startUploadTransportStats() {
          this.uploadTransportStarted || (this.uploadTransportStarted = true, this.transportStatsUploadInterval && window.clearInterval(this.transportStatsUploadInterval), this.transportStatsUploadInterval = window.setInterval(() => {
            var e2;
            const t2 = null === (e2 = this.requestStats) || void 0 === e2 ? void 0 : e2.call(this);
            t2 && this.uploadTransportStats(t2);
          }, 1e3));
        }
        startUploadExtensionUsageStats() {
          if (this.uploadExtensionUsageStarted)
            return;
          this.uploadExtensionUsageStarted = true, this.extensionUsageStatsUploadInterval && window.clearInterval(this.extensionUsageStatsUploadInterval);
          const e2 = /* @__PURE__ */ new Map();
          this.extensionUsageStatsUploadInterval = window.setInterval(async () => {
            var t2, i2, n2;
            const r2 = Date.now(), o2 = { connectionInterval: GE("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3, details: [], lts: r2 };
            let s2 = [];
            const a2 = (null === (t2 = this.requestAllTracks) || void 0 === t2 ? void 0 : t2.call(this)) || [];
            for (const e3 of a2)
              !e3.muted && e3.enabled && (s2 = s2.concat(await e3.getProcessorUsage()));
            const c2 = (null === (i2 = this.requestRemoteMedia) || void 0 === i2 ? void 0 : i2.call(this)) || [];
            for (const [e3, t3] of c2)
              t3.has(AS.VIDEO) && e3.videoTrack && (s2 = s2.concat(await e3.videoTrack.getProcessorUsage())), t3.has(AS.AUDIO) && e3.audioTrack && (s2 = s2.concat(await e3.audioTrack.getProcessorUsage()));
            if (0 === s2.length)
              return;
            o2.details = function(e3, t3) {
              const i3 = {};
              for (const { id: s3, value: a3, level: c3, direction: d3 } of e3) {
                var n3;
                const e4 = null !== (n3 = t3.get(s3)) && void 0 !== n3 ? n3 : 0, u3 = 2 === a3 ? e4 + GE("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3 : e4;
                var r3, o3;
                t3.set(s3, u3), i3[s3] ? (2 === a3 && (i3[s3].value = a3), c3 > i3[s3].level && (i3[s3].level = c3), "remote" === d3 && (i3[s3].remoteUidCount += 1), i3[s3].totalTs = null !== (r3 = t3.get(s3)) && void 0 !== r3 ? r3 : 0) : i3[s3] = { value: a3, level: c3, remoteUidCount: "local" === d3 ? 0 : 1, totalTs: null !== (o3 = t3.get(s3)) && void 0 !== o3 ? o3 : 0 };
              }
              return Object.keys(i3).map((e4) => {
                const { level: t4, value: n4, totalTs: r4 } = i3[e4];
                return { id: e4, level: t4, value: n4, totalTs: r4 };
              });
            }(s2, e2);
            const d2 = Date.now(), u2 = d2 > r2 ? d2 : r2 + 1;
            null === (n2 = this.requestUpload) || void 0 === n2 || n2.call(this, wf.EXTENSION_USAGE_STATS, { usageStats: o2, sendTs: u2 });
          }, GE("EXTENSION_USAGE_UPLOAD_INTERVAL"));
        }
        startUploadUplinkStats() {
          this.uploadUnplinkStarted || (this.uploadUnplinkStarted = true, this.uplinkStatsUploadInterval && window.clearInterval(this.uplinkStatsUploadInterval), this.uplinkStatsUploadInterval = window.setInterval(() => {
            var e2;
            const t2 = null === (e2 = this.requestStats) || void 0 === e2 ? void 0 : e2.call(this);
            t2 && (this.uploadUplinkStats(t2), this.lastStats = t2);
          }, 3e3), this.uplinkRelatedStatsUploadInterval && window.clearInterval(this.uplinkRelatedStatsUploadInterval), this.uplinkRelatedStatsUploadInterval = window.setInterval(() => {
            var e2;
            const t2 = null === (e2 = this.requestStats) || void 0 === e2 ? void 0 : e2.call(this);
            t2 && this.uploadRelatedUplinkStats(t2, this.lastStats), this.lastStats = t2;
          }, 1e3), this.uplinkDenoiserStatsUploadInterval && window.clearInterval(this.uplinkDenoiserStatsUploadInterval), this.uplinkDenoiserStatsUploadInterval = window.setInterval(() => {
            var e2;
            const t2 = null === (e2 = this.requestAllTracks) || void 0 === e2 ? void 0 : e2.call(this);
            t2 && this.uploadDenoiserStats(t2);
          }, 2e3), this.uplinkExtensionStatsUploadInterval && window.clearInterval(this.uplinkExtensionStatsUploadInterval), this.uplinkExtensionStatsUploadInterval = window.setInterval(() => {
            var e2;
            const t2 = null === (e2 = this.requestAllTracks) || void 0 === e2 ? void 0 : e2.call(this);
            t2 && this.uploadExtensionStats(t2);
          }, 2e3));
        }
        uploadTransportStats(e2) {
          dC(() => {
            var t2;
            null === (t2 = this.requestUpload) || void 0 === t2 || t2.call(this, wf.TRANSPORT_STATS, function(e3) {
              const t3 = { connectionType: 100, googRtt: e3.rtt };
              if ("relay" === e3.selectedCandidatePair.localCandidate.candidateType) {
                const i2 = e3.selectedCandidatePair.localCandidate.relayProtocol;
                "udp" === i2 && (t3.connectionType = 101), "tcp" === i2 && (t3.connectionType = 103), "tls" === i2 && (t3.connectionType = 104);
              }
              return t3;
            }(e2));
          });
        }
        uploadUplinkStats(e2) {
          var t2;
          ((null === (t2 = this.requestLocalMedia) || void 0 === t2 ? void 0 : t2.call(this)) || []).forEach((t3) => {
            let [i2, { track: n2, ssrcs: r2 }] = t3;
            switch (i2) {
              case bS.LocalVideoLowTrack:
              case bS.LocalVideoTrack: {
                const t4 = function(e3, t5, i3) {
                  var n3;
                  const r3 = t5.videoSend.find((t6) => t6.ssrc === e3);
                  if (!r3)
                    return null;
                  const o3 = { id: ZI(10, ""), timestamp: new Date(t5.timestamp).toISOString(), mediaType: "video", type: "ssrc", ssrc: r3.ssrc.toString() };
                  switch (o3.A_vstd = i3._originMediaStreamTrack && !i3._originMediaStreamTrack.enabled || i3._mediaStreamTrack && !i3._mediaStreamTrack.enabled ? "1" : "0", r3.sentFrame && (o3.A_fhs = r3.sentFrame.height.toString(), o3.A_frs = r3.sentFrame.frameRate.toString(), o3.A_fws = r3.sentFrame.width.toString()), r3.adaptionChangeReason) {
                    case "none":
                      o3.A_ac = "0";
                      break;
                    case "cpu":
                      o3.A_ac = "1";
                      break;
                    case "bandwidth":
                      o3.A_ac = "2";
                      break;
                    case "other":
                      o3.A_ac = "3";
                  }
                  return o3.A_lvps = af[i3._player ? i3._player.videoElementStatus : "uninit"].toString(), o3.A_nr = null === (n3 = r3.nacksCount) || void 0 === n3 ? void 0 : n3.toString(), r3.avgEncodeMs && (o3.A_aem = r3.avgEncodeMs.toFixed(0).toString()), o3;
                }(r2[0].ssrcId, e2, n2), o2 = i2 === bS.LocalVideoTrack ? function(e3, t5, i3) {
                  var n3, r3, o3, s3, a2, c2, d2, u2;
                  const l2 = t5.videoSend.find((t6) => t6.ssrc === e3);
                  if (!l2)
                    return null;
                  const h2 = { id: ZI(10, ""), timestamp: new Date(t5.timestamp).toISOString(), mediaType: "video", type: "ssrc", ssrc: l2.ssrc.toString() }, p2 = null !== (n3 = null !== (r3 = null === (o3 = l2.inputFrame) || void 0 === o3 ? void 0 : o3.height) && void 0 !== r3 ? r3 : null == i3 ? void 0 : i3._videoHeight) && void 0 !== n3 ? n3 : 0, _2 = null !== (s3 = null !== (a2 = null === (c2 = l2.inputFrame) || void 0 === c2 ? void 0 : c2.width) && void 0 !== a2 ? a2 : null == i3 ? void 0 : i3._videoWidth) && void 0 !== s3 ? s3 : 0, E2 = null !== (d2 = null === (u2 = l2.inputFrame) || void 0 === u2 ? void 0 : u2.frameRate) && void 0 !== d2 ? d2 : 0;
                  return p2 && (h2.A_fhi = p2 + ""), _2 && (h2.A_fwi = _2 + ""), E2 && (h2.A_fri = E2 + ""), h2;
                }(r2[0].ssrcId, e2, n2) : null;
                t4 && dC(() => {
                  var e3;
                  return null === (e3 = this.requestUpload) || void 0 === e3 ? void 0 : e3.call(this, wf.PUBLISH_STATS, { stream_type: i2 === bS.LocalVideoLowTrack ? "low" : "high", stats: ob(ob({}, t4), o2) });
                });
                const s2 = function(e3) {
                  const t5 = { id: "bweforvideo", timestamp: new Date(e3.timestamp).toISOString(), type: "VideoBwe" };
                  return e3.bitrate.retransmit && (t5.A_rb = e3.bitrate.retransmit.toString()), e3.bitrate.targetEncoded && (t5.A_teb = e3.bitrate.targetEncoded.toString()), t5.A_aeb = e3.bitrate.actualEncoded.toString(), t5.A_tb = e3.bitrate.transmit.toString(), void 0 !== e3.sendBandwidth && (t5.A_asb = e3.sendBandwidth.toString()), t5;
                }(e2);
                s2 && setTimeout(() => {
                  var e3;
                  return null === (e3 = this.requestUpload) || void 0 === e3 ? void 0 : e3.call(this, wf.PUBLISH_STATS, { stream_type: i2 === bS.LocalVideoLowTrack ? "low" : "high", stats: s2 });
                }, 1e3);
                break;
              }
              case bS.LocalAudioTrack: {
                const t4 = function(e3, t5, i3) {
                  const n3 = t5.audioSend.find((t6) => t6.ssrc === e3);
                  if (!n3)
                    return null;
                  const r3 = { id: ZI(10, ""), timestamp: new Date(t5.timestamp).toISOString(), mediaType: "audio", type: "ssrc", ssrc: n3.ssrc.toString() };
                  return r3.A_astd = i3._originMediaStreamTrack && !i3._originMediaStreamTrack.enabled || i3._mediaStreamTrack && !i3._mediaStreamTrack.enabled ? "1" : "0", n3.inputLevel ? r3.A_ail = Math.round(100 * n3.inputLevel).toString() : r3.A_ail = Math.round(100 * i3._source.getAccurateVolumeLevel()).toString(), r3.A_apil = Math.round(100 * i3._source.getAccurateVolumeLevel()).toString(), n3.aecReturnLoss && (r3.A_ecrl = Math.round(n3.aecReturnLoss).toString()), n3.aecReturnLossEnhancement && (r3.A_ecrle = Math.round(n3.aecReturnLossEnhancement).toString()), r3;
                }(r2[0].ssrcId, e2, n2);
                t4 && dC(() => {
                  var e3;
                  return null === (e3 = this.requestUpload) || void 0 === e3 ? void 0 : e3.call(this, wf.PUBLISH_STATS, { stream_type: "high", stats: t4 });
                });
                break;
              }
            }
          });
        }
        uploadRelatedUplinkStats(e2, t2) {
          var i2;
          ((null === (i2 = this.requestLocalMedia) || void 0 === i2 ? void 0 : i2.call(this)) || []).filter((e3) => {
            let [t3] = e3;
            return t3 === bS.LocalVideoLowTrack || t3 === bS.LocalVideoTrack;
          }).forEach((t3) => {
            let [i3, { ssrcs: n2 }] = t3;
            const r2 = function(e3, t4) {
              const i4 = t4.videoSend.find((t5) => t5.ssrc === e3);
              return i4 ? { mediaType: "video", isVideoMute: false, frameRateInput: i4.inputFrame && i4.inputFrame.frameRate.toString(), frameRateSent: i4.sentFrame && i4.sentFrame.frameRate.toString(), googRtt: i4.rttMs.toString(), qpSumPerFrame: Math.floor(i4.qpSumPerFrame).toString() } : null;
            }(n2[0].ssrcId, e2);
            r2 && dC(() => {
              var e3;
              null === (e3 = this.requestUpload) || void 0 === e3 || e3.call(this, wf.PUBLISH_RELATED_STATS, { stream_type: i3 === bS.LocalVideoLowTrack ? "low" : "high", stats: r2 });
            });
          });
        }
        uploadDenoiserStats(e2) {
          for (let r2 = 0; r2 < e2.length; r2++) {
            const o2 = e2[r2];
            if (o2 instanceof AI) {
              var t2, i2, n2;
              const e3 = null === (t2 = (i2 = o2._external).getDenoiserStats) || void 0 === t2 ? void 0 : t2.call(i2);
              return void (e3 && (null === (n2 = this.requestUpload) || void 0 === n2 || n2.call(this, wf.DENOISER_STATS, e3)));
            }
          }
        }
        uploadExtensionStats(e2) {
          for (let t2 = 0; t2 < e2.length; t2++) {
            e2[t2].getProcessorStats().forEach((e3) => {
              var t3;
              null === (t3 = this.requestUpload) || void 0 === t3 || t3.call(this, e3.type, e3.stats);
            });
          }
        }
        stopUploadUplinkStats() {
          this.uploadUnplinkStarted && (this.uploadUnplinkStarted = false, this.uplinkStatsUploadInterval && window.clearInterval(this.uplinkStatsUploadInterval), this.uplinkRelatedStatsUploadInterval && window.clearInterval(this.uplinkRelatedStatsUploadInterval), this.uplinkDenoiserStatsUploadInterval && window.clearInterval(this.uplinkDenoiserStatsUploadInterval), this.uplinkStatsUploadInterval = void 0, this.uplinkRelatedStatsUploadInterval = void 0, this.uplinkDenoiserStatsUploadInterval = void 0);
        }
        startUploadDownlinkStats() {
          if (this.uploadDownlinkStarted)
            return;
          let e2;
          this.uploadDownlinkStarted = true, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval);
          let t2 = false;
          this.downlinkStatsUploadInterval = window.setInterval(() => {
            var i2;
            const n2 = null === (i2 = this.requestStats) || void 0 === i2 ? void 0 : i2.call(this);
            n2 && (this.uploadDownlinkStats(n2, t2, e2), e2 = n2), t2 = !t2;
          }, 3e3), this.downlinkRelatedStatsUploadInterval && window.clearInterval(this.downlinkRelatedStatsUploadInterval), this.downlinkRelatedStatsUploadInterval = window.setInterval(() => {
            var e3;
            const t3 = null === (e3 = this.requestStats) || void 0 === e3 ? void 0 : e3.call(this);
            t3 && (this.uploadRelatedDownlinkStats(t3, this.lastStats), this.lastStats = t3);
          }, 1e3), this.downlinkExtensionStatsUploadInterval && window.clearInterval(this.downlinkExtensionStatsUploadInterval), this.downlinkExtensionStatsUploadInterval = window.setInterval(() => {
            var e3;
            const t3 = null === (e3 = this.requestRemoteMedia) || void 0 === e3 ? void 0 : e3.call(this);
            t3 && this.uploadDownlinkExtensionStats(t3);
          }, 2e3);
        }
        uploadDownlinkStats(e2, t2, i2) {
          var n2;
          ((null === (n2 = this.requestRemoteMedia) || void 0 === n2 ? void 0 : n2.call(this)) || []).forEach((n3) => {
            let [r2, o2] = n3;
            if (o2.has(AS.VIDEO) && r2.videoTrack) {
              const n4 = r2.videoTrack ? function(e3, t3, i3, n5, r3) {
                const o3 = t3.videoRecv.find((t4) => t4.ssrc === e3);
                if (!o3)
                  return null;
                const s2 = { id: ZI(10, ""), timestamp: new Date(t3.timestamp).toISOString(), mediaType: "video", type: "ssrc", ssrc: o3.ssrc.toString() };
                var a2, c2;
                if (s2.bytesReceived = o3.bytes.toString(), s2.packetsLost = o3.packetsLost.toString(), s2.packetsReceived = o3.packets.toString(), o3.framesRateFirefox && (s2.A_frr = o3.framesRateFirefox.toString()), o3.receivedFrame ? (s2.A_frr = o3.receivedFrame.frameRate.toString(), s2.A_fhr = o3.receivedFrame.height.toString(), s2.A_fwr = o3.receivedFrame.width.toString()) : (s2.A_fhr = null === (a2 = n5._videoHeight) || void 0 === a2 ? void 0 : a2.toString(), s2.A_fwr = null === (c2 = n5._videoWidth) || void 0 === c2 ? void 0 : c2.toString()), s2.A_frd = o3.decodeFrameRate.toString(), o3.outputFrame && (s2.A_fro = o3.outputFrame.frameRate.toString()), void 0 !== o3.jitterBufferMs && (s2.A_jbm = Math.floor(o3.jitterBufferMs).toString()), void 0 !== o3.currentDelayMs && (s2.A_cdm = Math.floor(o3.currentDelayMs).toString()), s2.A_fs = o3.firsCount.toString(), s2.A_ns = o3.nacksCount.toString(), s2.A_ps = o3.plisCount.toString(), n5 && (s2.A_vrtd = n5._originMediaStreamTrack.enabled && n5._mediaStreamTrack.enabled ? "0" : "1"), n5._player && n5._player.freezeTimeCounterList.length > 0 && (s2.A_vrft = Math.round(n5._player.freezeTimeCounterList.splice(0, 1)[0]).toString()), r3 && n5._player && "visible" === MI.visibility) {
                  const e4 = Math.min(6e3, n5._player.renderFreezeAccTime);
                  s2.A_vrrft = Math.round(e4).toString(), n5._player.renderFreezeAccTime = Math.max(0, n5._player.renderFreezeAccTime - e4);
                }
                if (s2.A_rvps = af[n5._player ? n5._player.videoElementStatus : "uninit"].toString(), i3) {
                  const t4 = i3.videoRecv.find((t5) => t5.ssrc === e3);
                  if (t4 && void 0 !== o3.totalInterFrameDelay && void 0 !== o3.totalSquaredInterFrameDelay && void 0 !== t4.totalInterFrameDelay && void 0 !== t4.totalSquaredInterFrameDelay) {
                    const e4 = o3.totalInterFrameDelay - t4.totalInterFrameDelay, i4 = o3.totalSquaredInterFrameDelay - t4.totalSquaredInterFrameDelay, n6 = o3.framesDecodeCount - t4.framesDecodeCount, r4 = e4 / n6 * 1e3, a3 = Math.round(1e3 * Math.sqrt((i4 - Math.pow(e4, 2) / n6) / n6));
                    !isNaN(a3) && r4 + a3 > Math.max(3 * r4, r4 + 150) && (s2.A_ifdsd = a3.toString());
                  }
                }
                return s2;
              }(r2._videoSSRC, e2, i2, r2.videoTrack, t2) : void 0;
              n4 && dC(() => {
                var e3;
                return null === (e3 = this.requestUpload) || void 0 === e3 ? void 0 : e3.call(this, wf.SUBSCRIBE_STATS, { stream_id: r2.uid, stats: n4 });
              });
            }
            if (o2.has(AS.AUDIO) && r2.audioTrack) {
              const t3 = r2.audioTrack ? function(e3, t4, i3, n4) {
                const r3 = t4.audioRecv.find((t5) => t5.ssrc === e3);
                if (!r3)
                  return null;
                const o3 = { id: ZI(10, ""), timestamp: new Date(t4.timestamp).toISOString(), mediaType: "audio", type: "ssrc", ssrc: r3.ssrc.toString() };
                if (o3.bytesReceived = r3.bytes.toString(), o3.packetsLost = r3.packetsLost.toString(), o3.packetsReceived = r3.packets.toString(), r3.outputLevel ? o3.A_aol = Math.round(100 * r3.outputLevel).toString() : o3.A_aol = Math.round(100 * n4._source.getAccurateVolumeLevel()).toString(), o3.A_apol = Math.round(100 * n4._source.getAccurateVolumeLevel()).toString(), n4 && (o3.A_artd = n4._originMediaStreamTrack.enabled && n4._mediaStreamTrack.enabled ? "0" : "1"), o3.A_jr = r3.jitterMs.toString(), o3.A_jbm = Math.floor(r3.jitterBufferMs).toString(), o3.A_cdm = Math.floor(r3.jitterBufferMs).toString(), o3.A_raps = af[pR.getPlayerState(n4.getTrackId())].toString(), i3) {
                  const t5 = i3.audioRecv.find((t6) => t6.ssrc === e3);
                  if (t5) {
                    const e4 = r3.concealedSamples - t5.concealedSamples;
                    e4 > 0 && (o3.A_cs = Math.round(e4).toString());
                  }
                }
                return o3;
              }(r2._audioSSRC, e2, i2, r2.audioTrack) : void 0;
              t3 && dC(() => {
                var e3;
                return null === (e3 = this.requestUpload) || void 0 === e3 ? void 0 : e3.call(this, wf.SUBSCRIBE_STATS, { stream_id: r2.uid, stats: t3 });
              });
            }
          });
        }
        uploadRelatedDownlinkStats(e2, t2) {
          var i2;
          ((null === (i2 = this.requestRemoteMedia) || void 0 === i2 ? void 0 : i2.call(this)) || []).forEach((i3) => {
            let [n2, r2] = i3;
            if (r2.has(AS.VIDEO) && n2.videoTrack) {
              var o2;
              const i4 = true === (n2._videoSSRC && (null === (o2 = this.requestVideoIsReady) || void 0 === o2 ? void 0 : o2.call(this, n2._videoSSRC)) || false), r3 = function(e3, t3, i5, n3, r4, o3) {
                const s2 = i5.videoRecv.find((t4) => t4.ssrc === e3), a2 = r4 ? r4.videoRecv.find((t4) => t4.ssrc === e3) : void 0;
                if (!s2)
                  return null;
                const c2 = kI.isRemoteVideoFreeze(o3, s2, a2) && t3, d2 = { mediaType: "video", isVideoMute: false, peerId: n3, frameRateReceived: s2.receivedFrame && s2.receivedFrame.frameRate.toString(), frameRateDecoded: s2.decodedFrame && s2.decodedFrame.frameRate.toString(), isFreeze: c2, bytesReceived: s2.bytes.toString(), packetsReceived: s2.packets.toString(), packetsLost: s2.packetsLost.toString(), qpSumPerFrame: Math.floor(s2.qpSumPerFrame).toString() };
                return s2.framesRateFirefox && (d2.frameRateDecoded = s2.framesRateFirefox.toString(), d2.frameRateReceived = s2.framesRateFirefox.toString()), d2;
              }(n2._videoSSRC, i4, e2, n2.uid, t2, n2.videoTrack);
              r3 && dC(() => {
                var e3;
                null === (e3 = this.requestUpload) || void 0 === e3 || e3.call(this, wf.SUBSCRIBE_RELATED_STATS, { stream_id: n2.uid, stats: r3 });
              });
            }
            if (r2.has(AS.AUDIO) && n2.audioTrack) {
              const t3 = function(e3, t4, i4, n3) {
                const r3 = t4.audioRecv.find((t5) => t5.ssrc === e3);
                if (!r3)
                  return null;
                const o3 = kI.isRemoteAudioFreeze(n3);
                return { mediaType: "audio", isAudioMute: false, peerId: i4, googJitterReceived: r3.jitterMs.toString(), isFreeze: o3, bytesReceived: r3.bytes.toString(), packetsReceived: r3.packets.toString(), packetsLost: r3.packetsLost.toString(), frameReceived: r3.receivedFrames.toString(), frameDropped: r3.droppedFrames.toString() };
              }(n2._audioSSRC, e2, n2.uid, n2.audioTrack);
              t3 && dC(() => {
                var e3;
                null === (e3 = this.requestUpload) || void 0 === e3 || e3.call(this, wf.SUBSCRIBE_RELATED_STATS, { stream_id: n2.uid, stats: t3 });
              });
            }
          });
        }
        stopUploadDownlinkStats() {
          this.uploadDownlinkStarted && (this.uploadDownlinkStarted = false, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval), this.downlinkRelatedStatsUploadInterval && window.clearInterval(this.downlinkRelatedStatsUploadInterval), this.downlinkStatsUploadInterval = void 0, this.downlinkRelatedStatsUploadInterval = void 0);
        }
        stopUploadTransportStats() {
          this.uploadTransportStarted && (this.uploadTransportStarted = false, this.transportStatsUploadInterval && window.clearInterval(this.transportStatsUploadInterval), this.transportStatsUploadInterval = void 0);
        }
        stopUploadExtensionUsageStats() {
          this.uploadExtensionUsageStarted && (this.uploadExtensionUsageStarted = false, this.extensionUsageStatsUploadInterval && window.clearInterval(this.extensionUsageStatsUploadInterval), this.extensionUsageStatsUploadInterval = void 0);
        }
        uploadDownlinkExtensionStats(e2) {
          e2.forEach((e3) => {
            let [t2, i2] = e3;
            if (i2.has(AS.VIDEO) && t2.videoTrack) {
              t2.videoTrack.getProcessorStats().forEach((e4) => {
                var t3;
                null === (t3 = this.requestUpload) || void 0 === t3 || t3.call(this, e4.type, e4.stats);
              });
            }
            if (i2.has(AS.AUDIO) && t2.audioTrack) {
              t2.audioTrack.getProcessorStats().forEach((e4) => {
                var t3;
                null === (t3 = this.requestUpload) || void 0 === t3 || t3.call(this, e4.type, e4.stats);
              });
            }
          });
        }
      }
      function ab(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function cb(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? ab(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : ab(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      const db = "v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0\na=msid-semantic: WMS\na=ice-lite\nm=application 9 UDP/DTLS/SCTP webrtc-datachannel\nc=IN IP4 127.0.0.1\na=mid:0\n", ub = "9", lb = 2e4, hb = 4e4;
      class pb {
        get localCapabilities() {
          return uC(this._localCapabilities);
        }
        get rtpCapabilities() {
          return uC(this._rtpCapabilities);
        }
        get candidates() {
          return uC(this._candidates);
        }
        get iceParameters() {
          return uC(this._iceParameters);
        }
        get dtlsParameters() {
          return uC(this._dtlsParameters);
        }
        constructor(e2) {
          _p(this, "sessionDesc", void 0), _p(this, "_localCapabilities", void 0), _p(this, "_rtpCapabilities", void 0), _p(this, "_candidates", void 0), _p(this, "_iceParameters", void 0), _p(this, "_dtlsParameters", void 0), _p(this, "setup", void 0), _p(this, "currentMidIndex", void 0), _p(this, "cname", void 0), _p(this, "firefoxSsrcMidMap", /* @__PURE__ */ new Map()), e2 = uC(e2);
          const { remoteIceParameters: t2, remoteDtlsParameters: i2, candidates: n2, remoteRTPCapabilities: r2, remoteSetup: o2, localCapabilities: s2, cname: a2 } = e2, c2 = UO.exports.parse(db);
          this._rtpCapabilities = r2, this._candidates = n2, this._iceParameters = t2, this._dtlsParameters = i2, this._localCapabilities = s2, this.setup = o2, this.cname = a2;
          const d2 = this.rtpCapabilities.send;
          for (const e3 of c2.mediaDescriptions) {
            if (e3.attributes.iceUfrag = t2.iceUfrag, e3.attributes.icePwd = t2.icePwd, e3.attributes.fingerprints = i2.fingerprints, e3.attributes.candidates = n2, e3.attributes.setup = o2, "application" === e3.media.mediaType && (e3.attributes.sctpPort = "5000"), "video" === e3.media.mediaType && (e3.media.fmts = d2.videoCodecs.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = d2.videoCodecs, e3.attributes.extmaps = d2.videoExtensions, GE("PRELOAD_MEDIA_COUNT") > 0)) {
              const { ssrcs: t3, ssrcGroups: i3 } = WO([{ ssrcId: hb, rtx: GE("USE_SUB_RTX") ? 40001 : void 0 }], this.cname);
              e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = i3;
            }
            if ("audio" === e3.media.mediaType && (e3.media.fmts = d2.audioCodecs.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = d2.audioCodecs, e3.attributes.extmaps = d2.audioExtensions, $O(e3), GE("PRELOAD_MEDIA_COUNT") > 0)) {
              const { ssrcs: t3, ssrcGroups: i3 } = WO([{ ssrcId: lb }], this.cname);
              e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = i3;
            }
          }
          this.sessionDesc = c2, this.currentMidIndex = c2.mediaDescriptions.length - 1;
        }
        updateRemoteRTPCapabilities(e2) {
          const t2 = UO.exports.parse(db);
          this._rtpCapabilities = e2;
          const i2 = this.rtpCapabilities.send;
          for (const e3 of t2.mediaDescriptions) {
            if (e3.attributes.iceUfrag = this._iceParameters.iceUfrag, e3.attributes.icePwd = this._iceParameters.icePwd, e3.attributes.fingerprints = this._dtlsParameters.fingerprints, e3.attributes.candidates = this._candidates, e3.attributes.setup = this.setup, "application" === e3.media.mediaType && (e3.attributes.sctpPort = "5000"), "video" === e3.media.mediaType && (e3.media.fmts = i2.videoCodecs.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = i2.videoCodecs, e3.attributes.extmaps = i2.videoExtensions, GE("PRELOAD_MEDIA_COUNT") > 0)) {
              const { ssrcs: t3, ssrcGroups: i3 } = WO([{ ssrcId: hb, rtx: GE("USE_SUB_RTX") ? 40001 : void 0 }], this.cname);
              e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = i3;
            }
            if ("audio" === e3.media.mediaType && (e3.media.fmts = i2.audioCodecs.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = i2.audioCodecs, e3.attributes.extmaps = i2.audioExtensions, GE("PRELOAD_MEDIA_COUNT") > 0)) {
              const { ssrcs: t3, ssrcGroups: i3 } = WO([{ ssrcId: lb }], this.cname);
              e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = i3;
            }
          }
          this.sessionDesc = t2, this.currentMidIndex = t2.mediaDescriptions.length - 1;
        }
        preloadRemoteMedia(e2) {
          this.rtpCapabilities;
          const t2 = this.candidates, i2 = this.dtlsParameters, n2 = this.iceParameters, r2 = this.rtpCapabilities.send;
          for (let o2 = 1; o2 < e2; o2++) {
            const e3 = 2 * o2 + lb, s2 = 2 * o2 + hb, { ssrcs: a2, ssrcGroups: c2 } = WO([{ ssrcId: e3 }], this.cname), { ssrcs: d2, ssrcGroups: u2 } = WO([{ ssrcId: s2, rtx: GE("USE_SUB_RTX") ? s2 + 1 : void 0 }], this.cname);
            this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "video", port: ub, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r2.videoCodecs.map((e4) => e4.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: n2.iceUfrag, icePwd: n2.icePwd, unrecognized: [], candidates: t2, extmaps: r2.videoExtensions, fingerprints: i2.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: d2, ssrcGroups: u2, rtcpFeedbackWildcards: [], payloads: r2.videoCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(2 * o2 - 1) } }), this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "audio", port: ub, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r2.audioCodecs.map((e4) => e4.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: n2.iceUfrag, icePwd: n2.icePwd, unrecognized: [], candidates: t2, extmaps: r2.audioExtensions, fingerprints: i2.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: a2, ssrcGroups: c2, rtcpFeedbackWildcards: [], payloads: r2.audioCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(2 * o2) } }), this.currentMidIndex += 2;
          }
          this.updateBundleMids();
        }
        toString() {
          return UO.exports.print(this.sessionDesc);
        }
        send(e2, t2, i2, n2) {
          const { ssrcs: r2, ssrcGroups: o2 } = WO(t2, this.cname, GE("SYNC_GROUP") ? i2 : void 0), s2 = this.findPreloadMediaDesc(r2);
          if (s2) {
            if (Kh() && this.firefoxSsrcMidMap.set(r2[0].ssrcId, s2.attributes.mid), n2 && (n2.twcc || n2.remb)) {
              const e3 = this.sessionDesc.mediaDescriptions.indexOf(s2);
              return this.sessionDesc.mediaDescriptions[e3] = this.mungSendMediaDesc(s2, n2), { mid: s2.attributes.mid, needExchangeSDP: true };
            }
            return { mid: s2.attributes.mid, needExchangeSDP: false };
          }
          {
            const t3 = this.findAvailableMediaIndex(e2, r2);
            let i3;
            return -1 === t3 || Hh() || Yh() || zh() || 0 === t3 && GE("USE_SUB_RTX") ? (i3 = this.createOrRecycleSendMedia(e2, r2, o2, "sendonly", n2), this.updateBundleMids()) : (i3 = uC(this.sessionDesc.mediaDescriptions[t3]), i3.attributes.direction = "sendonly", i3.attributes.ssrcs = r2, i3.attributes.ssrcGroups = o2, this.sessionDesc.mediaDescriptions[t3] = this.mungSendMediaDesc(i3, n2)), Kh() && this.firefoxSsrcMidMap.set(r2[0].ssrcId, i3.attributes.mid), { mid: i3.attributes.mid, needExchangeSDP: true };
          }
        }
        batchSend(e2) {
          const t2 = e2.map((e3) => {
            let { kind: t3, ssrcMsg: i3, mslabel: n3 } = e3;
            return this.send(t3, i3, n3);
          }), i2 = [];
          let n2 = false;
          return t2.forEach((e3) => {
            let { mid: t3, needExchangeSDP: r2 } = e3;
            r2 && (n2 = true), i2.push(t3);
          }), { mids: i2, needExchangeSDP: n2 };
        }
        stopSending(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => t3.attributes.mid && -1 !== e2.indexOf(t3.attributes.mid));
          if (t2.length !== e2.length)
            throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
          t2.forEach((e3) => {
            "0" === e3.attributes.mid || Kh() || Hh() || Yh() ? e3.attributes.ssrcs = [] : (e3.attributes.ssrcs = [], e3.attributes.direction = "inactive", e3.media.port = "0");
          }), this.updateBundleMids();
        }
        mute(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2);
          if (!t2)
            throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.mute."));
          t2.attributes.direction = "inactive";
        }
        unmute(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2);
          if (!t2)
            throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.unmute."));
          t2.attributes.direction = "sendonly";
        }
        muteRemote(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => e2.includes(t3.attributes.mid || ""));
          if (t2.length !== e2.length)
            throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
          t2.forEach((e3) => {
            e3.attributes.direction = "inactive";
          });
        }
        unmuteRemote(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => e2.includes(t3.attributes.mid || ""));
          if (t2.length !== e2.length)
            throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
          t2.forEach((e3) => {
            e3.attributes.direction = "recvonly";
          });
        }
        receive(e2, t2, i2, n2) {
          e2.forEach((e3, r2) => {
            this.createOrRecycleRecvMedia(e3, [], "recvonly", t2, i2, n2[r2]);
          }), this.updateBundleMids();
        }
        stopReceiving(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => -1 !== e2.indexOf(t3.attributes.mid));
          if (t2.length !== e2.length)
            throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
          t2.forEach((e3) => {
            e3.media.port = "0", e3.attributes.direction = "inactive";
          }), this.updateBundleMids();
        }
        updateCandidates(e2) {
          e2 === OS.TCP ? this._candidates.forEach((e3) => {
            -1 === this._candidates.findIndex((t2) => "tcp" === t2.transport && t2.connectionAddress === e3.connectionAddress && t2.port === e3.port) && this._candidates.push(cb(cb({}, e3), {}, { foundation: "tcpcandidate", priority: Number(e3.priority) - 1 + "", transport: "tcp", port: Number(e3.port) + 90 + "" }));
          }) : this._candidates = this._candidates.filter((e3) => "tcp" !== e3.transport);
          for (const e3 of this.sessionDesc.mediaDescriptions)
            e3.attributes.candidates = this.candidates;
        }
        restartICE(e2) {
          e2 = uC(e2), this._iceParameters = e2, this.sessionDesc.mediaDescriptions.forEach((t2) => {
            t2.attributes.iceUfrag = e2.iceUfrag, t2.attributes.icePwd = e2.icePwd;
          });
        }
        predictReceivingMids(e2) {
          const t2 = [];
          for (let i2 = 0; i2 < e2; i2++)
            t2.push((this.currentMidIndex + i2 + 1).toString(10));
          return t2;
        }
        findAvailableMediaIndex(e2, t2) {
          return this.sessionDesc.mediaDescriptions.findIndex((i2) => {
            const n2 = i2.media.mediaType === e2 && "0" !== i2.media.port && ("sendonly" === i2.attributes.direction || "sendrecv" === i2.attributes.direction) && 0 === i2.attributes.ssrcs.length;
            if (Kh()) {
              if (n2) {
                const e3 = this.firefoxSsrcMidMap.get(t2[0].ssrcId);
                return !(e3 || "0" !== i2.attributes.mid && "1" !== i2.attributes.mid) || !(!e3 || e3 !== i2.attributes.mid);
              }
              return false;
            }
            return n2;
          });
        }
        createOrRecycleRecvMedia(e2, t2, i2, n2, r2, o2) {
          const s2 = e2._mediaStreamTrack.kind, a2 = this.rtpCapabilities.recv, c2 = this.localCapabilities.send;
          let d2 = [];
          if (s2 === AS.VIDEO) {
            var u2, l2;
            if (GE("H264_PROFILE_LEVEL_ID") && "h264" === n2 && (d2 = a2.videoCodecs.filter((e3) => {
              var t3, i3;
              return ((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "").includes(n2) && (null == e3 || null === (i3 = e3.fmtp) || void 0 === i3 ? void 0 : i3.parameters["profile-level-id"]) === GE("H264_PROFILE_LEVEL_ID");
            })), !d2 || 0 === (null === (u2 = d2) || void 0 === u2 ? void 0 : u2.length)) {
              const e3 = c2.videoCodecs.filter((e4) => {
                var t3;
                return ((null === (t3 = e4.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "").includes(n2);
              });
              0 !== e3.length && (d2 = a2.videoCodecs.filter((t3) => e3.some((e4) => e4.payloadType === t3.payloadType)));
            }
            if (GE("USE_PUB_RTX")) {
              const e3 = d2.map((e4) => e4.payloadType.toString()), t3 = a2.videoCodecs.filter((t4) => {
                var i3, n3;
                return "rtx" === (null === (i3 = t4.rtpMap) || void 0 === i3 ? void 0 : i3.encodingName) && e3.includes((null === (n3 = t4.fmtp) || void 0 === n3 ? void 0 : n3.parameters.apt) || "");
              });
              d2 = [...d2, ...t3];
            }
            if (0 === d2.length)
              OE.warning("codec ".concat(n2, " not included in rtpCapabilities, fallback to default payloads: ").concat(null === (l2 = a2.videoCodecs[0].rtpMap) || void 0 === l2 ? void 0 : l2.encodingName)), d2 = a2.videoCodecs;
          } else
            d2 = a2.audioCodecs.filter((e3) => {
              var t3;
              return ((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "").includes(r2);
            }), 0 === d2.length && (OE.warning("codec ".concat(r2, " not included in rtpCapabilities, fallback to opus")), d2 = a2.audioCodecs.filter((e3) => {
              var t3;
              return ((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "").includes("opus");
            }));
          const h2 = s2 === AS.VIDEO ? a2.videoExtensions : a2.audioExtensions;
          this.currentMidIndex += 1;
          const p2 = "".concat(this.currentMidIndex);
          let _2 = { media: { mediaType: s2, port: ub, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: d2.map((e3) => e3.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: h2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: d2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i2, rtcpMux: true, rtcpRsize: true, mid: "".concat(p2) } };
          _2 = this.mungRecvMediaDsec(_2, e2, o2);
          const E2 = this.findFirstClosedMedia(s2);
          if (E2) {
            const e3 = this.sessionDesc.mediaDescriptions.indexOf(E2);
            this.sessionDesc.mediaDescriptions[e3] = _2;
          } else
            this.sessionDesc.mediaDescriptions.push(_2);
          return _2;
        }
        createOrRecycleSendMedia(e2, t2, i2, n2, r2) {
          const o2 = this.rtpCapabilities.send, s2 = e2 === AS.VIDEO ? o2.videoCodecs : o2.audioCodecs, a2 = e2 === AS.VIDEO ? o2.videoExtensions : o2.audioExtensions;
          this.currentMidIndex += 1;
          const c2 = "".concat(this.currentMidIndex);
          let d2 = { media: { mediaType: e2, port: ub, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: s2.map((e3) => e3.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: a2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: i2, rtcpFeedbackWildcards: [], payloads: s2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: n2, rtcpMux: true, rtcpRsize: true, mid: "".concat(c2) } };
          d2 = this.mungSendMediaDesc(d2, r2);
          const u2 = this.findFirstClosedMedia(e2);
          if (u2) {
            const e3 = this.sessionDesc.mediaDescriptions.indexOf(u2);
            this.sessionDesc.mediaDescriptions[e3] = d2;
          } else
            this.sessionDesc.mediaDescriptions.push(d2);
          return d2;
        }
        updateBundleMids() {
          this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter((e2) => "0" !== e2.media.port).map((e2) => e2.attributes.mid);
        }
        mungRecvMediaDsec(e2, t2, i2) {
          const n2 = uC(e2);
          return KO(n2), HO(n2, t2), YO(n2, t2), qO(n2), JO(n2, i2, this.localCapabilities.send), n2;
        }
        mungSendMediaDesc(e2, t2) {
          const i2 = uC(e2);
          return JO(i2, t2, this.localCapabilities.recv), $O(i2), i2;
        }
        updateRecvMedia(e2, t2) {
          const i2 = this.sessionDesc.mediaDescriptions.findIndex((t3) => t3.attributes.mid === e2);
          if (-1 !== i2) {
            const e3 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i2], t2);
            this.sessionDesc.mediaDescriptions[i2] = e3;
          }
        }
        bumpMid(e2) {
          this.currentMidIndex += e2;
        }
        findFirstClosedMedia(e2) {
          return this.sessionDesc.mediaDescriptions.find((t2) => Kh() ? "0" === t2.media.port && t2.media.mediaType === e2 : "0" === t2.media.port);
        }
        findPreloadMediaDesc(e2) {
          return this.sessionDesc.mediaDescriptions.find((t2) => {
            var i2, n2;
            return (null === (i2 = t2.attributes) || void 0 === i2 || null === (n2 = i2.ssrcs[0]) || void 0 === n2 ? void 0 : n2.ssrcId) === e2[0].ssrcId;
          });
        }
        getSSRC(e2) {
          var t2;
          return null === (t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2)) || void 0 === t2 ? void 0 : t2.attributes.ssrcs;
        }
      }
      var _b;
      function Eb(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function mb(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Eb(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : Eb(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      let fb = (ag((_b = class e2 extends YS {
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        constructor(e3, t2, i2) {
          super(e3, t2), _p(this, "store", void 0), _p(this, "peerConnection", void 0), _p(this, "remoteSDP", void 0), _p(this, "initialOffer", void 0), _p(this, "transportEventReceiver", void 0), _p(this, "statsFilter", void 0), _p(this, "localCapabilities", void 0), _p(this, "localCandidateCount", 0), _p(this, "allCandidatesReceived", false), _p(this, "establishPromise", void 0), _p(this, "mutex", new Ug("NVExtentionsConnection-mutex")), _p(this, "rtcMedia", void 0), this.store = t2, this.peerConnection = i2, this.statsFilter = vN(this.peerConnection, GE("STATS_UPDATE_INTERVAL"), void 0, Kh() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();
        }
        async establish(e3) {
          try {
            const e4 = await this.peerConnection.createOffer();
            if (!e4.sdp)
              throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
            const t2 = FO(e4.sdp), i2 = await zO(!GE("USE_PUB_RTX") && !GE("USE_SUB_RTX"), GE("FILTER_VIDEO_FEC"), GE("FILTER_AUDIO_FEC"));
            return this.localCapabilities = i2, this.initialOffer = e4, mb(mb({}, t2), {}, { rtpCapabilities: i2, offerSDP: e4.sdp });
          } catch (e4) {
            throw new SE(fE.GET_LOCAL_CONNECTION_PARAMS_FAILED, e4.toString());
          }
        }
        async connect(e3, t2, i2, n2, r2, o2) {
          try {
            if (!this.initialOffer)
              throw new Error("Cannot establish NVConnection without initial offer.");
            this.remoteSDP = new pb({ remoteIceParameters: e3, remoteDtlsParameters: t2, candidates: i2, remoteRTPCapabilities: n2, remoteSetup: r2, localCapabilities: ZO(this.localCapabilities), cname: o2 });
            const s2 = this.remoteSDP.toString(), a2 = UO.exports.parse(this.initialOffer.sdp), c2 = a2.mediaDescriptions.find((e4) => "audio" === e4.media.mediaType);
            c2 && $O(c2);
            const d2 = UO.exports.print(a2), u2 = this.logSDPExchange(d2 || "", "offer", "local", "connect");
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: d2 }), null == u2 || u2(s2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: s2 });
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "NV.connect failed; ".concat(e4.toString()));
          }
        }
        async updateRemoteConnect(e3) {
          var t2, i2, n2;
          null === (t2 = this.remoteSDP) || void 0 === t2 || t2.updateRemoteRTPCapabilities(e3), null === (i2 = this.remoteSDP) || void 0 === i2 || i2.preloadRemoteMedia(2);
          const r2 = null === (n2 = this.remoteSDP) || void 0 === n2 ? void 0 : n2.toString();
          await this.peerConnection.setRemoteDescription({ type: "offer", sdp: r2 });
          const o2 = await this.peerConnection.createAnswer();
          await this.peerConnection.setLocalDescription(o2), OE.debug("[NVExtentionsConnection] updateRemoteRTPCapabilities by exchanging SDP.");
        }
        send(e3, t2, i2) {
          var n2 = this;
          return DO(function* () {
            const r2 = yield PO(n2.mutex.lock("From NVExtentionsConnection.send"));
            try {
              if (!n2.remoteSDP)
                throw new Error("Cannot call NVExtentionsConnection.send before remote SDP created");
              const o2 = [];
              e3.forEach((e4) => {
                const t3 = n2.peerConnection.addTransceiver(e4._mediaStreamTrack, { direction: "sendonly" });
                o2.push(t3);
              }), Kh() && true === GE("SIMULCAST") && (yield PO(n2.applySimulcastForFirefox(o2, e3)));
              const s2 = yield PO(n2.peerConnection.createOffer()), a2 = n2.remoteSDP.predictReceivingMids(e3.length), c2 = n2.mungSendOfferSDP(s2.sdp, e3, a2), d2 = UO.exports.parse(c2), u2 = a2.map((e4) => {
                const t3 = d2.mediaDescriptions.find((t4) => t4.attributes.mid === e4);
                if (!t3)
                  throw new Error("Cannot extract ssrc from mediaDescription.");
                return BO(t3, GE("USE_PUB_RTX"));
              });
              let l2;
              try {
                l2 = yield u2;
              } catch (r3) {
                l2 = [], n2.remoteSDP.receive(e3, t2, i2, l2);
                const o3 = n2.remoteSDP.toString();
                throw yield PO(n2.peerConnection.setLocalDescription({ type: "offer", sdp: c2 })), yield PO(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: o3 })), yield PO(n2.stopSending(a2, true)), r3;
              }
              n2.remoteSDP.receive(e3, t2, i2, l2);
              const h2 = n2.remoteSDP.toString(), p2 = n2.logSDPExchange(c2, "offer", "local", "send");
              return yield PO(n2.peerConnection.setLocalDescription({ type: "offer", sdp: c2 })), yield PO(n2.applySimulcastEncodings(o2, e3)), yield PO(n2.applySendEncodings(o2, e3)), null == p2 || p2(h2), yield PO(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: h2 })), o2.map((e4, t3) => {
                const i3 = a2[t3];
                return { localSSRC: u2[t3], id: i3, transceiver: e4 };
              });
            } catch (e4) {
              throw e4 instanceof SE ? e4 : new SE(fE.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.send failed; ".concat(e4.toString()));
            } finally {
              r2();
            }
          })();
        }
        async stopSending(e3, t2) {
          const i2 = t2 ? void 0 : await this.mutex.lock("From NVExtentionsConnection.stopSending");
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call NVExtentionsConnection.stopSending before remote SDP created");
            const t3 = this.peerConnection.getTransceivers().filter((t4) => -1 !== e3.indexOf(t4.mid));
            if (t3.length !== e3.length)
              throw new Error("Transceivers' length doesn't match mids' length when trying to call NVExtentionsConnection.stopSending.");
            t3.map((e4) => {
              var t4;
              e4.direction = "inactive", null === (t4 = e4.stop) || void 0 === t4 || t4.call(e4);
            });
            const n2 = await this.peerConnection.createOffer(), r2 = this.logSDPExchange(n2.sdp || "", "offer", "local", "stopSending");
            await this.peerConnection.setLocalDescription(n2), this.remoteSDP.stopReceiving(e3);
            const o2 = this.remoteSDP.toString();
            null == r2 || r2(o2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o2 });
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.stopSending failed; ".concat(e4.toString()));
          } finally {
            i2 && i2();
          }
        }
        async receive(e3, t2, i2, n2) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call NVExtentionsConnection.receive ".concat(e3, " before remoteSDP created."));
            const { mid: r2, needExchangeSDP: o2 } = this.remoteSDP.send(e3, t2, i2, n2);
            if (o2) {
              const t3 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t3, "offer", "remote", "receive");
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t3 });
              const n3 = await this.peerConnection.createAnswer(), o3 = this.mungReceiveAnswerSDP(n3.sdp, r2, e3);
              null == i3 || i3(o3 || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: o3 }), OE.debug("[NVExtentionsConnection] receive ".concat(e3, " by exchanging SDP."));
            } else
              OE.debug("[NVExtentionsConnection] receive ".concat(e3, " no need to exchange SDP."));
            const s2 = this.peerConnection.getTransceivers().find((e4) => e4.mid === r2);
            if (!s2)
              throw new Error("Cannot get transceiver after setLocalDescription.");
            return { track: s2.receiver.track, id: r2 };
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async batchReceive(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call NVExtentionsConnection.batchReceive before remoteSDP created.");
            const { mids: t2, needExchangeSDP: i2 } = this.remoteSDP.batchSend(e3);
            if (i2) {
              const e4 = this.remoteSDP.toString(), t3 = this.logSDPExchange(e4, "offer", "remote", "receive");
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e4 });
              const i3 = await this.peerConnection.createAnswer();
              null == t3 || t3(i3.sdp || ""), await this.peerConnection.setLocalDescription(i3), OE.debug("[NVExtentionsConnection] batchReceive by exchanging SDP.");
            } else
              OE.debug("[NVExtentionsConnection] batchReceive no need to exchange SDP.");
            return t2.map((e4) => {
              const t3 = this.peerConnection.getTransceivers().find((t4) => t4.mid === e4);
              if (!t3)
                throw new Error("Cannot get transceiver after setLocalDescription.");
              return { track: t3.receiver.track, id: e4 };
            });
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async stopReceiving(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call NVExtentionsConnection.stopReceiving before remote SDP created.");
            this.remoteSDP.stopSending(e3);
            const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "stopReceiving");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "NVExtentionsConnection stopReceiving failed; ".concat(e4.toString()));
          }
        }
        async muteRemote(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call NVExtentionsConnection.muteRemote mid=".concat(e3, " before remote SDP created."));
            this.remoteSDP.mute(e3);
            const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "muteRemote");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.muteRemote failed; ".concat(e4.toString()));
          }
        }
        async unmuteRemote(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call NVExtentionsConnection.unmuteRemote mid=".concat(e3, " before remote SDP created."));
            this.remoteSDP.unmute(e3);
            const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "unmuteRemote");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.unmuteRemote failed; ".concat(e4.toString()));
          }
        }
        async muteLocal(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call NVExtentionsConnection.muteLocal before remote SDP created.");
            const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e3.indexOf(t3.mid));
            if (t2.length !== e3.length)
              throw new Error("Transceivers' length doesn't match mids' length.");
            t2.map((e4) => {
              e4.direction = "inactive";
            });
            const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "muteLocal");
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.muteRemote(e3);
            const r2 = this.remoteSDP.toString();
            null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.muteLocal failed; ".concat(e4.toString()));
          }
        }
        async unmuteLocal(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call NVExtentionsConnection.unmuteLocal before remote SDP created.");
            const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e3.indexOf(t3.mid));
            if (t2.length !== e3.length)
              throw new Error("Transceivers' length doesn't match mids' length.");
            t2.map(async (e4, t3) => {
              e4.direction = "sendonly";
            });
            const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "unmuteLocal");
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.unmuteRemote(e3);
            const r2 = this.remoteSDP.toString();
            null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.unmuteLocal failed; ".concat(e4.toString()));
          }
        }
        restartICE(e3) {
          var t2 = this;
          return DO(function* () {
            const i2 = yield PO(t2.mutex.lock("From NVExtentionsConnection.restartICE"));
            try {
              if (!t2.remoteSDP)
                throw new Error("Cannot restartICE before remoteSDP created.");
              if (JS().supportPCSetConfiguration) {
                const i3 = t2.peerConnection.getConfiguration(), n3 = e3 === OS.RELAY ? "relay" : "all";
                i3.iceTransportPolicy !== n3 && (OE.debug("restartICE change iceTransportPolicy from [".concat(i3.iceTransportPolicy, "] to [").concat(n3, "]")), i3.iceTransportPolicy = n3, t2.peerConnection.setConfiguration(i3));
              } else if (e3 === OS.RELAY)
                return;
              e3 !== OS.RELAY && t2.remoteSDP.updateCandidates(e3);
              const n2 = yield PO(t2.peerConnection.createOffer({ iceRestart: true }));
              if (!n2.sdp)
                throw new Error("Cannot restartICE because restart offer SDP does not exist.");
              const r2 = FO(n2.sdp), { remoteIceParameters: o2 } = yield r2.iceParameters;
              t2.remoteSDP.restartICE(o2);
              const s2 = t2.remoteSDP.toString(), a2 = t2.logSDPExchange(n2.sdp || "", "offer", "local", "restartICE");
              yield PO(t2.peerConnection.setLocalDescription(n2)), null == a2 || a2(s2), yield PO(t2.peerConnection.setRemoteDescription({ type: "answer", sdp: s2 }));
            } catch (e4) {
              OE.warning("restart ICE failed, abort operation", e4);
            } finally {
              i2();
            }
          })();
        }
        close() {
          var e3;
          null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, "closed"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy();
        }
        getStats() {
          return this.statsFilter.getStats();
        }
        getRemoteVideoIsReady(e3) {
          return this.statsFilter.getVideoIsReady(e3);
        }
        async updateEncoderConfig(e3, t2) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call NVExtentionsConnection.updateEncoderConfig before remote SDP created.");
            const i2 = await this.peerConnection.createOffer(), n2 = this.mungSendOfferSDP(i2.sdp, [t2], [e3]);
            this.remoteSDP.updateRecvMedia(e3, t2);
            const r2 = this.remoteSDP.toString(), o2 = this.logSDPExchange(n2, "offer", "local", "updateEncoderConfig");
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: n2 }), null == o2 || o2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, e4.toString());
          }
        }
        async updateSendParameters(e3, t2) {
          const i2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid === e3);
          1 === i2.length && (this.isVP8Simulcast(t2) ? Kh() || await this.applySimulcastEncodings(i2, [t2]) : await this.applySendEncodings(i2, [t2]));
        }
        setStatsRemoteVideoIsReady(e3, t2) {
          this.statsFilter.setVideoIsReady2(e3, t2);
        }
        async replaceTrack(e3, t2) {
          const i2 = this.peerConnection.getTransceivers().find((e4) => e4.mid === t2);
          i2 && await i2.sender.replaceTrack(e3._mediaStreamTrack);
        }
        getP2PConnectionParams() {
          var e3;
          if (null === (e3 = this.peerConnection.currentLocalDescription) || void 0 === e3 || !e3.sdp || !this.localCapabilities)
            throw new Error();
          return mb(mb({}, FO(this.peerConnection.currentLocalDescription.sdp)), {}, { rtpCapabilities: this.localCapabilities });
        }
        bindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = () => {
            var e3;
            null === (e3 = this.onICEConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.iceConnectionState);
          }, this.peerConnection.onconnectionstatechange = () => {
            var e3;
            null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.connectionState);
          }, this.peerConnection.onicecandidate = (e3) => {
            e3.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, OE.debug("[pc-".concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
          }, setTimeout(() => {
            this.allCandidatesReceived || (this.allCandidatesReceived = true, OE.debug("[pc-".concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
          }, GE("CANDIDATE_TIMEOUT"));
        }
        unbindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
        }
        static resolvePCConfiguration(t2) {
          const i2 = { iceServers: [] };
          return t2.iceServers ? i2.iceServers = t2.iceServers : t2.turnServer && "off" !== t2.turnServer.mode && (Uf(t2.turnServer.servers) ? i2.iceServers = t2.turnServer.servers : (i2.iceServers && i2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.servers)), GE("USE_TURN_SERVER_OF_GATEWAY") && i2.iceServers && t2.turnServer.serversFromGateway && i2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.serversFromGateway)), GE("FORCE_TURN_TCP") ? i2.iceTransportPolicy = "relay" : t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach((e3) => {
            e3.forceturn && (i2.iceTransportPolicy = "relay");
          }))), i2;
        }
        static turnServerConfigToIceServers(e3) {
          const t2 = [];
          return e3.forEach((e4) => {
            e4.security ? e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(VI(e4.turnServerURL), ":").concat(e4.tcpport, "?transport=tcp") }) : (e4.udpport && !GE("FORCE_TURN_TCP") && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.udpport, "?transport=udp") }), e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }));
          }), t2;
        }
        async applySendEncodings(e3, t2) {
          try {
            if (!JS().supportSetRtpSenderParameters)
              return;
            if (e3.length !== t2.length)
              return;
            for (let c2 = 0; c2 < e3.length; c2++) {
              const d2 = e3[c2], u2 = t2[c2];
              if (u2 && u2 instanceof Cy) {
                var i2, n2;
                if (this.isVP8Simulcast(u2))
                  continue;
                const e4 = {}, t3 = {};
                switch (u2._optimizationMode) {
                  case "motion":
                    e4.degradationPreference = "maintain-framerate";
                    break;
                  case "detail":
                    e4.degradationPreference = "maintain-resolution";
                    break;
                  default:
                    e4.degradationPreference = "balanced";
                }
                var r2, o2, s2, a2;
                if (null !== (i2 = u2._encoderConfig) && void 0 !== i2 && i2.bitrateMax)
                  t3.maxBitrate = 1e3 * (null === (r2 = u2._encoderConfig) || void 0 === r2 ? void 0 : r2.bitrateMax);
                if (u2._hints.includes(lS.LOW_STREAM))
                  null !== (o2 = u2._encoderConfig) && void 0 !== o2 && o2.frameRate && (t3.maxFramerate = FI(u2._encoderConfig.frameRate)), null !== (s2 = u2._encoderConfig) && void 0 !== s2 && s2.scaleResolutionDownBy && (null === (a2 = u2._encoderConfig) || void 0 === a2 ? void 0 : a2.scaleResolutionDownBy) > 1 && (t3.scaleResolutionDownBy = u2._encoderConfig.scaleResolutionDownBy);
                if (GE("DSCP_TYPE") && rp()) {
                  const e5 = GE("DSCP_TYPE");
                  ["very-low", "low", "medium", "high"].includes(e5) && (t3.networkPriority = e5);
                }
                const c3 = d2.sender.getParameters(), l2 = null === (n2 = c3.encodings) || void 0 === n2 ? void 0 : n2[0];
                Kh() && !l2 && (e4.encodings = [t3]), l2 && Object.assign(l2, t3), Object.assign(c3, e4), await d2.sender.setParameters(c3);
              }
            }
          } catch (e4) {
            OE.debug("Apply RTPSendEncodings failed.");
          }
        }
        mungSendOfferSDP(e3, t2, i2) {
          const n2 = UO.exports.parse(e3);
          return t2.forEach((e4, t3) => {
            const r2 = i2[t3], o2 = n2.mediaDescriptions.find((e5) => e5.attributes.mid === r2);
            o2 && (HO(o2, e4), XO(o2, e4, this.store.codec));
          }), UO.exports.print(n2);
        }
        mungReceiveAnswerSDP(e3, t2, i2) {
          const n2 = UO.exports.parse(e3), r2 = n2.mediaDescriptions.find((e4) => e4.attributes.mid === t2);
          return r2 && i2 === AS.AUDIO && "audio" === r2.media.mediaType && $O(r2), UO.exports.print(n2);
        }
        bindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = (e3) => {
            var t2;
            null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoReceived = (e3) => {
            var t2;
            null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstAudioDecoded = (e3) => {
            var t2;
            null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoDecoded = (e3, t2, i2) => {
            var n2;
            null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e3, t2, i2);
          }, this.statsFilter.onSelectedLocalCandidateChanged = (e3, t2) => {
            var i2;
            null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 || i2.call(this, e3, t2);
          }, this.statsFilter.onSelectedRemoteCandidateChanged = (e3, t2) => {
            var i2;
            null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 || i2.call(this, e3, t2);
          }, this.statsFilter.onFirstVideoDecodedTimeout = (e3) => {
            var t2;
            null === (t2 = this.onFirstVideoDecodedTimeout) || void 0 === t2 || t2.call(this, e3);
          };
        }
        unbindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
        }
        async applySimulcastForFirefox(e3, t2) {
          if (e3.length === t2.length)
            for (let s2 = 0; s2 < e3.length; s2++) {
              var i2, n2, r2, o2;
              const a2 = e3[s2], c2 = t2[s2];
              if (c2 instanceof Cy && !c2._hints.includes(lS.LOW_STREAM) && null !== (i2 = c2._encoderConfig) && void 0 !== i2 && i2.bitrateMax && (null === (n2 = c2._encoderConfig) || void 0 === n2 ? void 0 : n2.bitrateMax) > 200 && null !== (r2 = c2._scalabiltyMode) && void 0 !== r2 && r2.numSpatialLayers && (null === (o2 = c2._scalabiltyMode) || void 0 === o2 ? void 0 : o2.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
                const e4 = {}, t3 = { high: 1e3 * (c2._encoderConfig.bitrateMax - 50), medium: 5e4 };
                e4.encodings = [{ rid: "m", active: true, maxBitrate: t3.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: t3.high }];
                const i3 = a2.sender.getParameters();
                await a2.sender.setParameters(Object.assign(i3, e4));
              }
            }
        }
        async applySimulcastEncodings(e3, t2) {
          if (!Kh() && e3.length === t2.length)
            for (let i2 = 0; i2 < e3.length; i2++) {
              const n2 = t2[i2];
              if (n2 instanceof Cy && this.isVP8Simulcast(n2)) {
                const t3 = e3[i2], r2 = {}, o2 = { high: 1e3 * (n2._encoderConfig.bitrateMax - 50), medium: 5e4 };
                r2.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: o2.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: o2.medium, scaleResolutionDownBy: 4 }];
                const s2 = t3.sender.getParameters();
                await t3.sender.setParameters(Object.assign(s2, r2));
              }
            }
        }
        isVP8Simulcast(e3) {
          var t2, i2, n2, r2;
          return !!(e3 instanceof Cy && GE("SIMULCAST") && "vp8" === this.store.codec && !e3._hints.includes(lS.LOW_STREAM) && null !== (t2 = e3._encoderConfig) && void 0 !== t2 && t2.bitrateMax && (null === (i2 = e3._encoderConfig) || void 0 === i2 ? void 0 : i2.bitrateMax) > 200 && null !== (n2 = e3._scalabiltyMode) && void 0 !== n2 && n2.numSpatialLayers && (null === (r2 = e3._scalabiltyMode) || void 0 === r2 ? void 0 : r2.numSpatialLayers) > 1);
        }
        logSDPExchange(e3, t2, i2, n2) {
          if (GE("SDP_LOGGING"))
            return OE.upload("exchanging ".concat(i2, " ").concat(t2, " SDP during NVExtentionsConnection.").concat(n2, "\n"), e3), "offer" === t2 ? (e4) => {
              this.logSDPExchange(e4, "answer", "local" === i2 ? "remote" : "local", n2);
            } : void 0;
        }
        async getRemoteSSRC(e3) {
          if (!this.remoteSDP)
            return;
          const t2 = this.remoteSDP.getSSRC(e3);
          return null == t2 ? void 0 : t2[0].ssrcId;
        }
        setConfiguration(t2) {
          if (JS().supportPCSetConfiguration) {
            const i2 = e2.resolvePCConfiguration(t2);
            this.peerConnection.setConfiguration(i2);
          }
        }
      }).prototype, "connect", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "connect"), _b.prototype), ag(_b.prototype, "updateRemoteConnect", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "updateRemoteConnect"), _b.prototype), ag(_b.prototype, "receive", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "receive"), _b.prototype), ag(_b.prototype, "batchReceive", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "batchReceive"), _b.prototype), ag(_b.prototype, "stopReceiving", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "stopReceiving"), _b.prototype), ag(_b.prototype, "muteRemote", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "muteRemote"), _b.prototype), ag(_b.prototype, "unmuteRemote", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "unmuteRemote"), _b.prototype), ag(_b.prototype, "muteLocal", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "muteLocal"), _b.prototype), ag(_b.prototype, "unmuteLocal", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "unmuteLocal"), _b.prototype), ag(_b.prototype, "close", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "close"), _b.prototype), ag(_b.prototype, "updateEncoderConfig", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "updateEncoderConfig"), _b.prototype), ag(_b.prototype, "updateSendParameters", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "updateSendParameters"), _b.prototype), ag(_b.prototype, "replaceTrack", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "replaceTrack"), _b.prototype), ag(_b.prototype, "getRemoteSSRC", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "getRemoteSSRC"), _b.prototype), _b);
      function Sb(e2, t2, i2) {
        const n2 = e2[t2];
        if ("function" != typeof n2)
          throw new Error("Cannot use mutex on object property.");
        return i2.value = async function() {
          const e3 = this.mutex, i3 = await e3.lock("From NVExtentionsConnection.".concat(t2));
          try {
            for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++)
              o2[s2] = arguments[s2];
            return await n2.apply(this, o2);
          } finally {
            i3();
          }
        }, i2;
      }
      var Tb;
      function gb(e2) {
        var t2, i2, n2, r2 = 2;
        for ("undefined" != typeof Symbol && (i2 = MO, n2 = Symbol.iterator); r2--; ) {
          if (i2 && null != (t2 = e2[i2]))
            return t2.call(e2);
          if (n2 && null != (t2 = e2[n2]))
            return new Rb(t2.call(e2));
          i2 = "@@asyncIterator", n2 = "@@iterator";
        }
        throw new TypeError("Object is not async iterable");
      }
      function Rb(e2) {
        function t2(e3) {
          if (Object(e3) !== e3)
            return Sl.reject(new TypeError(e3 + " is not an object."));
          var t3 = e3.done;
          return Sl.resolve(e3.value).then(function(e4) {
            return { value: e4, done: t3 };
          });
        }
        return (Rb = function(e3) {
          this.s = e3, this.n = e3.next;
        }).prototype = { s: null, n: null, next: function() {
          return t2(this.n.apply(this.s, arguments));
        }, return: function(e3) {
          var i2 = this.s.return;
          return void 0 === i2 ? Sl.resolve({ value: e3, done: true }) : t2(i2.apply(this.s, arguments));
        }, throw: function(e3) {
          var i2 = this.s.return;
          return void 0 === i2 ? Sl.reject(e3) : t2(i2.apply(this.s, arguments));
        } }, new Rb(e2);
      }
      let Ib = (ag((Tb = class e2 extends YS {
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        constructor(t2, i2) {
          super(t2, i2), _p(this, "store", void 0), _p(this, "peerConnection", void 0), _p(this, "cname", void 0), _p(this, "mutex", new Ug("DataChannelConnection-mutex")), _p(this, "dataChannel", void 0), _p(this, "_p2pConnection", void 0), _p(this, "establishPromise", void 0), _p(this, "_nvMedia", void 0), this.store = i2, this.store.dcId = this.store.dcId + 1, this.peerConnection = new RTCPeerConnection(e2.resolvePCConfiguration(t2), { optional: [{ googDscp: true }] }), this.dataChannel = this.peerConnection.createDataChannel("agora-signal", { ordered: false, maxPacketLifeTime: 50 }), this.dataChannel.binaryType = "arraybuffer", this._p2pConnection = new fb(t2, i2, this.peerConnection), this.bindPCEvents(), this.establishPromise = this._p2pConnection.establishPromise;
        }
        async establish() {
          var e3;
          const t2 = null === (e3 = this._nvMedia) || void 0 === e3 ? void 0 : e3.getLocalRtpCapabilities();
          return await this._p2pConnection.establish(t2);
        }
        getP2PConnectionParams() {
          return this._p2pConnection.getP2PConnectionParams();
        }
        async connect(e3, t2, i2, n2, r2, o2) {
          return this.cname = o2, await this._p2pConnection.connect(e3, t2, i2, n2, r2, o2), await new Sl((e4, t3) => {
            const n3 = setTimeout(() => {
              this.closeSignal(), t3(new SE(fE.DATACHANNEL_CONNECTION_TIMEOUT, "Datachannel connection timed out, candidates: ".concat(JSON.stringify(i2))));
            }, 2e3);
            this.dataChannel.onopen = () => {
              if ("open" === this.dataChannel.readyState)
                return clearTimeout(n3), void e4();
            }, this.dataChannel.onerror = (e5) => {
              this.closeSignal(), t3(e5);
            };
          }), { transmitter: this.dataChannel, close: this.closeSignal.bind(this) };
        }
        send(e3, t2, i2) {
          var n2 = this;
          return DO(function* () {
            const r2 = yield PO(n2.mutex.lock("From DataChannelConnection.send"));
            try {
              return yield* kO(gb(n2._p2pConnection.send(e3, t2, i2)), PO);
            } finally {
              r2();
            }
          })();
        }
        async stopSending(e3, t2) {
          return this._p2pConnection.stopSending(e3, t2);
        }
        async receive(e3, t2, i2, n2) {
          return this._nvMedia ? (OE.debug("[DataChannelConnection] receive ".concat(e3, " by DataChannel.")), await this._nvMedia.reveiveByRTCMedia(e3, t2, this.cname)) : (OE.debug("[DataChannelConnection] receive ".concat(e3, " by WebRTC.")), await this._p2pConnection.receive(e3, t2, i2, n2));
        }
        async batchReceive(e3) {
          return [...await this._p2pConnection.batchReceive(e3)];
        }
        async stopReceiving(e3) {
          return await this._p2pConnection.stopReceiving(e3);
        }
        async muteRemote(e3) {
          return await this._p2pConnection.muteRemote(e3);
        }
        async unmuteRemote(e3) {
          return await this._p2pConnection.unmuteRemote(e3);
        }
        async muteLocal(e3) {
          return await this._p2pConnection.muteLocal(e3);
        }
        async unmuteLocal(e3) {
          return await this._p2pConnection.unmuteLocal(e3);
        }
        restartICE(e3) {
          var t2 = this;
          return DO(function* () {
            return yield* kO(gb(t2._p2pConnection.restartICE(e3)), PO);
          })();
        }
        close() {
          var e3;
          null === (e3 = this._nvMedia) || void 0 === e3 || e3.close(), this._p2pConnection.close(), this.unbindConnectionEvents(this._p2pConnection);
        }
        getStats() {
          return this._p2pConnection.getStats();
        }
        getRemoteVideoIsReady(e3) {
          return this._p2pConnection.getRemoteVideoIsReady(e3);
        }
        updateRemoteConnect(e3) {
          var t2;
          null === (t2 = this._nvMedia) || void 0 === t2 || t2.setRemoteRtpCapabilities(e3), this._p2pConnection.updateRemoteConnect(e3);
        }
        async updateEncoderConfig(e3, t2) {
          return await this._p2pConnection.updateEncoderConfig(e3, t2);
        }
        async updateSendParameters(e3, t2) {
          return await this._p2pConnection.updateSendParameters(e3, t2);
        }
        setStatsRemoteVideoIsReady(e3, t2) {
          this._p2pConnection.setStatsRemoteVideoIsReady(e3, t2);
        }
        async replaceTrack(e3, t2) {
          return await this._p2pConnection.replaceTrack(e3, t2);
        }
        async getRemoteSSRC(e3) {
          return this._p2pConnection.getRemoteSSRC(e3);
        }
        logSDPExchange(e3, t2, i2, n2) {
          if (GE("SDP_LOGGING"))
            return OE.upload("exchanging ".concat(i2, " ").concat(t2, " SDP during DataChannelConnection.").concat(n2, "\n"), e3), "offer" === t2 ? (e4) => {
              this.logSDPExchange(e4, "answer", "local" === i2 ? "remote" : "local", n2);
            } : void 0;
        }
        static resolvePCConfiguration(t2) {
          const i2 = { iceServers: [] };
          return t2.iceServers ? i2.iceServers = t2.iceServers : t2.turnServer && "off" !== t2.turnServer.mode && (Uf(t2.turnServer.servers) ? i2.iceServers = t2.turnServer.servers : (i2.iceServers && i2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.servers)), GE("USE_TURN_SERVER_OF_GATEWAY") && i2.iceServers && t2.turnServer.serversFromGateway && i2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.serversFromGateway)), GE("FORCE_TURN_TCP") ? i2.iceTransportPolicy = "relay" : t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach((e3) => {
            e3.forceturn && (i2.iceTransportPolicy = "relay");
          }))), i2;
        }
        static turnServerConfigToIceServers(e3) {
          const t2 = [];
          return e3.forEach((e4) => {
            e4.security ? e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(VI(e4.turnServerURL), ":").concat(e4.tcpport, "?transport=tcp") }) : (e4.udpport && !GE("FORCE_TURN_TCP") && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.udpport, "?transport=udp") }), e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }));
          }), t2;
        }
        bindPCEvents() {
          this._p2pConnection.onICEConnectionStateChange = (e3) => {
            var t2;
            return null === (t2 = this.onICEConnectionStateChange) || void 0 === t2 ? void 0 : t2.call(this, e3);
          }, this._p2pConnection.onConnectionStateChange = (e3) => {
            var t2;
            return null === (t2 = this.onConnectionStateChange) || void 0 === t2 ? void 0 : t2.call(this, e3);
          }, this._p2pConnection.onDTLSTransportStateChange = (e3) => {
            var t2;
            return null === (t2 = this.onDTLSTransportStateChange) || void 0 === t2 ? void 0 : t2.call(this, e3);
          }, this._p2pConnection.onDTLSTransportError = (e3) => {
            var t2;
            return null === (t2 = this.onDTLSTransportError) || void 0 === t2 ? void 0 : t2.call(this, e3);
          }, this._p2pConnection.onICETransportStateChange = (e3) => {
            var t2;
            return null === (t2 = this.onICETransportStateChange) || void 0 === t2 ? void 0 : t2.call(this, e3);
          }, this._p2pConnection.onFirstAudioReceived = (e3) => {
            var t2;
            return null === (t2 = this.onFirstAudioReceived) || void 0 === t2 ? void 0 : t2.call(this, e3);
          }, this._p2pConnection.onFirstVideoReceived = (e3) => {
            var t2;
            return null === (t2 = this.onFirstVideoReceived) || void 0 === t2 ? void 0 : t2.call(this, e3);
          }, this._p2pConnection.onFirstAudioDecoded = (e3) => {
            var t2;
            return null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 ? void 0 : t2.call(this, e3);
          }, this._p2pConnection.onFirstVideoDecoded = (e3, t2, i2) => {
            var n2;
            return null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 ? void 0 : n2.call(this, e3, t2, i2);
          }, this._p2pConnection.onFirstVideoDecodedTimeout = (e3) => {
            var t2;
            return null === (t2 = this.onFirstVideoDecodedTimeout) || void 0 === t2 ? void 0 : t2.call(this, e3);
          }, this._p2pConnection.onSelectedLocalCandidateChanged = (e3, t2) => {
            var i2;
            return null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 ? void 0 : i2.call(this, e3, t2);
          }, this._p2pConnection.onSelectedRemoteCandidateChanged = (e3, t2) => {
            var i2;
            return null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 ? void 0 : i2.call(this, e3, t2);
          };
        }
        closeSignal() {
          this.dataChannel.close(), this.peerConnection.close();
        }
        unbindConnectionEvents(e3) {
          e3.onConnectionStateChange = void 0, e3.onICEConnectionStateChange = void 0, e3.onICETransportStateChange = void 0, e3.onDTLSTransportStateChange = void 0, e3.onDTLSTransportError = void 0, e3.onFirstAudioDecoded = void 0, e3.onFirstAudioReceived = void 0, e3.onFirstVideoDecoded = void 0, e3.onFirstVideoReceived = void 0, e3.onSelectedLocalCandidateChanged = void 0, e3.onSelectedRemoteCandidateChanged = void 0, e3.onFirstVideoDecodedTimeout = void 0;
        }
        setConfiguration(e3) {
          this._p2pConnection.setConfiguration(e3);
        }
      }).prototype, "connect", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "connect"), Tb.prototype), ag(Tb.prototype, "receive", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "receive"), Tb.prototype), ag(Tb.prototype, "stopReceiving", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "stopReceiving"), Tb.prototype), ag(Tb.prototype, "muteRemote", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "muteRemote"), Tb.prototype), ag(Tb.prototype, "unmuteRemote", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "unmuteRemote"), Tb.prototype), ag(Tb.prototype, "muteLocal", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "muteLocal"), Tb.prototype), ag(Tb.prototype, "unmuteLocal", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "unmuteLocal"), Tb.prototype), ag(Tb.prototype, "close", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "close"), Tb.prototype), ag(Tb.prototype, "updateEncoderConfig", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "updateEncoderConfig"), Tb.prototype), ag(Tb.prototype, "updateSendParameters", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "updateSendParameters"), Tb.prototype), ag(Tb.prototype, "replaceTrack", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "replaceTrack"), Tb.prototype), ag(Tb.prototype, "getRemoteSSRC", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "getRemoteSSRC"), Tb.prototype), Tb);
      function Cb(e2, t2, i2) {
        const n2 = e2[t2];
        if ("function" != typeof n2)
          throw new Error("Cannot use mutex on object property.");
        return i2.value = async function() {
          const e3 = this.mutex, i3 = await e3.lock("From DataChannelConnection.".concat(t2));
          try {
            for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++)
              o2[s2] = arguments[s2];
            return await n2.apply(this, o2);
          } finally {
            i3();
          }
        }, i2;
      }
      var vb;
      function yb(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function Ab(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? yb(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : yb(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      function Ob(e2) {
        var t2, i2, n2, r2 = 2;
        for ("undefined" != typeof Symbol && (i2 = MO, n2 = Symbol.iterator); r2--; ) {
          if (i2 && null != (t2 = e2[i2]))
            return t2.call(e2);
          if (n2 && null != (t2 = e2[n2]))
            return new Nb(t2.call(e2));
          i2 = "@@asyncIterator", n2 = "@@iterator";
        }
        throw new TypeError("Object is not async iterable");
      }
      function Nb(e2) {
        function t2(e3) {
          if (Object(e3) !== e3)
            return Sl.reject(new TypeError(e3 + " is not an object."));
          var t3 = e3.done;
          return Sl.resolve(e3.value).then(function(e4) {
            return { value: e4, done: t3 };
          });
        }
        return (Nb = function(e3) {
          this.s = e3, this.n = e3.next;
        }).prototype = { s: null, n: null, next: function() {
          return t2(this.n.apply(this.s, arguments));
        }, return: function(e3) {
          var i2 = this.s.return;
          return void 0 === i2 ? Sl.resolve({ value: e3, done: true }) : t2(i2.apply(this.s, arguments));
        }, throw: function(e3) {
          var i2 = this.s.return;
          return void 0 === i2 ? Sl.reject(e3) : t2(i2.apply(this.s, arguments));
        } }, new Nb(e2);
      }
      let bb = (ag((vb = class extends EE {
        get state() {
          return this._state;
        }
        set state(e2) {
          const t2 = this._state;
          this._state = e2, this.emit(DS.StateChange, t2, this._state);
        }
        constructor(e2, t2) {
          super(), _p(this, "store", void 0), _p(this, "statsUploader", void 0), _p(this, "connection", void 0), _p(this, "localTrackMap", /* @__PURE__ */ new Map()), _p(this, "remoteUserMap", /* @__PURE__ */ new Map()), _p(this, "pendingLocalTracks", []), _p(this, "pendingRemoteTracks", []), _p(this, "statsCollector", void 0), _p(this, "isPlanB", false), _p(this, "shouldForwardP2PCreation", void 0), _p(this, "iceFailedCount", 0), _p(this, "dtlsFailedCount", 0), _p(this, "mutex", new Ug("P2PChannel-mutex")), _p(this, "_state", wS.Disconnected), _p(this, "_pcStatsUploadType", GE("NEW_ICE_RESTART") ? NS.FIRST_CONNECTION : NS.OLD_FIRST_CONNECTION), _p(this, "_isInRestartIce", false), _p(this, "_isStartRestartIce", false), _p(this, "_restartStates", ["disconnected", "failed"]), _p(this, "_restartTimer", void 0), _p(this, "_isFirstConnected", true), _p(this, "handleMuteLocalTrack", async (e3, t3, i2) => {
            const n2 = await this.mutex.lock("Locking from P2PChannel.handleMuteLocalTrack");
            try {
              if (!this.connection || this.state !== wS.Connected)
                return void i2(new SE(fE.INVALID_OPERATION, "Cannot call P2PChannel.handleMuteLocalTrack before connection established."));
              const r2 = this.filterTobeMutedTracks(e3);
              if (0 === r2.length)
                return void t3();
              const o2 = r2.find((e4) => "videoLowTrack" === e4[0]);
              if (o2) {
                o2[1].track._originMediaStreamTrack.stop();
              }
              await this.connection.muteLocal(r2.map((e4) => {
                let [, { id: t4 }] = e4;
                return t4;
              }));
              const s2 = this.createMuteMessage(r2);
              await rC(this, DS.RequestMuteLocal, s2), t3();
            } catch (e4) {
              i2(e4);
            } finally {
              n2();
            }
          }), _p(this, "handleUnmuteLocalTrack", async (e3, t3, i2) => {
            const n2 = await this.mutex.lock("Locking from P2PChannel.handleUnmuteLocalTrack");
            try {
              if (!this.connection || this.state !== wS.Connected)
                return void i2(new SE(fE.INVALID_OPERATION, "Cannot call P2PChannel.handleUnmuteLocalTrack before connection established."));
              const r2 = this.filterTobeUnmutedTracks(e3);
              if (0 === r2.length)
                return void t3();
              const o2 = r2.find((e4) => "videoLowTrack" === e4[0]);
              if (o2) {
                const t4 = o2[1];
                if (t4.track._originMediaStreamTrack.stop(), JS().supportDualStreamEncoding) {
                  const i3 = e3._mediaStreamTrack.clone();
                  t4.track._mediaStreamTrack = i3, t4.track._originMediaStreamTrack = i3;
                } else {
                  const i3 = FN(e3, sC(this, DS.RequestLowStreamParameter));
                  t4.track._mediaStreamTrack = i3, t4.track._originMediaStreamTrack = i3;
                }
                await new Sl((e4, i3) => {
                  this.handleReplaceTrack(t4.track, e4, i3, true);
                });
              }
              await this.connection.unmuteLocal(r2.map((e4) => {
                let [, { id: t4 }] = e4;
                return t4;
              }));
              const s2 = this.createUnmuteMessage(r2);
              await rC(this, DS.RequestUnmuteLocal, s2), t3();
            } catch (e4) {
              i2(e4);
            } finally {
              n2();
            }
          }), _p(this, "handleUpdateVideoEncoder", async (e3, t3, i2) => {
            const n2 = await this.mutex.lock("Locking from P2PChannel.handleSetVideoEncoder");
            try {
              const i3 = this.localTrackMap.get(bS.LocalVideoTrack);
              if (!this.connection || !i3 || i3.track !== e3 || this.state !== wS.Connected)
                return void t3();
              const { id: r2, track: o2 } = i3;
              await this.connection.updateSendParameters(r2, o2), await this.connection.updateEncoderConfig(r2, o2), this.emit(DS.UpdateVideoEncoder, o2), t3();
            } catch (e4) {
              i2(e4);
            } finally {
              n2();
            }
          }), _p(this, "handleSetOptimizationMode", async (e3, t3, i2) => {
            const n2 = await this.mutex.lock("Locking from P2PChannel.handleSetOptimizationMode");
            try {
              const i3 = this.localTrackMap.get(bS.LocalVideoTrack);
              if (!this.connection || !i3 || i3.track !== e3 || this.state !== wS.Connected)
                return;
              const { id: r2, track: o2 } = i3;
              await this.connection.updateSendParameters(r2, o2), t3();
            } catch (e4) {
              i2(e4);
            } finally {
              n2();
            }
          }), _p(this, "handleReplaceTrack", async (e3, t3, i2, n2) => {
            let r2;
            OE.debug("[".concat(this.store.clientId, "] P2PChannel handleReplaceTrack for [track-id-").concat(e3.getTrackId(), "]")), "boolean" == typeof n2 && n2 || (r2 = await this.mutex.lock("From P2PChannel.handleReplaceTrack"));
            try {
              var o2;
              const i3 = Array.from(this.localTrackMap.entries()).find((t4) => {
                let [, { track: i4 }] = t4;
                return e3 === i4;
              });
              if (!this.connection || !i3 || this.state !== wS.Connected)
                return void t3();
              if (await (null === (o2 = this.connection) || void 0 === o2 ? void 0 : o2.replaceTrack(e3, i3[1].id)), this.isPlanB) {
                const t4 = i3[1];
                t4.id = e3._mediaStreamTrack.id, this.localTrackMap.set(i3[0], t4);
              }
              if (i3[0] === bS.LocalVideoTrack && JS().supportDualStreamEncoding) {
                const t4 = this.localTrackMap.get(bS.LocalVideoLowTrack);
                if (t4) {
                  const i4 = e3._mediaStreamTrack.clone();
                  t4.track._originMediaStreamTrack.stop(), t4.track._mediaStreamTrack = i4, t4.track._originMediaStreamTrack = i4, await new Sl((e4, i5) => {
                    this.handleReplaceTrack(t4.track, e4, i5, true);
                  });
                }
              }
              t3();
            } catch (e4) {
              i2(e4);
            } finally {
              var s2;
              null === (s2 = r2) || void 0 === s2 || s2();
            }
          }), _p(this, "handleGetLocalVideoStats", (e3) => {
            e3(this.statsCollector.getLocalVideoTrackStats());
          }), _p(this, "handleGetLocalAudioStats", (e3) => {
            e3(this.statsCollector.getLocalAudioTrackStats());
          }), _p(this, "handleGetRemoteVideoStats", (e3) => this.statsCollector.getRemoteVideoTrackStats(e3.uid)[e3.uid]), _p(this, "handleGetRemoteAudioStats", (e3) => this.statsCollector.getRemoteAudioTrackStats(e3.uid)[e3.uid]), this.store = e2, this.statsCollector = t2, this.statsCollector.addP2PChannel(this), this.statsUploader = new sb(), this.bindStatsUploaderEvents(), this.isPlanB = !JS().supportUnifiedPlan || GE("CHROME_FORCE_PLAN_B") && rp(), this.shouldForwardP2PCreation = GE("FORWARD_P2P_CREATION") && JS().supportPCSetConfiguration, this.shouldForwardP2PCreation && (this.connection = this.store.useDataChannel ? new Ib({}, this.store) : this.isPlanB ? new NN({}, this.store) : new VN({}, this.store), this.bindConnectionEvents(this.connection));
        }
        async startP2PConnection(e2, t2) {
          var i2;
          this.state = wS.New;
          const n2 = this.shouldForwardP2PCreation && "closed" === (null === (i2 = this.connection) || void 0 === i2 ? void 0 : i2.peerConnectionState);
          if (this.shouldForwardP2PCreation && !n2 || (n2 && this.connection && (OE.warning("[".concat(this.store.clientId, "] P2PChannel.startP2PConnection ForwardP2P closed.")), this.connection.close(), this.unbindConnectionEvents(this.connection)), this.connection = this.store.useDataChannel ? new Ib(e2, this.store) : this.isPlanB ? new NN(e2, this.store) : new VN(e2, this.store), this.bindConnectionEvents(this.connection)), !this.connection)
            throw new SE(fE.UNEXPECTED_ERROR, "Cannot P2PChannel.startConnection before P2PConnection initialization .");
          return this._pcStatsUploadType = GE("NEW_ICE_RESTART") ? NS.FIRST_CONNECTION : NS.OLD_FIRST_CONNECTION, this._isFirstConnected = true, this._isInRestartIce = false, this._isStartRestartIce = false, this.connection.setConfiguration(e2), this.connection.establishPromise;
        }
        async connect(e2, t2, i2, n2, r2, o2) {
          if (!this.connection)
            throw new SE(fE.UNEXPECTED_ERROR, "Cannot P2PChannel.connect before P2PChannel.startP2PConnection .");
          this.connection instanceof Ib ? this.connection.updateRemoteConnect(n2) : (this.store.peerConnectionStart(), await this.connection.connect(e2, t2, i2, n2, r2, o2), this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = wS.Connected);
        }
        async preConnect(e2, t2, i2, n2, r2, o2) {
          if (!this.connection)
            throw new SE(fE.UNEXPECTED_ERROR, "Cannot P2PChannel.connect before P2PChannel.startP2PConnection .");
          this.store.peerConnectionStart();
          const s2 = await this.connection.connect(e2, t2, i2, n2, r2, o2);
          return this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = wS.Connected, s2;
        }
        getEstablishParams() {
          if (this.connection instanceof Ib)
            return this.connection.getP2PConnectionParams();
          throw new Error("Only DataChannelConnection needs to obtain establishParams");
        }
        publish(e2, t2, i2) {
          var n2 = this;
          return DO(function* () {
            const r2 = yield PO(n2.mutex.lock("From P2PChannel.publish"));
            try {
              if (!n2.connection || n2.state !== wS.Connected) {
                if (n2.state === wS.Disconnected)
                  throw new SE(fE.UNEXPECTED_ERROR, "PeerConnection already disconnected.");
                n2.throwIfTrackTypeNotMatch(e2);
                const t3 = e2.filter((e3) => -1 === n2.pendingLocalTracks.indexOf(e3));
                return void (n2.pendingLocalTracks = n2.pendingLocalTracks.concat(t3));
              }
              n2.store.pubId = n2.store.pubId + 1, DI.markPublishStart(n2.store.clientId, n2.store.pubId);
              const o2 = n2.filterTobePublishedTracks(e2, t2, i2);
              if (0 === o2.length)
                return void (yield PO(n2.tryToUnmuteAudio(e2)));
              yield* kO(Ob(n2.doPublish(n2.connection, o2)), PO);
            } finally {
              r2();
            }
          })();
        }
        doPublish(e2, t2) {
          var i2 = this;
          return DO(function* () {
            t2.forEach((e3) => {
              let { track: t3, type: n3 } = e3;
              const r3 = Date.now();
              i2.store.publish(t3.getTrackId(), n3 === bS.LocalAudioTrack ? "audio" : "video", r3);
            }), i2.bindLocalTrackEvents(t2);
            const n2 = yield PO(e2.send(t2.map((e3) => {
              let { track: t3 } = e3;
              return t3;
            }), i2.store.codec, i2.store.audioCodec)), r2 = (yield PO(n2.next())).value, o2 = i2.createGatewayPublishMessage(t2, r2);
            let s2;
            try {
              s2 = yield o2;
            } catch (e3) {
              throw n2.throw(e3), (null == e3 ? void 0 : e3.code) === fE.WS_ABORT && t2.forEach((e4) => {
                let { track: t3 } = e4;
                -1 === i2.pendingLocalTracks.indexOf(t3) && i2.pendingLocalTracks.push(t3);
              }), i2.unbindLocalTrackEvents(t2), e3;
            }
            const a2 = i2.mapPubResToRemoteConfig(o2, s2), c2 = (yield PO(n2.next(a2))).value;
            t2.forEach((e3) => {
              let { type: t3 } = e3;
              i2.statsCollector.addLocalStats(t3);
            }), i2.assignLocalTracks(t2, c2), i2.statsUploader.startUploadUplinkStats(), t2.forEach((e3) => {
              let { track: t3, type: n3 } = e3;
              const r3 = Date.now();
              i2.store.publish(t3.getTrackId(), n3 === bS.LocalAudioTrack ? "audio" : "video", void 0, r3);
            });
          })();
        }
        publishLowStream(e2) {
          var t2 = this;
          return DO(function* () {
            if (!t2.connection || t2.state !== wS.Connected)
              return;
            const i2 = yield PO(t2.mutex.lock("Locking from P2PChannel.publishLowStream"));
            try {
              const r2 = t2.localTrackMap.get(bS.LocalVideoTrack);
              if (!r2)
                throw new SE(fE.UNEXPECTED_ERROR, "Could not find high stream");
              if (t2.localTrackMap.has(bS.LocalVideoLowTrack))
                throw new SE(fE.UNEXPECTED_ERROR, "[".concat(t2.store.clientId, "] Can't publish low stream when stream already publish"));
              const o2 = [{ track: t2.getLowVideoTrack(r2.track, e2), type: bS.LocalVideoLowTrack }];
              if (yield* kO(Ob(t2.doPublish(t2.connection, o2)), PO), r2.track.muted || !r2.track.enabled) {
                var n2;
                const e3 = null === (n2 = t2.localTrackMap.get(bS.LocalVideoLowTrack)) || void 0 === n2 ? void 0 : n2.id;
                void 0 !== e3 && (yield PO(t2.connection.muteLocal([e3])));
              }
            } finally {
              i2();
            }
          })();
        }
        async republish() {
          this.pendingLocalTracks.length > 0 && (OE.debug("[".concat(this.store.clientId, "] Emit P2PChannelEvents.RequestRePublish to republish tracks.")), await nC(this, DS.RequestRePublish, this.pendingLocalTracks), this.emit(DS.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = []);
        }
        async reSubscribe(e2) {
          for (let e3 = this.pendingRemoteTracks.length - 1; e3 >= 0; e3--) {
            const { user: t2, kind: i2 } = this.pendingRemoteTracks[e3];
            (i2 !== AS.AUDIO || t2._audio_added_ && t2._audioSSRC) && (i2 !== AS.VIDEO || t2._video_added_ && t2._videoSSRC) || this.pendingRemoteTracks.splice(e3, 1);
          }
          if (e2)
            await nC(this, DS.RequestReSubscribe, this.pendingRemoteTracks);
          else
            for (const { user: e3, kind: t2 } of this.pendingRemoteTracks)
              await this.subscribe(e3, t2, t2 === AS.VIDEO ? e3._videoSSRC : e3._audioSSRC);
          this.pendingRemoteTracks.forEach((e3) => {
            let { user: t2 } = e3;
            this.emit(DS.MediaReconnectEnd, t2.uid);
          }), this.pendingRemoteTracks = [];
        }
        async unpublish(e2) {
          if (!this.connection || this.state !== wS.Connected)
            return void e2.forEach((e3) => {
              const t3 = this.pendingLocalTracks.indexOf(e3);
              -1 !== t3 && this.pendingLocalTracks.splice(t3, 1);
            });
          const t2 = this.filterTobeUnpublishedTracks(e2);
          if (0 === t2.length)
            return;
          const i2 = t2.find((e3) => "videoLowTrack" === e3[0]);
          if (i2) {
            i2[1].track.close();
          }
          return this.doUnpublish(this.connection, t2);
        }
        async unpublishLowStream() {
          if (!this.connection || this.state !== wS.Connected)
            return;
          const e2 = this.localTrackMap.get(bS.LocalVideoLowTrack);
          if (!e2)
            return;
          e2.track.close();
          const t2 = [[bS.LocalVideoLowTrack, e2]];
          return this.doUnpublish(this.connection, t2);
        }
        async doUnpublish(e2, t2) {
          const i2 = this.createGatewayUnpublishMessage(t2);
          return await e2.stopSending(t2.map((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          })), this.withdrawLocalTracks(t2), this.unbindLocalTrackEvents(t2.map((e3) => {
            let [t3, { track: i3 }] = e3;
            return { type: t3, track: i3 };
          })), t2.forEach((e3) => {
            let [t3] = e3;
            this.statsCollector.removeLocalStats(t3);
          }), 0 === this.localTrackMap.size && this.statsUploader.stopUploadUplinkStats(), i2;
        }
        async subscribe(e2, t2, i2, n2, r2) {
          var o2;
          if (!this.connection || this.state !== wS.Connected)
            throw new SE(fE.INVALID_OPERATION, "Cannot subscribe remote user when peerConnection disconnected.");
          if (null !== (o2 = this.remoteUserMap.get(e2)) && void 0 !== o2 && o2.has(t2))
            return;
          let s2, a2, c2 = void 0;
          if (r2) {
            const i3 = r2.find((e3) => {
              let { stream_type: i4 } = e3;
              return i4 === t2;
            });
            if (!i3)
              throw new SE(fE.UNEXPECTED_ERROR, "Cannot subscribe to remote ".concat(t2, " for user: ").concat(e2.uid, " because subscribe answer from gateway does not contain stream_type: ").concat(t2, "."));
            const n3 = await this.connection.receive(t2, i3.ssrcs, String(e2._uintid), i3.attributes);
            this.connection instanceof VN && (c2 = n3.transceiver), s2 = n3.track, a2 = n3.id;
          } else {
            const r3 = await this.connection.receive(t2, [{ ssrcId: i2, rtx: n2 }], String(e2._uintid), void 0);
            this.connection instanceof VN && (c2 = r3.transceiver), s2 = r3.track, a2 = r3.id;
          }
          t2 === AS.AUDIO ? (e2._audioTrack ? e2._audioTrack._updateOriginMediaStreamTrack(s2) : (e2._audioTrack = new nb(s2, e2.uid, e2._uintid, this.store), OE.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(e2._audioTrack.getTrackId()))), c2 && e2._audioTrack._updateRtpTransceiver(c2), this.bindRemoteTrackEvents(e2, e2._audioTrack)) : (e2._videoTrack ? e2._videoTrack._updateOriginMediaStreamTrack(s2) : (e2._videoTrack = new ib(s2, e2.uid, e2._uintid, this.store), OE.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(e2._videoTrack.getTrackId()))), c2 && e2._videoTrack._updateRtpTransceiver(c2), this.bindRemoteTrackEvents(e2, e2._videoTrack));
          const d2 = this.remoteUserMap.get(e2);
          d2 ? d2.set(t2, a2) : this.remoteUserMap.set(e2, /* @__PURE__ */ new Map([[t2, a2]])), this.statsCollector.addRemoteStats(e2.uid), this.statsUploader.startUploadDownlinkStats();
          const u2 = this.pendingRemoteTracks.findIndex((i3) => {
            let { user: n3, kind: r3 } = i3;
            return n3.uid === e2.uid && t2 === r3;
          });
          -1 !== u2 && (this.pendingRemoteTracks.splice(u2, 1), this.emit(DS.MediaReconnectEnd, e2.uid));
        }
        async massSubscribe(e2) {
          return this.massSubscribeNoLock(e2);
        }
        async massSubscribeNoLock(e2) {
          if (!this.connection || this.state !== wS.Connected)
            throw new SE(fE.INVALID_OPERATION, "Cannot subscribeAll remote users when peerConnection disconnected.");
          e2 = e2.filter((e3) => {
            var t3;
            let { user: i2, mediaType: n2 } = e3;
            return !(null !== (t3 = this.remoteUserMap.get(i2)) && void 0 !== t3 && t3.has(n2));
          });
          const t2 = await this.connection.batchReceive(e2.map((e3) => {
            let { user: t3, mediaType: i2, ssrcId: n2, rtxSsrcId: r2 } = e3;
            return { kind: i2, ssrcMsg: [{ ssrcId: n2, rtx: r2 }], mslabel: String(t3._uintid) };
          }));
          e2.forEach((e3, i2) => {
            let { user: n2, mediaType: r2 } = e3;
            const { track: o2, id: s2, transceiver: a2 } = t2[i2];
            r2 === AS.AUDIO ? (n2._audioTrack ? n2._audioTrack._updateOriginMediaStreamTrack(o2) : (n2._audioTrack = new nb(o2, n2.uid, n2._uintid, this.store), OE.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(n2._audioTrack.getTrackId()))), a2 && n2._audioTrack._updateRtpTransceiver(a2), this.bindRemoteTrackEvents(n2, n2._audioTrack)) : (n2._videoTrack ? n2._videoTrack._updateOriginMediaStreamTrack(o2) : (n2._videoTrack = new ib(o2, n2.uid, n2._uintid, this.store), OE.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(n2._videoTrack.getTrackId()))), a2 && n2._videoTrack._updateRtpTransceiver(a2), this.bindRemoteTrackEvents(n2, n2._videoTrack));
            const c2 = this.remoteUserMap.get(n2);
            c2 ? c2.set(r2, s2) : this.remoteUserMap.set(n2, /* @__PURE__ */ new Map([[r2, s2]])), this.statsCollector.addRemoteStats(n2.uid), this.statsUploader.startUploadDownlinkStats();
            const d2 = this.pendingRemoteTracks.findIndex((e4) => {
              let { user: t3, kind: i3 } = e4;
              return t3.uid === n2.uid && r2 === i3;
            });
            -1 !== d2 && (this.pendingRemoteTracks.splice(d2, 1), this.emit(DS.MediaReconnectEnd, n2.uid));
          });
        }
        async unsubscribe(e2, t2, i2) {
          const n2 = this.pendingRemoteTracks.filter((i3) => {
            let { user: n3, kind: r3 } = i3;
            return void 0 !== t2 ? n3.uid === e2.uid && t2 === r3 : n3.uid === e2.uid;
          });
          if (n2.forEach((e3) => {
            const t3 = this.pendingRemoteTracks.indexOf(e3);
            this.pendingRemoteTracks.splice(t3, 1);
          }), this.connection && this.state === wS.Connected || i2 || n2.forEach((t3) => {
            let { kind: i3 } = t3;
            var n3;
            if (i3 === AS.AUDIO)
              null === (n3 = e2._audioTrack) || void 0 === n3 || n3._destroy(), e2._audioTrack = void 0;
            else if (i3 === AS.VIDEO) {
              var r3;
              null === (r3 = e2._videoTrack) || void 0 === r3 || r3._destroy(), e2._videoTrack = void 0;
            }
          }), !this.connection || this.state !== wS.Connected)
            return;
          const r2 = this.filterTobeUnSubscribedTracks(e2, t2);
          if (0 === r2.length)
            return;
          await this.connection.stopReceiving(r2.map((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          }));
          const o2 = this.createUnsubscribeMessage(r2);
          return this.withdrawRemoteTracks(r2), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadDownlinkStats(), r2.forEach((e3) => {
            let [t3, { kind: n3 }] = e3;
            var r3, o3;
            n3 === AS.VIDEO && t3._videoSSRC && (null === (r3 = this.connection) || void 0 === r3 || r3.setStatsRemoteVideoIsReady(t3._videoSSRC, false));
            if (n3 === AS.VIDEO)
              this.unbindRemoteTrackEvents(t3._videoTrack), i2 || (null === (o3 = t3._videoTrack) || void 0 === o3 || o3._destroy(), t3._videoTrack = void 0);
            else if (n3 === AS.AUDIO) {
              var s2;
              if (this.unbindRemoteTrackEvents(t3._audioTrack), !i2)
                null === (s2 = t3._audioTrack) || void 0 === s2 || s2._destroy(), t3._audioTrack = void 0;
            }
          }), o2;
        }
        async massUnsubscribe(e2) {
          return this.massUnsubscribeNoLock(e2);
        }
        async massUnsubscribeNoLock(e2) {
          let t2 = [];
          for (const { user: i3, mediaType: n3 } of e2) {
            const e3 = this.pendingRemoteTracks.filter((e4) => {
              let { user: t3, kind: r2 } = e4;
              return void 0 !== n3 ? t3.uid === i3.uid && n3 === r2 : t3.uid === i3.uid;
            });
            e3.forEach((e4) => {
              const t3 = this.pendingRemoteTracks.indexOf(e4);
              this.pendingRemoteTracks.splice(t3, 1);
            }), t2 = t2.concat(e3);
          }
          if (!this.connection || this.state !== wS.Connected)
            return void t2.forEach((e3) => {
              let { user: t3, kind: i3 } = e3;
              var n3;
              if (i3 === AS.AUDIO)
                null === (n3 = t3._audioTrack) || void 0 === n3 || n3._destroy(), t3._audioTrack = void 0;
              else if (i3 === AS.VIDEO) {
                var r2;
                null === (r2 = t3._videoTrack) || void 0 === r2 || r2._destroy(), t3._videoTrack = void 0;
              }
            });
          const i2 = zi(e2).call(e2, (e3, t3) => {
            let { user: i3, mediaType: n3 } = t3;
            const r2 = this.filterTobeUnSubscribedTracks(i3, n3);
            return e3.concat(r2);
          }, []);
          if (0 === i2.length)
            return;
          await this.connection.stopReceiving(i2.map((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          }));
          const n2 = this.createUnsubscribeAllMessage(i2);
          return this.withdrawRemoteTracks(i2), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadDownlinkStats(), i2.forEach((e3) => {
            let [t3, { kind: i3 }] = e3;
            var n3, r2;
            i3 === AS.VIDEO && t3._videoSSRC && (null === (n3 = this.connection) || void 0 === n3 || n3.setStatsRemoteVideoIsReady(t3._videoSSRC, false));
            if (i3 === AS.VIDEO)
              this.unbindRemoteTrackEvents(t3._videoTrack), null === (r2 = t3._videoTrack) || void 0 === r2 || r2._destroy(), t3._videoTrack = void 0;
            else if (i3 === AS.AUDIO) {
              var o2;
              this.unbindRemoteTrackEvents(t3._audioTrack), null === (o2 = t3._audioTrack) || void 0 === o2 || o2._destroy(), t3._audioTrack = void 0;
            }
          }), n2;
        }
        async muteRemote(e2, t2) {
          if (!this.connection)
            return;
          const i2 = this.remoteUserMap.get(e2);
          if (!i2)
            return void OE.warning("[".concat(this.store.clientId, "] P2PChannel.muteRemote has no remote user ").concat(e2.uid, "."));
          if (!i2.get(t2))
            return void OE.warning("[".concat(this.store.clientId, "] P2PChannel.muteRemote has no remote user ").concat(e2.uid, " media type ").concat(t2, "."));
          const n2 = t2 === AS.VIDEO ? e2._videoSSRC : e2._audioSSRC;
          void 0 !== n2 && this.connection.setStatsRemoteVideoIsReady(n2, false);
        }
        async unmuteRemote(e2, t2) {
          return this.unmuteRemoteNoLock(e2, t2);
        }
        async unmuteRemoteNoLock(e2, t2) {
          if (!this.connection)
            return;
          const i2 = this.remoteUserMap.get(e2);
          if (!i2)
            return void OE.warning("[".concat(this.store.clientId, "] P2PChannel.unmuteRemote has no remote user ").concat(e2.uid, "."));
          i2.get(t2) || OE.warning("[".concat(this.store.clientId, "] P2PChannel.unmuteRemote has no remote user ").concat(e2.uid, " media type ").concat(t2, "."));
        }
        getAllTracks(e2) {
          const t2 = this.localTrackMap.get(bS.LocalAudioTrack);
          if ((null == t2 ? void 0 : t2.track) instanceof NI) {
            const i2 = t2.track;
            return Array.from(this.localTrackMap.entries()).filter((e3) => {
              let [t3] = e3;
              return t3 !== bS.LocalAudioTrack;
            }).filter((t3) => {
              let [i3] = t3;
              return !(e2 && i3 === bS.LocalVideoLowTrack);
            }).map((e3) => {
              let [, { track: t3 }] = e3;
              return t3;
            }).concat(i2.trackList);
          }
          return Array.from(this.localTrackMap.entries()).filter((t3) => {
            let [i2] = t3;
            return !(e2 && i2 === bS.LocalVideoLowTrack);
          }).map((e3) => {
            let [, { track: t3 }] = e3;
            return t3;
          });
        }
        reportPublishEvent(e2, t2, i2, n2, r2) {
          if (e2) {
            const i3 = this.localTrackMap.get(bS.LocalAudioTrack), o3 = n2 ? this.localTrackMap.get(bS.LocalVideoLowTrack) : this.localTrackMap.get(bS.LocalVideoTrack);
            Pg.publish(this.store.sessionId, { eventElapse: DI.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t2, audioName: null == i3 ? void 0 : i3.track.getTrackLabel(), videoName: null == o3 ? void 0 : o3.track.getTrackLabel(), screenshare: -1 !== (null == o3 ? void 0 : o3.track._hints.indexOf(lS.SCREEN_TRACK)), audio: !!i3, video: !!o3, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
          } else {
            var o2;
            i2 || (i2 = []);
            const s2 = i2.find((e3) => e3 instanceof yI), a2 = n2 ? null === (o2 = this.localTrackMap.get(bS.LocalVideoTrack)) || void 0 === o2 ? void 0 : o2.track : i2.find((e3) => e3 instanceof Cy);
            Pg.publish(this.store.sessionId, { eventElapse: DI.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t2, audioName: null == s2 ? void 0 : s2.getTrackLabel(), videoName: null == a2 ? void 0 : a2.getTrackLabel(), screenshare: -1 !== (null == a2 ? void 0 : a2._hints.indexOf(lS.SCREEN_TRACK)), audio: !!s2, video: !!a2, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
          }
        }
        reportSubscribeEvent(e2, t2, i2, n2) {
          const r2 = n2 === AS.VIDEO ? i2._videoSSRC : i2._audioSSRC;
          r2 && Pg.subscribe(this.store.sessionId, { succ: e2, ec: t2, video: n2 === AS.VIDEO, audio: n2 === AS.AUDIO, peerid: i2.uid, subscribeRequestid: n2 === AS.VIDEO ? i2._videoSSRC : i2._audioSSRC, p2pid: this.store.p2pId, eventElapse: DI.measureFromSubscribeStart(this.store.clientId, r2) });
        }
        reset() {
          OE.debug("[".concat(this.store.clientId, "] P2PChannel.reset")), this.mutex = new Ug("P2PChannel-mutex"), this.connection && (this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0), this.shouldForwardP2PCreation && (this.connection = this.store.useDataChannel ? new Ib({}, this.store) : this.isPlanB ? new NN({}, this.store) : new VN({}, this.store), this.bindConnectionEvents(this.connection)), this.statsUploader.stopUploadUplinkStats(), this.statsUploader.stopUploadDownlinkStats(), this.statsUploader.stopUploadTransportStats(), this.statsUploader.stopUploadExtensionUsageStats(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.unbindRtpTransceiver();
          const e2 = this.localTrackMap.get(bS.LocalAudioTrack);
          if ((null == e2 ? void 0 : e2.track) instanceof NI) {
            if (e2.track.trackList.length > 0) {
              const t2 = e2.track;
              e2.track.trackList.forEach((e3) => {
                t2.removeAudioTrack(e3);
              });
            }
            e2.track.close();
          }
          this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.iceFailedCount = 0, this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.state = wS.Disconnected;
        }
        getStats() {
          var e2;
          return null === (e2 = this.connection) || void 0 === e2 ? void 0 : e2.getStats();
        }
        getRemoteVideoIsReady(e2) {
          var t2;
          return (null === (t2 = this.connection) || void 0 === t2 ? void 0 : t2.getRemoteVideoIsReady(e2)) || false;
        }
        getLocalAudioVolume() {
          const e2 = this.localTrackMap.get(bS.LocalAudioTrack);
          if (e2)
            return e2.track.getVolumeLevel();
        }
        getLocalVideoSize() {
          const e2 = this.localTrackMap.get(bS.LocalVideoTrack);
          if (e2)
            return { width: e2.track._videoWidth || 0, height: e2.track._videoHeight || 0 };
        }
        getEncoderConfig(e2) {
          const t2 = this.localTrackMap.get(e2);
          return t2 && t2.track instanceof Cy || t2 && t2.track instanceof yI ? t2.track._encoderConfig : void 0;
        }
        getLocalMedia(e2) {
          return this.localTrackMap.get(e2);
        }
        hasLocalMedia() {
          return this.localTrackMap.size > 0;
        }
        hasRemoteMedia(e2, t2) {
          if (!e2)
            return this.remoteUserMap.size > 0;
          const i2 = this.remoteUserMap.get(e2);
          return !!i2 && (!t2 || i2.has(t2));
        }
        async hasRemoteMediaWithLock(e2, t2) {
          if (!e2)
            return this.remoteUserMap.size > 0;
          const i2 = this.remoteUserMap.get(e2);
          return !!i2 && (!t2 || i2.has(t2));
        }
        getRemoteMedia(e2) {
          var t2;
          const i2 = Array.from(Eg(t2 = this.remoteUserMap).call(t2)).find((t3) => t3.uid === e2);
          return i2 ? { audioTrack: i2.audioTrack, audioSSRC: i2._audioSSRC, videoTrack: i2.videoTrack, videoSSRC: i2._videoSSRC } : {};
        }
        getAudioLevels() {
          let e2 = Array.from(this.remoteUserMap.entries()).map((e3) => {
            let [t3] = e3;
            return { uid: t3.uid, level: t3.audioTrack ? 100 * t3.audioTrack._source.getAccurateVolumeLevel() : 0 };
          });
          const t2 = this.localTrackMap.get(bS.LocalAudioTrack);
          return t2 && e2.push({ level: 100 * t2.track._source.getAccurateVolumeLevel(), uid: this.store.uid }), e2 = Hm(e2).call(e2, (e3, t3) => e3.level - t3.level), e2;
        }
        async disconnectForReconnect() {
          this.connection && (OE.debug("[".concat(this.store.clientId, "] P2PChannel.disconnectForReconnect closing P2PConnection")), this.state = wS.Reconnecting, GE("KEEP_LAST_FRAME") && 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t2] = e2;
            var i2;
            t2._videoTrack && t2._videoTrack._player && (null === (i2 = t2._videoTrack._player.getVideoElement()) || void 0 === i2 || i2.pause(), t2._videoTrack._player.isKeepLastFrame = true, t2._videoTrack._originMediaStreamTrack.stop());
          }), this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0, this.shouldForwardP2PCreation && (this.connection = this.store.useDataChannel ? new Ib({}, this.store) : this.isPlanB ? new NN({}, this.store) : new VN({}, this.store), this.bindConnectionEvents(this.connection)), 0 !== this.localTrackMap.size && (Array.from(this.localTrackMap.entries()).forEach((e2) => {
            let [t2, { track: i2 }] = e2;
            switch (t2) {
              case bS.LocalVideoTrack:
                i2._hints.includes(lS.LOW_STREAM) ? i2.close() : this.pendingLocalTracks.push(i2);
                break;
              case bS.LocalAudioTrack:
                i2 instanceof NI ? this.pendingLocalTracks = this.pendingLocalTracks.concat(i2.trackList) : this.pendingLocalTracks.push(i2);
                break;
              case bS.LocalVideoLowTrack:
            }
          }), this.emit(DS.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t2, i2] = e2;
            Array.from(Eg(i2).call(i2)).forEach((e3) => {
              this.setPendingRemoteMedia(t2, e3);
            }), this.emit(DS.MediaReconnectStart, t2.uid);
          }), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), this.statsUploader.stopUploadUplinkStats(), this.statsUploader.stopUploadDownlinkStats(), this.statsUploader.stopUploadTransportStats(), OE.debug("[".concat(this.store.clientId, "] P2PChannel disconnected, waiting to reconnect.")));
        }
        hasPendingRemoteMedia(e2, t2) {
          for (const i2 of this.pendingRemoteTracks) {
            const { user: n2, kind: r2 } = i2;
            if ((e2 instanceof yy ? e2.uid : e2) === n2.uid && t2 === r2)
              return true;
          }
          return false;
        }
        setPendingRemoteMedia(e2, t2) {
          this.hasPendingRemoteMedia(e2, t2) || this.pendingRemoteTracks.push({ user: e2, kind: t2 });
        }
        restartICE(e2) {
          var t2 = this;
          return DO(function* () {
            if (!t2.connection || t2.state !== wS.Connected || t2.connection instanceof Ib)
              return;
            const i2 = yield PO(t2.mutex.lock("From P2PChannel.restartICE"));
            let n2;
            try {
              n2 = yield PO(t2.connection.restartICE(e2));
              const r3 = yield PO(n2.next());
              if (r3.done)
                return;
              const o2 = r3.value, s2 = yield o2;
              switch (t2.reportPCDisconnectedOrFailed(e2), e2) {
                case OS.TCP:
                  t2._pcStatsUploadType = NS.TCP_RESTART;
                  break;
                case OS.RELAY:
                  t2._pcStatsUploadType = NS.RELAY_RESTART;
                  break;
                default:
                  t2._pcStatsUploadType = NS.OLD_RESTART;
              }
              t2._isInRestartIce = true, n2.next(s2);
            } catch (e3) {
              var r2;
              null === (r2 = n2) || void 0 === r2 || r2.throw(e3);
            } finally {
              i2();
            }
          })();
        }
        getUplinkNetworkQuality() {
          if (!this.connection)
            return 0;
          const e2 = this.connection.getStats(), t2 = this.localTrackMap.get(bS.LocalVideoTrack), i2 = this.localTrackMap.get(bS.LocalAudioTrack), n2 = e2.videoSend.find((e3) => e3.ssrc === (null == t2 ? void 0 : t2.ssrcs[0].ssrcId)), r2 = e2.audioSend.find((e3) => e3.ssrc === (null == i2 ? void 0 : i2.ssrcs[0].ssrcId));
          if (!n2 || !r2)
            return 1;
          const o2 = oC(this, DS.NeedSignalRTT), s2 = n2 ? n2.rttMs : void 0, a2 = r2 ? r2.rttMs : void 0, c2 = s2 && a2 ? (s2 + a2) / 2 : s2 || a2, d2 = (c2 && o2 ? (c2 + o2) / 2 : c2 || o2) || 0, u2 = 100 * e2.sendPacketLossRate * 0.7 / 50 + 0.3 * d2 / 1500, l2 = u2 < 0.17 ? 1 : u2 < 0.36 ? 2 : u2 < 0.59 ? 3 : u2 < 0.1 ? 4 : 5, h2 = null == t2 ? void 0 : t2.track;
          if (h2 && h2._encoderConfig && -1 === h2._hints.indexOf(lS.SCREEN_TRACK)) {
            const t3 = h2._encoderConfig.bitrateMax, i3 = e2.bitrate.actualEncoded;
            if (t3 && i3) {
              const e3 = (1e3 * t3 - i3) / (1e3 * t3);
              return XE[e3 < 0.15 ? 0 : e3 < 0.3 ? 1 : e3 < 0.45 ? 2 : e3 < 0.6 ? 3 : 4][l2];
            }
          }
          return l2;
        }
        getDownlinkNetworkQuality() {
          if (!this.connection)
            return 0;
          const e2 = this.connection.getStats();
          let t2 = 0;
          return Array.from(this.remoteUserMap.entries()).forEach((i2) => {
            let [n2] = i2;
            const r2 = n2._audioSSRC, o2 = n2._videoSSRC, s2 = e2.audioRecv.find((e3) => e3.ssrc === r2), a2 = e2.videoRecv.find((e3) => e3.ssrc === o2);
            if (!s2 && !a2)
              return void (t2 += 1);
            const c2 = oC(this, DS.NeedSignalRTT), d2 = e2.rtt, u2 = (d2 && c2 ? (d2 + c2) / 2 : d2 || c2) || 0, l2 = s2 ? s2.jitterMs : void 0, h2 = e2.recvPacketLossRate;
            let p2 = 0.7 * h2 * 100 / 50 + 0.3 * u2 / 1500;
            l2 && (p2 = 0.6 * h2 * 100 / 50 + 0.2 * u2 / 1500 + 0.2 * l2 / 400);
            t2 += p2 < 0.1 ? 1 : p2 < 0.17 ? 2 : p2 < 0.36 ? 3 : p2 < 0.59 ? 4 : 5;
          }), this.remoteUserMap.size > 0 ? Math.round(t2 / this.remoteUserMap.size) : t2;
        }
        async muteLocalTrack(e2) {
          return new Sl((t2, i2) => {
            this.handleMuteLocalTrack(e2, t2, i2);
          });
        }
        filterTobePublishedTracks(e2, t2, i2) {
          const n2 = [], r2 = JS(), o2 = this.getAllTracks();
          e2 = cC(e2 = e2.filter((e3) => -1 === o2.indexOf(e3)));
          let s2 = false, a2 = false;
          for (const o3 of e2) {
            if (o3 instanceof Cy && (this.localTrackMap.has(bS.LocalVideoTrack) || s2 ? new SE(fE.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (n2.push({ track: o3, type: bS.LocalVideoTrack }), s2 = true), t2)) {
              const e3 = this.getLowVideoTrack(o3, i2);
              n2.push({ track: e3, type: bS.LocalVideoLowTrack });
            }
            if (o3 instanceof yI) {
              const e3 = this.localTrackMap.get(bS.LocalAudioTrack);
              if (e3) {
                if (!(e3.track instanceof NI))
                  throw new SE(fE.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
                if (o3._bypassWebAudio)
                  throw new SE(fE.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
                e3.track.addAudioTrack(o3), this.bindLocalAudioTrackEvents(o3, true);
              } else if (a2) {
                const e4 = n2.find((e5) => {
                  let { type: t3 } = e5;
                  return t3 === bS.LocalAudioTrack;
                });
                if (!(e4.track instanceof NI))
                  throw new SE(fE.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
                if (o3._bypassWebAudio)
                  throw new SE(fE.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
                e4.track.addAudioTrack(o3);
              } else {
                if (!r2.webAudioMediaStreamDest || o3 instanceof NI || o3._bypassWebAudio)
                  n2.push({ track: o3, type: bS.LocalAudioTrack });
                else {
                  const e4 = new NI();
                  e4.addAudioTrack(o3), n2.push({ track: e4, type: bS.LocalAudioTrack });
                }
                a2 = true;
              }
            }
          }
          return n2;
        }
        filterTobeUnpublishedTracks(e2) {
          const t2 = [], i2 = this.getAllTracks();
          e2 = cC(e2 = e2.filter((e3) => -1 !== i2.indexOf(e3)));
          for (const i3 of e2) {
            if (i3 instanceof yI) {
              const e3 = this.localTrackMap.get(bS.LocalAudioTrack);
              if (!e3)
                continue;
              e3.track instanceof NI ? (e3.track.removeAudioTrack(i3), this.unbindLocalAudioTrackEvents(i3), 0 === e3.track.trackList.length && (t2.push([bS.LocalAudioTrack, e3]), e3.track.close())) : t2.push([bS.LocalAudioTrack, e3]);
            }
            if (i3 instanceof Cy) {
              const e3 = this.localTrackMap.get(bS.LocalVideoTrack);
              if (!e3)
                continue;
              t2.push([bS.LocalVideoTrack, e3]);
              const i4 = this.localTrackMap.get(bS.LocalVideoLowTrack);
              i4 && t2.push([bS.LocalVideoLowTrack, i4]);
            }
          }
          return t2;
        }
        bindLocalTrackEvents(e2) {
          e2.forEach((e3) => {
            let { track: t2, type: i2 } = e3;
            switch (i2) {
              case bS.LocalVideoTrack:
                t2.addListener(uS.GET_STATS, this.handleGetLocalVideoStats), t2.addListener(uS.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.addListener(uS.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.addListener(uS.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.addListener(uS.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode), t2.addListener(uS.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.addListener(uS.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.addListener(uS.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case bS.LocalAudioTrack:
                this.bindLocalAudioTrackEvents(t2);
                break;
              case bS.LocalVideoLowTrack:
            }
          });
        }
        bindLocalAudioTrackEvents(e2, t2) {
          e2 instanceof NI ? e2.trackList.forEach((e3) => {
            e3.addListener(uS.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.addListener(uS.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.addListener(uS.GET_STATS, this.handleGetLocalAudioStats), e3.addListener(uS.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.addListener(uS.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          }) : (e2.addListener(uS.GET_STATS, this.handleGetLocalAudioStats), e2.addListener(uS.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.addListener(uS.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.addListener(uS.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.addListener(uS.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), t2 || e2.addListener(uS.NEED_REPLACE_TRACK, this.handleReplaceTrack));
        }
        unbindLocalTrackEvents(e2) {
          e2 || (e2 = Array.from(this.localTrackMap.entries()).map((e3) => {
            let [t2, { track: i2 }] = e3;
            return { track: i2, type: t2 };
          })), e2.forEach((e3) => {
            let { track: t2, type: i2 } = e3;
            switch (i2) {
              case bS.LocalVideoTrack:
                t2.off(uS.GET_STATS, this.handleGetLocalVideoStats), t2.off(uS.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.off(uS.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.off(uS.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.off(uS.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode), t2.off(uS.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.off(uS.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.off(uS.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case bS.LocalAudioTrack:
                this.unbindLocalAudioTrackEvents(t2);
                break;
              case bS.LocalVideoLowTrack:
            }
          });
        }
        unbindLocalAudioTrackEvents(e2) {
          e2 instanceof NI ? e2.trackList.forEach((e3) => {
            e3.off(uS.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.off(uS.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.off(uS.GET_STATS, this.handleGetLocalAudioStats), e3.off(uS.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.off(uS.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          }) : (e2.off(uS.GET_STATS, this.handleGetLocalAudioStats), e2.off(uS.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.off(uS.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.off(uS.NEED_REPLACE_TRACK, this.handleReplaceTrack), e2.off(uS.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.off(uS.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack));
        }
        bindRemoteTrackEvents(e2, t2) {
          t2 instanceof ib && t2.addListener(uS.GET_STATS, (t3) => {
            t3(this.handleGetRemoteVideoStats(e2));
          }), t2 instanceof nb && t2.addListener(uS.GET_STATS, (t3) => {
            t3(this.handleGetRemoteAudioStats(e2));
          });
        }
        unbindRemoteTrackEvents(e2) {
          e2 && e2.removeAllListeners(uS.GET_STATS);
        }
        unbindAllRemoteTrackEvents() {
          Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t2, i2] = e2;
            i2.has(AS.AUDIO) && this.unbindRemoteTrackEvents(t2._audioTrack), i2.has(AS.VIDEO) && this.unbindRemoteTrackEvents(t2._videoTrack);
          });
        }
        createGatewayPublishMessage(e2, t2) {
          return e2.map((e3, i2) => {
            let n2, r2, { track: o2, type: s2 } = e3;
            switch (s2) {
              case bS.LocalAudioTrack:
                n2 = sS.Audio, r2 = { dtx: o2 instanceof AI && o2._config.DTX, hq: false, lq: false, stereo: false, speech: false };
                break;
              case bS.LocalVideoTrack:
                n2 = o2._hints.includes(lS.SCREEN_TRACK) ? sS.Screen : sS.High, r2 = Ab(Ab({}, BI(o2)), {}, { codec: this.store.codec });
                break;
              case bS.LocalVideoLowTrack:
                n2 = sS.Low, r2 = Ab(Ab({}, BI(o2)), {}, { codec: this.store.codec });
            }
            return { stream_type: n2, attributes: r2, ssrcs: t2[i2] };
          });
        }
        createGatewayUnpublishMessage(e2) {
          return e2.map((e3) => {
            let t2, [i2, { track: n2, ssrcs: r2, id: o2 }] = e3;
            switch (i2) {
              case bS.LocalVideoTrack:
                t2 = n2._hints.includes(lS.SCREEN_TRACK) ? sS.Screen : sS.High;
                break;
              case bS.LocalAudioTrack:
                t2 = sS.Audio;
                break;
              case bS.LocalVideoLowTrack:
                t2 = sS.Low;
            }
            return { stream_type: t2, ssrcs: r2, mid: o2 };
          });
        }
        assignLocalTracks(e2, t2) {
          e2.forEach((e3, i2) => {
            let { track: n2, type: r2 } = e3;
            this.localTrackMap.set(r2, { track: n2, id: t2[i2].id, ssrcs: t2[i2].localSSRC });
          });
        }
        withdrawLocalTracks(e2) {
          e2.forEach((e3) => {
            let [t2] = e3;
            this.localTrackMap.delete(t2);
          });
        }
        bindConnectionEvents(e2) {
          e2.onConnectionStateChange = async (t2) => {
            if (OE.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onConnectionStateChange(").concat(t2, ")")), this.emit(DS.PeerConnectionStateChange, t2), "connected" !== t2 || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), "connected" === t2 && (this._restartTimer && (clearTimeout(this._restartTimer), this._restartTimer = void 0), (this._isFirstConnected || this._isInRestartIce) && this.reportPCStats(Date.now(), true, this._pcStatsUploadType), this._isInRestartIce = false, this._isFirstConnected = false, this._isStartRestartIce = false), GE("NEW_ICE_RESTART")) {
              if (this._restartStates.includes(t2)) {
                if (this._isStartRestartIce)
                  return;
                this._isStartRestartIce = true;
                const t3 = (t4) => {
                  if ("disconnected" === e2.iceConnectionState || "checking" === e2.iceConnectionState || "failed" === e2.iceConnectionState) {
                    OE.debug("[".concat(this.store.clientId, "] [P2PChannel] start use restartICE, type is ").concat(t4));
                    "CONNECTED" === oC(this, DS.QueryClientConnectionState) && this.emit(DS.RequestRestartICE, t4);
                  }
                }, i2 = () => {
                  "disconnected" !== e2.iceConnectionState && "checking" !== e2.iceConnectionState && "failed" !== e2.iceConnectionState || (this.reportPCStats(Date.now(), false, this._pcStatsUploadType), OE.debug("[".concat(this.store.clientId, "] P2PConnection disconnected timeout, force reconnect")), setTimeout(() => this.emit(DS.P2PLost), 0), this.iceFailedCount += 1, this.requestReconnect());
                }, n2 = GE("ICE_RESTART_INTERVAL");
                return void (this._restartTimer = window.setTimeout(() => {
                  if (GE("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE") && JS().supportPCSetConfiguration)
                    t3(OS.RELAY), this._restartTimer = window.setTimeout(i2, n2);
                  else if (Kh())
                    t3(OS.UDP), this._restartTimer = window.setTimeout(i2, 4e3);
                  else {
                    if (t3(OS.TCP), JS().supportPCSetConfiguration)
                      return void (this._restartTimer = window.setTimeout(() => {
                        t3(OS.RELAY), this._restartTimer = window.setTimeout(i2, n2);
                      }, n2));
                    this._restartTimer = window.setTimeout(i2, n2);
                  }
                }, 800));
              }
            } else {
              if ("disconnected" === t2 && "disconnected" === e2.iceConnectionState)
                return setTimeout(() => {
                  if ("disconnected" === e2.iceConnectionState && GE("ICE_RESTART")) {
                    "CONNECTED" === oC(this, DS.QueryClientConnectionState) && this.emit(DS.RequestRestartICE);
                  }
                }, 800), void setTimeout(() => {
                  "disconnected" === e2.peerConnectionState && (OE.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection disconnected timeout 4000ms, force reconnect")), this.reportPCStats(Date.now(), false, this._pcStatsUploadType), this._isInRestartIce = false, setTimeout(() => this.emit(DS.P2PLost), 0), this.iceFailedCount += 1, this.requestReconnect());
                }, 4e3);
              "failed" === t2 && (OE.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection state failed, force reconnect")), this.reportPCDisconnectedOrFailed(), setTimeout(() => this.emit(DS.P2PLost), 0), this.iceFailedCount += 1, await this.requestReconnect());
            }
          }, e2.onICEConnectionStateChange = (e3) => {
            "connected" !== e3 || this.store.keyMetrics.iceConnectionEnd || this.store.iceConnectionEnd(), OE.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICEConnectionStateChange(").concat(e3, ")")), Pg.reportApiInvoke(this.store.sessionId, { name: "ICEConnectionStateChange", options: e3, tag: Ef.TRACER }).onSuccess(), this.emit(DS.IceConnectionStateChange, e3);
          }, e2.onICETransportStateChange = (e3) => {
            OE.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICETransportStateChange(").concat(e3, ")"));
          }, e2.onDTLSTransportStateChange = (e3) => {
            OE.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportStateChange(").concat(e3, ")"));
          }, e2.onDTLSTransportError = (e3) => {
            OE.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportError(").concat(e3, ")"));
          }, e2.onFirstAudioDecoded = (e3) => {
            var t2;
            const i2 = Array.from(Eg(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._audioSSRC === e3);
            var n2;
            i2 && (this.store.subscribe(i2.uid, "audio", void 0, void 0, void 0, Date.now()), null === (n2 = i2.audioTrack) || void 0 === n2 || n2.emit(fS.FIRST_FRAME_DECODED), Pg.firstRemoteFrame(this.store.sessionId, uf.FIRST_AUDIO_DECODE, lf.FIRST_AUDIO_DECODE, { peer: i2._uintid, subscribeElapse: DI.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId }));
          }, e2.onFirstAudioReceived = (e3) => {
            var t2;
            const i2 = Array.from(Eg(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._audioSSRC === e3);
            i2 && Pg.firstRemoteFrame(this.store.sessionId, uf.FIRST_AUDIO_RECEIVED, lf.FIRST_AUDIO_RECEIVED, { peer: i2._uintid, subscribeElapse: DI.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
          }, e2.onFirstVideoDecoded = (e3, t2, i2) => {
            this.reportVideoFirstFrameDecoded(e3, t2, i2);
          }, e2.onFirstVideoReceived = (e3) => {
            var t2;
            const i2 = Array.from(Eg(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._videoSSRC === e3);
            i2 && Pg.firstRemoteFrame(this.store.sessionId, uf.FIRST_VIDEO_RECEIVED, lf.FIRST_VIDEO_RECEIVED, { peer: i2._uintid, subscribeElapse: DI.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
          }, e2.onSelectedLocalCandidateChanged = (e3, t2) => {
            const i2 = "relay" === e3.candidateType, n2 = "relay" === t2.candidateType;
            "unknown" !== t2.candidateType && i2 === n2 || this.emit(DS.ConnectionTypeChange, i2), OE.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(YI(t2)), " -> ").concat(JSON.stringify(YI(e3)), ")"));
          }, e2.onSelectedRemoteCandidateChanged = (e3, t2) => {
            OE.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(YI(t2)), " -> ").concat(JSON.stringify(YI(e3)), ")"));
          }, e2.onFirstVideoDecodedTimeout = (e3) => {
            this.reportVideoFirstFrameDecoded(e3, void 0, void 0, true);
          };
        }
        unbindConnectionEvents(e2) {
          e2.onConnectionStateChange = void 0, e2.onICEConnectionStateChange = void 0, e2.onICETransportStateChange = void 0, e2.onDTLSTransportStateChange = void 0, e2.onDTLSTransportError = void 0, e2.onFirstAudioDecoded = void 0, e2.onFirstAudioReceived = void 0, e2.onFirstVideoDecoded = void 0, e2.onFirstVideoReceived = void 0, e2.onSelectedLocalCandidateChanged = void 0, e2.onSelectedRemoteCandidateChanged = void 0, e2.onFirstVideoDecodedTimeout = void 0;
        }
        filterTobeMutedTracks(e2) {
          const t2 = [];
          if (-1 === this.getAllTracks().indexOf(e2))
            return t2;
          const i2 = this.localTrackMap.get(bS.LocalAudioTrack);
          if (e2 instanceof yI && (null == i2 ? void 0 : i2.track) instanceof NI)
            return i2.track.isActive || t2.push([bS.LocalAudioTrack, i2]), t2;
          const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
            let [, { track: i3 }] = t3;
            return e2 === i3;
          });
          if (n2 && (t2.push(n2), n2[0] === bS.LocalVideoTrack)) {
            const e3 = this.localTrackMap.get(bS.LocalVideoLowTrack);
            e3 && t2.push([bS.LocalVideoLowTrack, e3]);
          }
          return t2;
        }
        filterTobeUnmutedTracks(e2) {
          const t2 = [], i2 = this.localTrackMap.get(bS.LocalAudioTrack);
          if (e2 instanceof yI && (null == i2 ? void 0 : i2.track) instanceof NI)
            return i2.track.isActive && t2.push([bS.LocalAudioTrack, i2]), t2;
          const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
            let [, { track: i3 }] = t3;
            return e2 === i3;
          });
          if (n2)
            if (n2[0] === bS.LocalVideoTrack) {
              t2.push(n2);
              const e3 = this.localTrackMap.get(bS.LocalVideoLowTrack);
              e3 && t2.push([bS.LocalVideoLowTrack, e3]);
            } else
              t2.push(n2);
          return t2;
        }
        createMuteMessage(e2) {
          return e2.map((e3) => {
            let t2, [i2, { track: n2, ssrcs: r2, id: o2 }] = e3;
            switch (i2) {
              case bS.LocalAudioTrack:
                t2 = sS.Audio;
                break;
              case bS.LocalVideoTrack:
                t2 = n2._hints.includes(lS.SCREEN_TRACK) ? sS.Screen : sS.High;
                break;
              case bS.LocalVideoLowTrack:
                t2 = sS.Low;
            }
            return { stream_type: t2, ssrcs: r2, mid: o2 };
          });
        }
        createUnmuteMessage(e2) {
          return e2.map((e3) => {
            let t2, [i2, { track: n2, ssrcs: r2, id: o2 }] = e3;
            switch (i2) {
              case bS.LocalAudioTrack:
                t2 = sS.Audio;
                break;
              case bS.LocalVideoTrack:
                t2 = n2._hints.includes(lS.SCREEN_TRACK) ? sS.Screen : sS.High;
                break;
              case bS.LocalVideoLowTrack:
                t2 = sS.Low;
            }
            return { stream_type: t2, ssrcs: r2, mid: o2 };
          });
        }
        filterTobeUnSubscribedTracks(e2, t2) {
          const i2 = [], n2 = this.remoteUserMap.get(e2);
          if (!n2)
            return i2;
          if (t2) {
            const r2 = n2.get(t2);
            if (!r2)
              return i2;
            i2.push([e2, { kind: t2, id: r2 }]);
          } else
            Array.from(n2.entries()).forEach((t3) => {
              let [n3, r2] = t3;
              i2.push([e2, { kind: n3, id: r2 }]);
            });
          return i2;
        }
        createUnsubscribeMessage(e2) {
          const t2 = [];
          return e2.forEach((e3) => {
            let [i2, { kind: n2, id: r2 }] = e3;
            switch (n2) {
              case AS.VIDEO:
                return void (i2._videoSSRC && t2.push({ stream_type: AS.VIDEO, ssrcId: i2._videoSSRC }));
              case AS.AUDIO:
                return void (i2._audioSSRC && t2.push({ stream_type: AS.AUDIO, ssrcId: i2._audioSSRC }));
            }
          }), t2;
        }
        createUnsubscribeAllMessage(e2) {
          const t2 = /* @__PURE__ */ new Map();
          return e2.forEach((e3) => {
            let [i2, { kind: n2 }] = e3;
            if (t2.has(i2)) {
              let e4 = t2.get(i2);
              n2 === AS.VIDEO ? e4 |= cS.Video : e4 |= cS.Audio, t2.set(i2, e4);
            } else
              n2 === AS.VIDEO ? t2.set(i2, cS.Video) : t2.set(i2, cS.Audio);
          }), { users: Array.from(t2.entries()).map((e3) => {
            let [t3, i2] = e3;
            return { stream_id: t3.uid, stream_type: i2 };
          }) };
        }
        withdrawRemoteTracks(e2) {
          e2.forEach((e3) => {
            let [t2, { kind: i2 }] = e3;
            const n2 = this.remoteUserMap.get(t2);
            n2 && (n2.delete(i2), 0 === Array.from(n2.entries()).length && this.remoteUserMap.delete(t2));
          });
        }
        async updateBitrateLimit(e2) {
          const t2 = this.localTrackMap.get(bS.LocalVideoTrack), i2 = this.localTrackMap.get(bS.LocalVideoLowTrack);
          t2 && await t2.track.setBitrateLimit(e2.uplink), i2 && e2.low_stream_uplink && await i2.track.setBitrateLimit({ max_bitrate: e2.low_stream_uplink.bitrate, min_bitrate: e2.low_stream_uplink.bitrate || 0 });
        }
        isP2PDisconnected() {
          if (this.connection) {
            return "connected" !== this.connection.peerConnectionState;
          }
          return true;
        }
        mapPubResToRemoteConfig(e2, t2) {
          return e2.map((e3, i2) => {
            var n2;
            let { stream_type: r2 } = e3;
            return null === (n2 = t2.find((e4) => {
              let { stream_type: t3 } = e4;
              return r2 === t3;
            })) || void 0 === n2 ? void 0 : n2.attributes;
          });
        }
        async tryToUnmuteAudio(e2) {
          for (let i2 = 0; i2 < e2.length; i2++)
            if (e2[i2] instanceof yI) {
              var t2;
              const n2 = this.filterTobeUnmutedTracks(e2[i2]);
              if (0 === n2.length)
                continue;
              await (null === (t2 = this.connection) || void 0 === t2 ? void 0 : t2.unmuteLocal(n2.map((e3) => {
                let [, { id: t3 }] = e3;
                return t3;
              })));
              const r2 = this.createUnmuteMessage(n2);
              return void await rC(this, DS.RequestUnmuteLocal, r2);
            }
        }
        bindStatsUploaderEvents() {
          this.statsUploader.requestStats = () => this.getStats(), this.statsUploader.requestLocalMedia = () => Array.from(this.localTrackMap.entries()), this.statsUploader.requestRemoteMedia = () => Array.from(this.remoteUserMap.entries()), this.statsUploader.requestVideoIsReady = (e2) => {
            var t2;
            return !(null === (t2 = this.connection) || void 0 === t2 || !t2.getRemoteVideoIsReady(e2));
          }, this.statsUploader.requestUpload = (e2, t2) => this.emit(DS.RequestUploadStats, e2, t2), this.statsUploader.requestAllTracks = () => this.getAllTracks();
        }
        unbindStatsUploaderEvents() {
          this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0;
        }
        async requestReconnect() {
          this.dtlsFailedCount += 1, await zI(gE(this.dtlsFailedCount, TE)), this.emit(DS.RequestReconnect);
        }
        async reconnectP2P() {
          const e2 = Array.from(this.localTrackMap.entries()), t2 = this.createGatewayUnpublishMessage(e2);
          Array.from(this.remoteUserMap.entries()), t2.length > 0 && await nC(this, DS.RequestUnpublishForReconnectPC, t2), this.disconnectForReconnect(), this.emit(DS.RequestReconnectPC);
        }
        canPublishLowStream() {
          return this.localTrackMap.has(bS.LocalVideoTrack) || this.pendingLocalTracks.some((e2) => e2 instanceof Cy);
        }
        throwIfTrackTypeNotMatch(e2) {
          if (e2.filter((e3) => e3 instanceof Cy).length > 1)
            throw new SE(fE.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
          if (e2.filter((e3) => e3 instanceof yI).length > 1 && (e2.some((e3) => e3 instanceof yI && e3._bypassWebAudio) || !JS().webAudioMediaStreamDest))
            throw new SE(fE.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
          for (const t2 of e2) {
            if (t2 instanceof Cy && this.pendingLocalTracks.some((e3) => e3 instanceof Cy))
              throw new SE(fE.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
            if (t2 instanceof yI && this.pendingLocalTracks.some((e3) => e3 instanceof yI) && (!JS().webAudioMediaStreamDest || t2._bypassWebAudio || this.pendingLocalTracks.some((e3) => e3 instanceof yI && e3._bypassWebAudio)))
              throw new SE(fE.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
          }
        }
        getLowVideoTrack(e2, t2) {
          const i2 = JS().supportDualStreamEncoding, n2 = Ab(Ab({}, { width: 160, height: 120, framerate: 15, bitrate: 50 }), t2);
          let r2;
          r2 = i2 ? e2._mediaStreamTrack.clone() : FN(e2, n2);
          const o2 = ZI(8, "track-low-"), s2 = new Cy(r2, Ab(Ab({}, i2 && { scaleResolutionDownBy: KI(n2, e2) }), {}, { frameRate: n2.framerate, bitrateMax: n2.bitrate, bitrateMin: n2.bitrate }), void 0, void 0, o2);
          return s2.on(ES.TRANSCEIVER_UPDATED, (t3) => {
            e2._updateRtpTransceiver(t3, hS.LOW_STREAM);
          }), s2._hints.push(lS.LOW_STREAM), e2.addListener(uS.NEED_CLOSE, () => {
            s2.close();
          }), s2;
        }
        async globalLock() {
          return this.mutex.lock("From P2PChannel.globalLock");
        }
        async reportPCStats(e2, t2, i2) {
          let n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
          if (this.connection && this.connection instanceof VN) {
            var r2, o2, s2, a2;
            const c2 = this.store.keyMetrics.descriptionStart || 0, { iceConnectionState: d2, dtlsTransportState: u2, peerConnectionState: l2 } = this.connection, { local: h2, remote: p2 } = await this.connection.getSelectedCandidatePair();
            Pg.pcStats(this.store.sessionId, { startTime: c2, eventElapse: e2 - c2 || 0, iceconnectionsate: d2, dtlsstate: u2, connectionstate: l2, intSucc: t2 ? 1 : 2, error: n2, selectedLocalCandidateProtocol: null !== (r2 = null == h2 ? void 0 : h2.protocol) && void 0 !== r2 ? r2 : "", selectedLocalCandidateType: null !== (o2 = h2.candidateType) && void 0 !== o2 ? o2 : "", selectedLocalCandidateAddress: "".concat(h2.address, ":").concat(h2.port), selectedRemoteCandidateProtocol: null !== (s2 = p2.protocol) && void 0 !== s2 ? s2 : "", selectedRemoteCandidateType: null !== (a2 = p2.candidateType) && void 0 !== a2 ? a2 : "", selectedRemoteCandidateAddress: "".concat(p2.address, ":").concat(p2.port), restartCnt: i2 });
          }
        }
        reportVideoFirstFrameDecoded(e2, t2, i2, n2) {
          var r2;
          const o2 = Array.from(Eg(r2 = this.remoteUserMap).call(r2)).find((t3) => t3._videoSSRC === e2);
          if (o2) {
            n2 || this.store.subscribe(o2.uid, "video", void 0, void 0, void 0, void 0, Date.now());
            const r3 = this.store.keyMetrics, s2 = r3.subscribe.find((e3) => e3.userId === o2.uid && "video" === e3.type);
            Pg.firstRemoteVideoDecode(this.store.sessionId, uf.FIRST_VIDEO_DECODE, lf.FIRST_VIDEO_DECODE, { peer: o2._uintid, videowidth: t2, videoheight: i2, subscribeElapse: DI.measureFromSubscribeStart(this.store.clientId, e2), subscribeRequestid: e2, p2pid: this.store.p2pId, apEnd: r3.requestAPEnd || 0, apStart: r3.requestAPStart || 0, joinGwEnd: r3.joinGatewayEnd || 0, joinGwStart: r3.joinGatewayStart || 0, pcEnd: r3.peerConnectionEnd || 0, pcStart: r3.peerConnectionStart || 0, subscriberEnd: (null == s2 ? void 0 : s2.subscribeEnd) || 0, subscriberStart: (null == s2 ? void 0 : s2.subscribeStart) || 0, videoAddNotify: (null == s2 ? void 0 : s2.streamAdded) || 0, state: n2 ? 1 : 0 });
          }
        }
        async remoteMediaSsrcChanged(e2, t2, i2) {
          if (!this.connection)
            return false;
          const n2 = this.remoteUserMap.get(e2);
          if (!n2)
            return false;
          const r2 = n2.get(t2);
          if (!r2)
            return false;
          const o2 = await this.connection.getRemoteSSRC(r2);
          return void 0 !== o2 && o2 !== i2;
        }
        resetConnection(e2) {
          OE.debug("[".concat(this.store.clientId, "] [P2PChannel] reset connection to ").concat(e2)), this.state === wS.Connected ? (OE.debug("[".concat(this.store.clientId, "] [P2PChannel] fallback to websocket but P2PChannel state still connected, disconnect first")), this.disconnectForReconnect()) : (this.connection && (this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0), this.shouldForwardP2PCreation && (this.connection = e2 === dS.datachannel ? new Ib({}, this.store) : this.isPlanB ? new NN({}, this.store) : new VN({}, this.store), this.bindConnectionEvents(this.connection)));
        }
        unbindRtpTransceiver() {
          0 !== this.localTrackMap.size && Array.from(this.localTrackMap.entries()).forEach((e2) => {
            let [t2, { track: i2 }] = e2;
            t2 === bS.LocalVideoLowTrack ? i2._updateRtpTransceiver(void 0, hS.LOW_STREAM) : i2._updateRtpTransceiver(void 0);
          });
        }
        reportPCDisconnectedOrFailed(e2) {
          this.connection && this.connection instanceof VN && ("disconnected" !== this.connection.iceConnectionState && "checking" !== this.connection.iceConnectionState && "failed" !== this.connection.iceConnectionState || (this._isFirstConnected ? (this.reportPCStats(Date.now(), false, this._pcStatsUploadType), this._isFirstConnected = false) : this._pcStatsUploadType === NS.TCP_RESTART && e2 === OS.RELAY ? this.reportPCStats(Date.now(), false, this._pcStatsUploadType) : this.reportPCStats(Date.now(), false, NS.DISCONNECTED_OR_FAILED)));
        }
      }).prototype, "startP2PConnection", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "startP2PConnection"), vb.prototype), ag(vb.prototype, "connect", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "connect"), vb.prototype), ag(vb.prototype, "preConnect", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "preConnect"), vb.prototype), ag(vb.prototype, "unpublish", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "unpublish"), vb.prototype), ag(vb.prototype, "unpublishLowStream", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "unpublishLowStream"), vb.prototype), ag(vb.prototype, "subscribe", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "subscribe"), vb.prototype), ag(vb.prototype, "massSubscribe", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "massSubscribe"), vb.prototype), ag(vb.prototype, "unsubscribe", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "unsubscribe"), vb.prototype), ag(vb.prototype, "massUnsubscribe", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "massUnsubscribe"), vb.prototype), ag(vb.prototype, "muteRemote", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "muteRemote"), vb.prototype), ag(vb.prototype, "unmuteRemote", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "unmuteRemote"), vb.prototype), ag(vb.prototype, "hasRemoteMediaWithLock", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "hasRemoteMediaWithLock"), vb.prototype), ag(vb.prototype, "disconnectForReconnect", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "disconnectForReconnect"), vb.prototype), ag(vb.prototype, "updateBitrateLimit", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "updateBitrateLimit"), vb.prototype), ag(vb.prototype, "remoteMediaSsrcChanged", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "remoteMediaSsrcChanged"), vb.prototype), vb);
      function wb(e2, t2, i2) {
        const n2 = e2[t2];
        if ("function" != typeof n2)
          throw new Error("Cannot use mutex on object property.");
        return i2.value = async function() {
          const e3 = this.mutex, i3 = await e3.lock("From P2PChannel.".concat(t2));
          try {
            for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++)
              o2[s2] = arguments[s2];
            return await n2.apply(this, o2);
          } finally {
            i3();
          }
        }, i2;
      }
      function Db(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function Pb(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Db(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : Db(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      var Lb;
      !function(e2) {
        e2.SET_SESSION_ID = "SET_SESSION_ID", e2.SET_P2P_ID = "SET_P2P_id", e2.SET_DC_ID = "SET_DC_id", e2.SET_UID = "SET_UID", e2.SET_PUB_ID = "SET_PUB_ID", e2.SET_CLOUD_PROXY_SERVER_MODE = "SET_CLOUD_PROXY_SERVER_MODE", e2.KEY_METRIC_CLIENT_CREATED = "KEY_METRIC_CLIENT_CREATED", e2.KEY_METRIC_JOIN_START = "KEY_METRIC_JOIN_START", e2.AVOID_JOIN_START = "AVOID_JOIN_START", e2.KEY_METRIC_JOIN_END = "KEY_METRIC_JOIN_END", e2.KEY_METRIC_REQUEST_AP_START = "KEY_METRIC_REQUEST_AP_START", e2.KEY_METRIC_REQUEST_AP_END = "KEY_METRIC_REQUEST_AP_END", e2.KEY_METRIC_JOIN_GATEWAY_START = "KEY_METRIC_JOIN_GATEWAY_START", e2.KEY_METRIC_JOIN_GATEWAY_END = "KEY_METRIC_JOIN_GATEWAY_END", e2.KEY_METRIC_PEER_CONNECTION_START = "KEY_METRIC_PEER_CONNECTION_START", e2.KEY_METRIC_PEER_CONNECTION_END = "KEY_METRIC_PEER_CONNECTION_END", e2.KEY_METRIC_DESCRIPTION_START = "KEY_METRIC_DESCRIPTION_START", e2.KEY_METRIC_ICE_CONNECTION_END = "KEY_METRIC_ICE_CONNECTION_END", e2.KEY_METRIC_SIGNAL_CHANNEL_OPEN = "KEY_METRIC_SIGNAL_CHANNEL_OPEN", e2.KEY_METRIC_PUBLISH = "KEY_METRIC_PUBLISH", e2.KEY_METRIC_SUBSCRIBE = "KEY_METRIC_SUBSCRIBE", e2.RECORD_JOIN_CHANNEL_SERVICE = "RECORD_JOIN_CHANNEL_SERVICE", e2.RESET_JOIN_CHANNEL_SERVICE_RECORDS = "RESET_JOIN_CHANNEL_SERVICE_RECORDS", e2.RESET_KEY_METRICS = "RESET_KEY_METRICS", e2.SET_USE_DATACHANNEL = "SET_USE_DATACHANNEL";
      }(Lb || (Lb = {}));
      class kb {
        constructor(e2, t2, i2, n2) {
          _p(this, "state", void 0), this.state = { codec: e2, audioCodec: t2, mode: i2, clientId: n2, sessionId: null, p2pId: 0, dcId: 0, pubId: 0, subId: 0, avoidJoinStart: 0, keyMetrics: { publish: [], subscribe: [] }, joinChannelServiceRecords: [], cloudProxyServerMode: "disabled", useDataChannel: false };
        }
        dispatch(e2) {
          this.state = function(e3, t2) {
            switch (t2.type) {
              case Lb.SET_SESSION_ID:
                return Pb(Pb({}, e3), {}, { sessionId: t2.sessionId });
              case Lb.SET_P2P_ID:
                return Pb(Pb({}, e3), {}, { p2pId: t2.p2pId });
              case Lb.SET_UID:
                return Pb(Pb({}, e3), {}, { uid: t2.uid });
              case Lb.SET_PUB_ID:
                return Pb(Pb({}, e3), {}, { pubId: t2.pubId });
              case Lb.KEY_METRIC_CLIENT_CREATED:
                return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { clientCreated: t2.metric }) });
              case Lb.KEY_METRIC_JOIN_START:
                return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { joinStart: t2.metric }) });
              case Lb.AVOID_JOIN_START:
                return Pb(Pb({}, e3), {}, { avoidJoinStart: t2.avoidJoinStart });
              case Lb.KEY_METRIC_JOIN_END:
                return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { joinEnd: t2.metric }) });
              case Lb.KEY_METRIC_REQUEST_AP_START:
                return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { requestAPStart: t2.metric }) });
              case Lb.KEY_METRIC_REQUEST_AP_END:
                return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { requestAPEnd: t2.metric }) });
              case Lb.KEY_METRIC_JOIN_GATEWAY_START:
                return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { joinGatewayStart: t2.metric }) });
              case Lb.KEY_METRIC_JOIN_GATEWAY_END:
                return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { joinGatewayEnd: t2.metric }) });
              case Lb.KEY_METRIC_PEER_CONNECTION_START:
                return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { peerConnectionStart: t2.metric }) });
              case Lb.KEY_METRIC_PEER_CONNECTION_END:
                return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { peerConnectionEnd: t2.metric }) });
              case Lb.KEY_METRIC_DESCRIPTION_START:
                return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { descriptionStart: t2.metric }) });
              case Lb.KEY_METRIC_SIGNAL_CHANNEL_OPEN:
                return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { signalChannelOpen: t2.metric }) });
              case Lb.KEY_METRIC_ICE_CONNECTION_END:
                return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { iceConnectionEnd: t2.metric }) });
              case Lb.KEY_METRIC_PUBLISH: {
                const i2 = e3.keyMetrics.publish, n2 = i2.findIndex((e4) => e4.trackId === t2.metric.trackId);
                return -1 !== n2 ? (i2[n2] = Pb(Pb({}, i2[n2]), t2.metric), Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { publish: [...i2] }) })) : Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { publish: [...e3.keyMetrics.publish, t2.metric] }) });
              }
              case Lb.KEY_METRIC_SUBSCRIBE: {
                const i2 = e3.keyMetrics.subscribe, n2 = i2.findIndex((e4) => e4.userId === t2.metric.userId && e4.type === t2.metric.type);
                return -1 !== n2 ? (i2[n2] = Pb(Pb({}, i2[n2]), t2.metric), Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { subscribe: [...i2] }) })) : Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { subscribe: [...e3.keyMetrics.subscribe, t2.metric] }) });
              }
              case Lb.SET_CLOUD_PROXY_SERVER_MODE:
                return e3.cloudProxyServerMode = t2.mode, e3;
              case Lb.RECORD_JOIN_CHANNEL_SERVICE:
                return "number" != typeof t2.index ? e3.joinChannelServiceRecords = [...e3.joinChannelServiceRecords, t2.record] : (e3.joinChannelServiceRecords[t2.index] = Pb(Pb({}, e3.joinChannelServiceRecords[t2.index]), t2.record), e3.joinChannelServiceRecords = [...e3.joinChannelServiceRecords]), e3;
              case Lb.RESET_JOIN_CHANNEL_SERVICE_RECORDS:
                return e3.joinChannelServiceRecords = [], e3;
              case Lb.RESET_KEY_METRICS:
                return e3.keyMetrics = { publish: [], subscribe: [] }, e3;
              case Lb.SET_USE_DATACHANNEL:
                return Pb(Pb({}, e3), {}, { useDataChannel: t2.val });
              default:
                return e3;
            }
          }(this.state, e2);
        }
        set sessionId(e2) {
          this.dispatch({ type: Lb.SET_SESSION_ID, sessionId: e2 });
        }
        get sessionId() {
          return this.state.sessionId;
        }
        get codec() {
          return this.state.codec;
        }
        get audioCodec() {
          return this.state.audioCodec;
        }
        get clientId() {
          return this.state.clientId;
        }
        set p2pId(e2) {
          this.dispatch({ type: Lb.SET_P2P_ID, p2pId: e2 });
        }
        get p2pId() {
          return this.state.p2pId;
        }
        set dcId(e2) {
          this.dispatch({ type: Lb.SET_DC_ID, dcId: e2 });
        }
        get dcId() {
          return this.state.dcId;
        }
        set uid(e2) {
          this.dispatch({ type: Lb.SET_UID, uid: e2 });
        }
        get uid() {
          return this.state.uid;
        }
        set pubId(e2) {
          this.dispatch({ type: Lb.SET_PUB_ID, pubId: e2 });
        }
        get pubId() {
          return this.state.pubId;
        }
        set cloudProxyServerMode(e2) {
          this.dispatch({ type: Lb.SET_CLOUD_PROXY_SERVER_MODE, mode: e2 });
        }
        get cloudProxyServerMode() {
          return this.state.cloudProxyServerMode;
        }
        set useDataChannel(e2) {
          this.dispatch({ type: Lb.SET_USE_DATACHANNEL, val: e2 });
        }
        get useDataChannel() {
          return this.state.useDataChannel;
        }
        clientCreated() {
          this.dispatch({ type: Lb.KEY_METRIC_CLIENT_CREATED, metric: Date.now() });
        }
        joinStart() {
          this.dispatch({ type: Lb.KEY_METRIC_JOIN_START, metric: Date.now() });
        }
        joinEnd() {
          this.dispatch({ type: Lb.KEY_METRIC_JOIN_END, metric: Date.now() });
        }
        requestAPStart() {
          this.dispatch({ type: Lb.KEY_METRIC_REQUEST_AP_START, metric: Date.now() });
        }
        requestAPEnd() {
          this.dispatch({ type: Lb.KEY_METRIC_REQUEST_AP_END, metric: Date.now() });
        }
        joinGatewayStart() {
          this.dispatch({ type: Lb.KEY_METRIC_JOIN_GATEWAY_START, metric: Date.now() });
        }
        joinGatewayEnd() {
          this.dispatch({ type: Lb.KEY_METRIC_JOIN_GATEWAY_END, metric: Date.now() });
        }
        peerConnectionStart() {
          this.dispatch({ type: Lb.KEY_METRIC_PEER_CONNECTION_START, metric: Date.now() });
        }
        peerConnectionEnd() {
          this.dispatch({ type: Lb.KEY_METRIC_PEER_CONNECTION_END, metric: Date.now() });
        }
        descriptionStart() {
          this.dispatch({ type: Lb.KEY_METRIC_DESCRIPTION_START, metric: Date.now() });
        }
        signalChannelOpen() {
          this.dispatch({ type: Lb.KEY_METRIC_SIGNAL_CHANNEL_OPEN, metric: Date.now() });
        }
        iceConnectionEnd() {
          this.dispatch({ type: Lb.KEY_METRIC_ICE_CONNECTION_END, metric: Date.now() });
        }
        publish(e2, t2, i2, n2) {
          this.dispatch({ type: Lb.KEY_METRIC_PUBLISH, metric: Pb(Pb({ trackId: e2, type: t2 }, i2 && { publishStart: i2 }), n2 && { publishEnd: n2 }) });
        }
        subscribe(e2, t2, i2, n2, r2, o2, s2) {
          this.dispatch({ type: Lb.KEY_METRIC_SUBSCRIBE, metric: Pb(Pb(Pb(Pb(Pb({ userId: e2, type: t2 }, i2 && { subscribeStart: i2 }), n2 && { subscribeEnd: n2 }), r2 && { firstFrame: r2 }), o2 && { streamAdded: o2 }), s2 && { firstDecoded: s2 }) });
        }
        massSubscribe(e2, t2, i2, n2) {
          e2.forEach((e3) => {
            this.dispatch({ type: Lb.KEY_METRIC_SUBSCRIBE, metric: Pb(Pb(Pb({ userId: e3.userId, type: e3.type }, t2 && { subscribeStart: t2 }), i2 && { subscribeEnd: i2 }), n2 && { firstFrame: n2 }) });
          });
        }
        get keyMetrics() {
          return this.state.keyMetrics;
        }
        recordJoinChannelService(e2, t2) {
          "gateway" === e2.service && Array.isArray(e2.urls) && (e2.urls = e2.urls.map((e3) => e3.replace(/(\d+)-\d+-\d+-(\d+)/, "$1-*-*-$2")));
          try {
            return "number" != typeof t2 ? (this.dispatch({ type: Lb.RECORD_JOIN_CHANNEL_SERVICE, record: Pb(Pb({}, e2), {}, { sessionId: this.sessionId, cloudProxyMode: this.cloudProxyServerMode, uid: this.uid }) }), this.state.joinChannelServiceRecords.length - 1) : (t2 < 0 || t2 >= this.state.joinChannelServiceRecords.length || this.dispatch({ type: Lb.RECORD_JOIN_CHANNEL_SERVICE, record: e2, index: t2 }), t2);
          } catch (e3) {
            return 0;
          }
        }
        resetJoinChannelServiceRecords() {
          this.dispatch({ type: Lb.RESET_JOIN_CHANNEL_SERVICE_RECORDS });
        }
        resetKeyMetrics() {
          this.dispatch({ type: Lb.RESET_KEY_METRICS });
        }
        get joinChannelServiceRecords() {
          try {
            return this.state.joinChannelServiceRecords;
          } catch (e2) {
            return [];
          }
        }
        get avoidJoinStart() {
          return this.state.avoidJoinStart;
        }
        set avoidJoinStart(e2) {
          this.dispatch({ type: Lb.AVOID_JOIN_START, avoidJoinStart: e2 });
        }
      }
      let Mb;
      const Ub = () => "HTTPS" === (Mb || Mb || (Mb = (window.location.protocol.split(":")[0] || "").toUpperCase(), Mb)), xb = () => void 0 !== window.isSecureContext;
      function Vb(e2) {
        let t2 = Xb();
        return function(e3, t3) {
          let i2 = e3.appId;
          void 0 !== i2 && (dw(t3, 10), iw(t3, i2));
          let n2 = e3.cid;
          void 0 !== n2 && (dw(t3, 16), dw(t3, n2));
          let r2 = e3.cname;
          void 0 !== r2 && (dw(t3, 26), iw(t3, r2));
          let o2 = e3.deviceId;
          void 0 !== o2 && (dw(t3, 34), iw(t3, o2));
          let s2 = e3.elapse;
          void 0 !== s2 && (dw(t3, 40), uw(t3, s2));
          let a2 = e3.fileSize;
          void 0 !== a2 && (dw(t3, 48), uw(t3, qb(a2)));
          let c2 = e3.height;
          void 0 !== c2 && (dw(t3, 56), uw(t3, qb(c2)));
          let d2 = e3.jpg;
          void 0 !== d2 && (dw(t3, 66), dw(t3, d2.length), function(e4, t4) {
            let i3 = $b(e4, t4.length);
            e4.bytes.set(t4, i3);
          }(t3, d2));
          let u2 = e3.networkType;
          void 0 !== u2 && (dw(t3, 72), uw(t3, qb(u2)));
          let l2 = e3.osType;
          void 0 !== l2 && (dw(t3, 80), uw(t3, qb(l2)));
          let h2 = e3.requestId;
          void 0 !== h2 && (dw(t3, 90), iw(t3, h2));
          let p2 = e3.sdkVersion;
          void 0 !== p2 && (dw(t3, 98), iw(t3, p2));
          let _2 = e3.sequence;
          void 0 !== _2 && (dw(t3, 104), uw(t3, qb(_2)));
          let E2 = e3.sid;
          void 0 !== E2 && (dw(t3, 114), iw(t3, E2));
          let m2 = e3.timestamp;
          void 0 !== m2 && (dw(t3, 120), uw(t3, m2));
          let f2 = e3.uid;
          void 0 !== f2 && (dw(t3, 128), dw(t3, f2));
          let S2 = e3.vid;
          void 0 !== S2 && (dw(t3, 136), dw(t3, S2));
          let T2 = e3.width;
          void 0 !== T2 && (dw(t3, 144), uw(t3, qb(T2)));
          let g2 = e3.service;
          void 0 !== g2 && (dw(t3, 152), dw(t3, g2));
          let R2 = e3.callbackData;
          void 0 !== R2 && (dw(t3, 162), iw(t3, R2));
          let I2 = e3.jpgEncryption;
          void 0 !== I2 && (dw(t3, 168), dw(t3, I2));
          let C2 = e3.requestType;
          void 0 !== C2 && (dw(t3, 176), dw(t3, C2));
          let v2 = e3.scorePorn;
          void 0 !== v2 && (dw(t3, 185), aw(t3, v2));
          let y2 = e3.scoreSexy;
          void 0 !== y2 && (dw(t3, 193), aw(t3, y2));
          let A2 = e3.scoreNeutral;
          void 0 !== A2 && (dw(t3, 201), aw(t3, A2));
          let O2 = e3.scene;
          void 0 !== O2 && (dw(t3, 208), dw(t3, O2));
          let N2 = e3.ossFilePrefix;
          void 0 !== N2 && (dw(t3, 218), iw(t3, N2));
          let b2 = e3.serviceVendor;
          if (void 0 !== b2)
            for (let e4 of b2) {
              dw(t3, 226);
              let i3 = Xb();
              Bb(e4, i3), dw(t3, i3.limit), nw(t3, i3), zb(i3);
            }
        }(e2, t2), function(e3) {
          let t3 = e3.bytes, i2 = e3.limit;
          return t3.length === i2 ? t3 : t3.subarray(0, i2);
        }(t2);
      }
      function jb(e2) {
        return function(e3) {
          let t3 = {};
          e:
            for (; !Zb(e3); ) {
              let i2 = cw(e3);
              switch (i2 >>> 3) {
                case 0:
                  break e;
                case 1:
                  t3.code = cw(e3);
                  break;
                case 2:
                  t3.msg = tw(e3, cw(e3));
                  break;
                case 3: {
                  let i3 = Gb(e3);
                  t3.data = Fb(e3), e3.limit = i3;
                  break;
                }
                default:
                  Wb(e3, 7 & i2);
              }
            }
          return t3;
        }({ bytes: t2 = e2, offset: 0, limit: t2.length });
        var t2;
      }
      function Fb(e2) {
        let t2 = {};
        e:
          for (; !Zb(e2); ) {
            let i2 = cw(e2);
            switch (i2 >>> 3) {
              case 0:
                break e;
              case 1:
                t2.requestId = tw(e2, cw(e2));
                break;
              case 2:
                t2.requestType = cw(e2) >>> 0;
                break;
              case 3:
                t2.scorePorn = sw(e2);
                break;
              case 4:
                t2.scoreSexy = sw(e2);
                break;
              case 5:
                t2.scoreNeutral = sw(e2);
                break;
              case 6:
                t2.requestScene = cw(e2) >>> 0;
                break;
              case 7:
                t2.scene = cw(e2) >>> 0;
                break;
              default:
                Wb(e2, 7 & i2);
            }
          }
        return t2;
      }
      function Bb(e2, t2) {
        let i2 = e2.service;
        void 0 !== i2 && (dw(t2, 8), dw(t2, i2));
        let n2 = e2.vendor;
        void 0 !== n2 && (dw(t2, 16), dw(t2, n2));
        let r2 = e2.token;
        void 0 !== r2 && (dw(t2, 26), iw(t2, r2));
        let o2 = e2.callbackUrl;
        void 0 !== o2 && (dw(t2, 34), iw(t2, o2));
      }
      function Gb(e2) {
        let t2 = cw(e2), i2 = e2.limit;
        return e2.limit = e2.offset + t2, i2;
      }
      function Wb(e2, t2) {
        switch (t2) {
          case 0:
            for (; 128 & rw(e2); )
              ;
            break;
          case 2:
            Qb(e2, cw(e2));
            break;
          case 5:
            Qb(e2, 4);
            break;
          case 1:
            Qb(e2, 8);
            break;
          default:
            throw new Error("Unimplemented type: " + t2);
        }
      }
      let Hb = new Float32Array(1);
      new Uint8Array(Hb.buffer);
      let Kb = new Float64Array(1), Yb = new Uint8Array(Kb.buffer);
      function qb(e2) {
        return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
      }
      let Jb = [];
      function Xb() {
        const e2 = Jb.pop();
        return e2 ? (e2.offset = e2.limit = 0, e2) : { bytes: new Uint8Array(64), offset: 0, limit: 0 };
      }
      function zb(e2) {
        Jb.push(e2);
      }
      function Qb(e2, t2) {
        if (e2.offset + t2 > e2.limit)
          throw new Error("Skip past limit");
        e2.offset += t2;
      }
      function Zb(e2) {
        return e2.offset >= e2.limit;
      }
      function $b(e2, t2) {
        let i2 = e2.bytes, n2 = e2.offset, r2 = e2.limit, o2 = n2 + t2;
        if (o2 > i2.length) {
          let t3 = new Uint8Array(2 * o2);
          t3.set(i2), e2.bytes = t3;
        }
        return e2.offset = o2, o2 > r2 && (e2.limit = o2), n2;
      }
      function ew(e2, t2) {
        let i2 = e2.offset;
        if (i2 + t2 > e2.limit)
          throw new Error("Read past limit");
        return e2.offset += t2, i2;
      }
      function tw(e2, t2) {
        let i2 = ew(e2, t2), n2 = String.fromCharCode, r2 = e2.bytes, o2 = "\uFFFD", s2 = "";
        for (let e3 = 0; e3 < t2; e3++) {
          let a2, c2, d2, u2, l2 = r2[e3 + i2];
          0 == (128 & l2) ? s2 += n2(l2) : 192 == (224 & l2) ? e3 + 1 >= t2 ? s2 += o2 : (a2 = r2[e3 + i2 + 1], 128 != (192 & a2) ? s2 += o2 : (u2 = (31 & l2) << 6 | 63 & a2, u2 < 128 ? s2 += o2 : (s2 += n2(u2), e3++))) : 224 == (240 & l2) ? e3 + 2 >= t2 ? s2 += o2 : (a2 = r2[e3 + i2 + 1], c2 = r2[e3 + i2 + 2], 32896 != (49344 & (a2 | c2 << 8)) ? s2 += o2 : (u2 = (15 & l2) << 12 | (63 & a2) << 6 | 63 & c2, u2 < 2048 || u2 >= 55296 && u2 <= 57343 ? s2 += o2 : (s2 += n2(u2), e3 += 2))) : 240 == (248 & l2) ? e3 + 3 >= t2 ? s2 += o2 : (a2 = r2[e3 + i2 + 1], c2 = r2[e3 + i2 + 2], d2 = r2[e3 + i2 + 3], 8421504 != (12632256 & (a2 | c2 << 8 | d2 << 16)) ? s2 += o2 : (u2 = (7 & l2) << 18 | (63 & a2) << 12 | (63 & c2) << 6 | 63 & d2, u2 < 65536 || u2 > 1114111 ? s2 += o2 : (u2 -= 65536, s2 += n2(55296 + (u2 >> 10), 56320 + (1023 & u2)), e3 += 3))) : s2 += o2;
        }
        return s2;
      }
      function iw(e2, t2) {
        let i2 = t2.length, n2 = 0;
        for (let e3 = 0; e3 < i2; e3++) {
          let r3 = t2.charCodeAt(e3);
          r3 >= 55296 && r3 <= 56319 && e3 + 1 < i2 && (r3 = (r3 << 10) + t2.charCodeAt(++e3) - 56613888), n2 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
        }
        dw(e2, n2);
        let r2 = $b(e2, n2), o2 = e2.bytes;
        for (let e3 = 0; e3 < i2; e3++) {
          let n3 = t2.charCodeAt(e3);
          n3 >= 55296 && n3 <= 56319 && e3 + 1 < i2 && (n3 = (n3 << 10) + t2.charCodeAt(++e3) - 56613888), n3 < 128 ? o2[r2++] = n3 : (n3 < 2048 ? o2[r2++] = n3 >> 6 & 31 | 192 : (n3 < 65536 ? o2[r2++] = n3 >> 12 & 15 | 224 : (o2[r2++] = n3 >> 18 & 7 | 240, o2[r2++] = n3 >> 12 & 63 | 128), o2[r2++] = n3 >> 6 & 63 | 128), o2[r2++] = 63 & n3 | 128);
        }
      }
      function nw(e2, t2) {
        let i2 = $b(e2, t2.limit), n2 = e2.bytes, r2 = t2.bytes;
        for (let e3 = 0, o2 = t2.limit; e3 < o2; e3++)
          n2[e3 + i2] = r2[e3];
      }
      function rw(e2) {
        return e2.bytes[ew(e2, 1)];
      }
      function ow(e2, t2) {
        let i2 = $b(e2, 1);
        e2.bytes[i2] = t2;
      }
      function sw(e2) {
        let t2 = ew(e2, 8), i2 = e2.bytes;
        return Yb[0] = i2[t2++], Yb[1] = i2[t2++], Yb[2] = i2[t2++], Yb[3] = i2[t2++], Yb[4] = i2[t2++], Yb[5] = i2[t2++], Yb[6] = i2[t2++], Yb[7] = i2[t2++], Kb[0];
      }
      function aw(e2, t2) {
        let i2 = $b(e2, 8), n2 = e2.bytes;
        Kb[0] = t2, n2[i2++] = Yb[0], n2[i2++] = Yb[1], n2[i2++] = Yb[2], n2[i2++] = Yb[3], n2[i2++] = Yb[4], n2[i2++] = Yb[5], n2[i2++] = Yb[6], n2[i2++] = Yb[7];
      }
      function cw(e2) {
        let t2, i2 = 0, n2 = 0;
        do {
          t2 = rw(e2), i2 < 32 && (n2 |= (127 & t2) << i2), i2 += 7;
        } while (128 & t2);
        return n2;
      }
      function dw(e2, t2) {
        for (t2 >>>= 0; t2 >= 128; )
          ow(e2, 127 & t2 | 128), t2 >>>= 7;
        ow(e2, t2);
      }
      function uw(e2, t2) {
        let i2 = t2.low >>> 0, n2 = (t2.low >>> 28 | t2.high << 4) >>> 0, r2 = t2.high >>> 24, o2 = 0 === r2 ? 0 === n2 ? i2 < 16384 ? i2 < 128 ? 1 : 2 : i2 < 1 << 21 ? 3 : 4 : n2 < 16384 ? n2 < 128 ? 5 : 6 : n2 < 1 << 21 ? 7 : 8 : r2 < 128 ? 9 : 10, s2 = $b(e2, o2), a2 = e2.bytes;
        switch (o2) {
          case 10:
            a2[s2 + 9] = r2 >>> 7 & 1;
          case 9:
            a2[s2 + 8] = 9 !== o2 ? 128 | r2 : 127 & r2;
          case 8:
            a2[s2 + 7] = 8 !== o2 ? n2 >>> 21 | 128 : n2 >>> 21 & 127;
          case 7:
            a2[s2 + 6] = 7 !== o2 ? n2 >>> 14 | 128 : n2 >>> 14 & 127;
          case 6:
            a2[s2 + 5] = 6 !== o2 ? n2 >>> 7 | 128 : n2 >>> 7 & 127;
          case 5:
            a2[s2 + 4] = 5 !== o2 ? 128 | n2 : 127 & n2;
          case 4:
            a2[s2 + 3] = 4 !== o2 ? i2 >>> 21 | 128 : i2 >>> 21 & 127;
          case 3:
            a2[s2 + 2] = 3 !== o2 ? i2 >>> 14 | 128 : i2 >>> 14 & 127;
          case 2:
            a2[s2 + 1] = 2 !== o2 ? i2 >>> 7 | 128 : i2 >>> 7 & 127;
          case 1:
            a2[s2] = 1 !== o2 ? 128 | i2 : 127 & i2;
        }
      }
      const lw = async (e2, t2, i2) => {
        const n2 = function(e3) {
          const t3 = [];
          for (let i3 = 0; i3 < e3.length; i3 += 2)
            t3.push(parseInt(e3.slice(i3, i3 + 2), 16));
          return Uint8Array.from(t3);
        }(function(e3) {
          const t3 = "0123456789abcdef";
          function i3(e4) {
            let i4, n4 = "";
            for (i4 = 0; i4 <= 3; i4++)
              n4 += t3.charAt(e4 >> 8 * i4 + 4 & 15) + t3.charAt(e4 >> 8 * i4 & 15);
            return n4;
          }
          function n3(e4, t4) {
            const i4 = (65535 & e4) + (65535 & t4);
            return (e4 >> 16) + (t4 >> 16) + (i4 >> 16) << 16 | 65535 & i4;
          }
          function r3(e4, t4, i4, r4, o4, s3) {
            return n3(function(e5, t5) {
              return e5 << t5 | e5 >>> 32 - t5;
            }(n3(n3(t4, e4), n3(r4, s3)), o4), i4);
          }
          function o3(e4, t4, i4, n4, o4, s3, a3) {
            return r3(t4 & i4 | ~t4 & n4, e4, t4, o4, s3, a3);
          }
          function s2(e4, t4, i4, n4, o4, s3, a3) {
            return r3(t4 & n4 | i4 & ~n4, e4, t4, o4, s3, a3);
          }
          function a2(e4, t4, i4, n4, o4, s3, a3) {
            return r3(t4 ^ i4 ^ n4, e4, t4, o4, s3, a3);
          }
          function c2(e4, t4, i4, n4, o4, s3, a3) {
            return r3(i4 ^ (t4 | ~n4), e4, t4, o4, s3, a3);
          }
          const d2 = function(e4) {
            let t4;
            const i4 = 1 + (e4.length + 8 >> 6), n4 = new Array(16 * i4);
            for (t4 = 0; t4 < 16 * i4; t4++)
              n4[t4] = 0;
            for (t4 = 0; t4 < e4.length; t4++)
              n4[t4 >> 2] |= e4.charCodeAt(t4) << t4 % 4 * 8;
            return n4[t4 >> 2] |= 128 << t4 % 4 * 8, n4[16 * i4 - 2] = 8 * e4.length, n4;
          }(e3);
          let u2, l2, h2, p2, _2, E2 = 1732584193, m2 = -271733879, f2 = -1732584194, S2 = 271733878;
          for (u2 = 0; u2 < d2.length; u2 += 16)
            l2 = E2, h2 = m2, p2 = f2, _2 = S2, E2 = o3(E2, m2, f2, S2, d2[u2 + 0], 7, -680876936), S2 = o3(S2, E2, m2, f2, d2[u2 + 1], 12, -389564586), f2 = o3(f2, S2, E2, m2, d2[u2 + 2], 17, 606105819), m2 = o3(m2, f2, S2, E2, d2[u2 + 3], 22, -1044525330), E2 = o3(E2, m2, f2, S2, d2[u2 + 4], 7, -176418897), S2 = o3(S2, E2, m2, f2, d2[u2 + 5], 12, 1200080426), f2 = o3(f2, S2, E2, m2, d2[u2 + 6], 17, -1473231341), m2 = o3(m2, f2, S2, E2, d2[u2 + 7], 22, -45705983), E2 = o3(E2, m2, f2, S2, d2[u2 + 8], 7, 1770035416), S2 = o3(S2, E2, m2, f2, d2[u2 + 9], 12, -1958414417), f2 = o3(f2, S2, E2, m2, d2[u2 + 10], 17, -42063), m2 = o3(m2, f2, S2, E2, d2[u2 + 11], 22, -1990404162), E2 = o3(E2, m2, f2, S2, d2[u2 + 12], 7, 1804603682), S2 = o3(S2, E2, m2, f2, d2[u2 + 13], 12, -40341101), f2 = o3(f2, S2, E2, m2, d2[u2 + 14], 17, -1502002290), m2 = o3(m2, f2, S2, E2, d2[u2 + 15], 22, 1236535329), E2 = s2(E2, m2, f2, S2, d2[u2 + 1], 5, -165796510), S2 = s2(S2, E2, m2, f2, d2[u2 + 6], 9, -1069501632), f2 = s2(f2, S2, E2, m2, d2[u2 + 11], 14, 643717713), m2 = s2(m2, f2, S2, E2, d2[u2 + 0], 20, -373897302), E2 = s2(E2, m2, f2, S2, d2[u2 + 5], 5, -701558691), S2 = s2(S2, E2, m2, f2, d2[u2 + 10], 9, 38016083), f2 = s2(f2, S2, E2, m2, d2[u2 + 15], 14, -660478335), m2 = s2(m2, f2, S2, E2, d2[u2 + 4], 20, -405537848), E2 = s2(E2, m2, f2, S2, d2[u2 + 9], 5, 568446438), S2 = s2(S2, E2, m2, f2, d2[u2 + 14], 9, -1019803690), f2 = s2(f2, S2, E2, m2, d2[u2 + 3], 14, -187363961), m2 = s2(m2, f2, S2, E2, d2[u2 + 8], 20, 1163531501), E2 = s2(E2, m2, f2, S2, d2[u2 + 13], 5, -1444681467), S2 = s2(S2, E2, m2, f2, d2[u2 + 2], 9, -51403784), f2 = s2(f2, S2, E2, m2, d2[u2 + 7], 14, 1735328473), m2 = s2(m2, f2, S2, E2, d2[u2 + 12], 20, -1926607734), E2 = a2(E2, m2, f2, S2, d2[u2 + 5], 4, -378558), S2 = a2(S2, E2, m2, f2, d2[u2 + 8], 11, -2022574463), f2 = a2(f2, S2, E2, m2, d2[u2 + 11], 16, 1839030562), m2 = a2(m2, f2, S2, E2, d2[u2 + 14], 23, -35309556), E2 = a2(E2, m2, f2, S2, d2[u2 + 1], 4, -1530992060), S2 = a2(S2, E2, m2, f2, d2[u2 + 4], 11, 1272893353), f2 = a2(f2, S2, E2, m2, d2[u2 + 7], 16, -155497632), m2 = a2(m2, f2, S2, E2, d2[u2 + 10], 23, -1094730640), E2 = a2(E2, m2, f2, S2, d2[u2 + 13], 4, 681279174), S2 = a2(S2, E2, m2, f2, d2[u2 + 0], 11, -358537222), f2 = a2(f2, S2, E2, m2, d2[u2 + 3], 16, -722521979), m2 = a2(m2, f2, S2, E2, d2[u2 + 6], 23, 76029189), E2 = a2(E2, m2, f2, S2, d2[u2 + 9], 4, -640364487), S2 = a2(S2, E2, m2, f2, d2[u2 + 12], 11, -421815835), f2 = a2(f2, S2, E2, m2, d2[u2 + 15], 16, 530742520), m2 = a2(m2, f2, S2, E2, d2[u2 + 2], 23, -995338651), E2 = c2(E2, m2, f2, S2, d2[u2 + 0], 6, -198630844), S2 = c2(S2, E2, m2, f2, d2[u2 + 7], 10, 1126891415), f2 = c2(f2, S2, E2, m2, d2[u2 + 14], 15, -1416354905), m2 = c2(m2, f2, S2, E2, d2[u2 + 5], 21, -57434055), E2 = c2(E2, m2, f2, S2, d2[u2 + 12], 6, 1700485571), S2 = c2(S2, E2, m2, f2, d2[u2 + 3], 10, -1894986606), f2 = c2(f2, S2, E2, m2, d2[u2 + 10], 15, -1051523), m2 = c2(m2, f2, S2, E2, d2[u2 + 1], 21, -2054922799), E2 = c2(E2, m2, f2, S2, d2[u2 + 8], 6, 1873313359), S2 = c2(S2, E2, m2, f2, d2[u2 + 15], 10, -30611744), f2 = c2(f2, S2, E2, m2, d2[u2 + 6], 15, -1560198380), m2 = c2(m2, f2, S2, E2, d2[u2 + 13], 21, 1309151649), E2 = c2(E2, m2, f2, S2, d2[u2 + 4], 6, -145523070), S2 = c2(S2, E2, m2, f2, d2[u2 + 11], 10, -1120210379), f2 = c2(f2, S2, E2, m2, d2[u2 + 2], 15, 718787259), m2 = c2(m2, f2, S2, E2, d2[u2 + 9], 21, -343485551), E2 = n3(E2, l2), m2 = n3(m2, h2), f2 = n3(f2, p2), S2 = n3(S2, _2);
          return i3(E2) + i3(m2) + i3(f2) + i3(S2);
        }("" + t2 + i2)).slice(0, 16), r2 = n2.slice(0, 12), o2 = await window.crypto.subtle.importKey("raw", n2, "AES-GCM", true, ["encrypt"]);
        return new Uint8Array(await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: r2 }, o2, e2));
      }, hw = async (e2, t2, i2) => await lw(e2.buffer, t2, i2);
      function pw(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      const _w = /* @__PURE__ */ new Map([["moderation", 1], ["supervise", 2]]);
      class Ew extends EE {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          if (this._connectionState === e2)
            return;
          const t2 = this._connectionState;
          this._connectionState = e2, this.emit(VS.CONNECTION_STATE_CHANGE, t2, e2);
        }
        get inspectType() {
          return this._inspectType;
        }
        set inspectType(e2) {
          var t2;
          this._inspectMode = zi(t2 = e2.map((e3) => _w.get(e3) || 0)).call(t2, (e3, t3) => e3 + t3), this._inspectType = e2;
        }
        get quality() {
          return this._quality;
        }
        set quality(e2) {
          this._quality = e2 > 1 ? 1 : e2 < 0.1 ? 0.1 : e2, this.qualityTimer && (window.clearTimeout(this.qualityTimer), this.qualityTimer = null), this._quality >= 1 || (this.qualityTimer = window.setTimeout(() => {
            this.quality = this._quality / this.qualityRatio;
          }, 6e4));
        }
        constructor(e2) {
          super(), _p(this, "name", "AgoraRTCVideoContentInspect"), _p(this, "_connectionState", US.CONNECTING), _p(this, "_innerConnectionState", void 0), _p(this, "sequence", 0), _p(this, "inspectStartTime", void 0), _p(this, "workerManagerConnection", void 0), _p(this, "workerConnection", void 0), _p(this, "workerMessageLengthLimit", void 0), _p(this, "inspectIntervalMinimum", void 0), _p(this, "qualityRatio", void 0), _p(this, "_connectInfo", void 0), _p(this, "_cancelTokenSource", pE.CancelToken.source()), _p(this, "_retryConfig", void 0), _p(this, "wmSequence", 0), _p(this, "inspectInterval", void 0), _p(this, "inspectTimer", null), _p(this, "ossFilePrefix", void 0), _p(this, "extraInfo", void 0), _p(this, "_inspectType", void 0), _p(this, "_inspectMode", void 0), _p(this, "_quality", 1), _p(this, "qualityTimer", null), _p(this, "_inspectId", void 0), _p(this, "_needWorkUrlOnly", false), _p(this, "inspectImage", () => {
            if (this.connectionState !== US.CONNECTED)
              throw new SE(fE.OPERATION_ABORTED, "content inspect service connection status is ".concat(this.connectionState));
            this.inspectTimer && (window.clearInterval(this.inspectTimer), this.inspectTimer = null), this.inspectTimer = window.setInterval(() => {
              this.connectionState === US.CONNECTED ? this.requestToInspectImage() : OE.debug("[".concat(this._inspectId, "] Inspect State is not connected , "), this.connectionState);
            }, this.inspectInterval < this.inspectIntervalMinimum ? this.inspectIntervalMinimum : this.inspectInterval), this.requestToInspectImage();
          }), this._inspectId = ZI(5, "inspect-"), this.workerMessageLengthLimit = GE("VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT"), this.inspectIntervalMinimum = GE("VIDEO_INSPECT_INTERVAL_MINIMUM"), this.qualityRatio = GE("VIDEO_INSPECT_QUALITY_RATIO"), this.inspectInterval = e2.interval, this.ossFilePrefix = e2.ossFilePrefix, this.extraInfo = e2.extraInfo, this.inspectType = e2.inspectType, this.inspectStartTime = Number(Date.now()), this.workerManagerConnection = new vC("worker-manager-" + this._inspectId, TE), this.on(VS.STATE_CHANGE, (e3, t2) => {
            this._innerConnectionState = e3, OE.debug("[".concat(this._inspectId, "] Inspect operation :").concat(xS[e3], " ").concat(t2 || ""));
          }), this.handleWorkerManagerEvents(), this.workerConnection = new vC("worker-" + this._inspectId, TE), this.handleWorkerEvents();
        }
        async init(e2, t2) {
          this.emit(VS.STATE_CHANGE, xS.CONNECT_AP), this._connectInfo = e2;
          const i2 = this._cancelTokenSource.token;
          return this._retryConfig = t2, new Sl((n2, r2) => {
            this.on(VS.CONNECTION_STATE_CHANGE, (e3, t3) => {
              t3 === US.CONNECTED && n2();
            }), this.requestAP(e2, i2, t2).then((e3) => {
              this.connectWorkerManager(e3);
            }).catch((e3) => {
              r2(e3);
            });
          });
        }
        async requestAP(e2, t2, i2) {
          const n2 = GE("WEBCS_DOMAIN").map((e3) => "https://".concat(e3, "/api/v1")), r2 = await function(e3, t3, i3, n3) {
            let { appId: r3, areaCode: o3, cname: s2, sid: a2, token: c2, uid: d2 } = t3;
            sv++;
            const u2 = "image_moderation_api", l2 = { service_name: u2, json_body: JSON.stringify({ appId: r3, areaCode: o3, cname: s2, command: "allocateEdge", requestId: sv, seq: sv, sid: a2, token: c2, ts: Date.now(), uid: d2 + "" }) };
            let h2, p2, _2 = e3[0];
            return RE(async () => {
              h2 = Date.now();
              const e4 = await gg(_2, { data: l2, cancelToken: i3, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" }, params: { action: "wrtc_gateway" } });
              if (p2 = Date.now() - h2, 0 !== e4.code) {
                const t5 = new SE(fE.UNEXPECTED_RESPONSE, "image inspect ap error, code" + e4.code, { retry: true, responseTime: p2 });
                throw OE.error(t5.toString()), t5;
              }
              const t4 = JSON.parse(e4.json_body);
              if (200 !== t4.code) {
                const e5 = new SE(fE.UNEXPECTED_RESPONSE, "image inspect ap error, code: ".concat(t4.code, ", reason: ").concat(t4.reason), { code: t4.code, responseTime: p2 });
                throw OE.error(e5.toString()), e5;
              }
              if (!t4.servers || !Array.isArray(t4.servers) || 0 === t4.servers.length) {
                const e5 = new SE(fE.UNEXPECTED_RESPONSE, "image inspect ap empty server", { code: t4.code, responseTime: p2 });
                throw OE.error(e5.toString()), e5;
              }
              const n4 = GE("VIDEO_INSPECT_WORKER_MANAGER_HOST"), r4 = GE("VIDEO_INSPECT_WORKER_MANAGER_PORT");
              return { addressList: t4.servers.map((e5) => {
                let { address: t5, wss: i4 } = e5;
                if (t5 && i4)
                  return "wss://".concat(t5.replace(/\./g, "-"), ".").concat(n4, ":").concat(r4 || i4);
              }).filter((e5) => !!e5), workerToken: t4.workerToken, vid: t4.vid, responseTime: p2 };
            }, (t4, i4) => (Pg.apworkerEvent(a2, { success: true, sc: 200, serviceName: u2, responseDetail: JSON.stringify(t4.addressList), firstSuccess: 0 === i4, responseTime: p2, serverIp: e3[i4 % e3.length] }), false), (t4, i4) => (Pg.apworkerEvent(a2, { success: false, sc: t4.data && t4.data.code || 200, serviceName: u2, responseTime: p2, serverIp: e3[i4 % e3.length] }), !!(t4.code !== fE.OPERATION_ABORTED && t4.code !== fE.UNEXPECTED_RESPONSE || t4.data && t4.data.retry) && (_2 = e3[(i4 + 1) % e3.length], true)), n3);
          }(n2, e2, t2, i2);
          this.emit(VS.STATE_CHANGE, xS.AP_CONNECTED);
          const { addressList: o2 } = r2;
          return this.wmSequence++, o2;
        }
        async connectWorkerManager(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          this._needWorkUrlOnly = t2, this.emit(VS.STATE_CHANGE, xS.CONNECT_WORKER_MANAGER), await this.workerManagerConnection.init(e2, 1e4);
        }
        async connectWorker(e2) {
          await this.workerConnection.init([e2]);
        }
        handleWorkerManagerEvents() {
          this.workerManagerConnection.on(Hf.CONNECTED, async () => {
            this.emit(VS.STATE_CHANGE, xS.WORKER_MANAGER_CONNECTED, this.workerManagerConnection.url), this.workerManagerConnection.sendMessage({ appId: this._connectInfo.appId, cname: this._connectInfo.cname, uid: this._connectInfo.uid + "", sdkVersion: "4.18.2", sid: this._connectInfo.sid, seq: this.wmSequence, ts: Number(Date.now()), requestId: Math.floor(1e12 * Math.random()), allocate: true, clientRequest: { command: "join" } }, true);
          }), this.workerManagerConnection.on(Hf.CLOSED, () => {
            this._innerConnectionState < xS.GET_WORKER_MANAGER_RESPONSE && OE.debug("[".concat(this._inspectId, "] Inspect worker manager is closed before connecting worker"));
          }), this.workerManagerConnection.on(Hf.FAILED, () => {
            this._innerConnectionState < xS.GET_WORKER_MANAGER_RESPONSE && OE.debug("[".concat(this._inspectId, "] Connecting inspect worker manager is failed before connecting worker"));
          }), this.workerManagerConnection.on(Hf.RECONNECTING, () => {
            this._innerConnectionState < xS.GET_WORKER_MANAGER_RESPONSE && OE.debug("[".concat(this._inspectId, "] Inspect worker manager is reconnecting before connecting worker"));
          }), this.workerManagerConnection.on(Hf.ON_MESSAGE, async (e2) => {
            this.emit(VS.STATE_CHANGE, xS.GET_WORKER_MANAGER_RESPONSE);
            const t2 = this.workerManagerConnection.url;
            this.workerManagerConnection.close();
            const i2 = JSON.parse(e2.data);
            if (200 !== i2.code)
              throw OE.error("[".concat(this._inspectId, "] Unexpected code ").concat(i2.code, " from worker manager")), new SE(fE.UNEXPECTED_RESPONSE, "response code of worker is unexpected", i2);
            if (!(i2.serverResponse && i2.serverResponse.portWss && t2))
              throw OE.error("[".concat(this._inspectId, "] Unexpected content from worker manager : ").concat(JSON.stringify(i2))), new SE(fE.UNEXPECTED_RESPONSE, "response content of worker is unexpected", i2);
            {
              const e3 = GE("VIDEO_INSPECT_WORKER_PORT") || i2.serverResponse.portWss, n2 = t2.replace(/:\d+\/?$/, ":".concat(e3));
              this.emit(VS.STATE_CHANGE, xS.CONNECT_WORKER, n2), this._needWorkUrlOnly ? this.emit(VS.REQUEST_NEW_WORKER_URL, n2) : await this.connectWorker(n2);
            }
          }), this.workerManagerConnection.on(Hf.WILL_RECONNECT, (e2, t2) => {
            t2(e2);
          }), this.workerManagerConnection.on(Hf.REQUEST_NEW_URLS, (e2, t2) => {
            this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e2).catch(t2);
          });
        }
        handleWorkerEvents() {
          this.workerConnection.on(Hf.CONNECTED, async () => {
            this.emit(VS.STATE_CHANGE, xS.WORKER_CONNECTED, this.workerConnection.url), this.connectionState = US.CONNECTED;
          }), this.workerConnection.on(Hf.ON_MESSAGE, async (e2) => {
            if (e2.data instanceof ArrayBuffer) {
              const i2 = jb(new Uint8Array(e2.data));
              if (GE("SHOW_VIDEO_INSPECT_WORKER_MESSAGE") && OE.debug("[".concat(this._inspectId, "] Response message for worker of inspect content "), JSON.stringify(i2)), 200 === i2.code) {
                if (Array.isArray(this.inspectType) && 1 === this.inspectType.length && "supervise" === this.inspectType[0])
                  return void this.emit(VS.INSPECT_RESULT, void 0, void 0);
                if (i2.data && i2.data.scorePorn && i2.data.scoreSexy && i2.data.scoreNeutral) {
                  var t2;
                  const e3 = { porn: i2.data.scorePorn, sexy: i2.data.scoreSexy, neutral: i2.data.scoreNeutral }, n2 = zi(t2 = Object.keys(e3)).call(t2, (t3, i3) => e3[t3] > e3[i3] ? t3 : i3, "porn"), r2 = Object.keys(e3).find((e4) => e4 === n2);
                  this.emit(VS.INSPECT_RESULT, r2);
                } else
                  this.emit(VS.INSPECT_RESULT, void 0, new SE(fE.UNEXPECTED_RESPONSE, i2.code + "", "There is an unexpected data on message"));
              } else
                this.emit(VS.INSPECT_RESULT, void 0, new SE(fE.UNEXPECTED_RESPONSE, i2.code + "", i2.msg));
            } else
              OE.error("[".concat(this._inspectId, "] Unexpected message type from worker")), this.emit(VS.INSPECT_RESULT, void 0, new SE(fE.UNEXPECTED_RESPONSE, "invalid worker message type"));
          }), this.workerConnection.on(Hf.CLOSED, () => {
            this.connectionState = US.CLOSED;
          }), this.workerConnection.on(Hf.FAILED, () => {
            this.connectionState = US.CLOSED;
          }), this.workerConnection.on(Hf.RECONNECTING, () => {
            this.connectionState = this.connectionState === US.CONNECTED ? US.RECONNECTING : US.CONNECTING;
          }), this.workerConnection.on(Hf.WILL_RECONNECT, (e2, t2) => {
            "recover" === e2 && t2(e2), t2("tryNext");
          }), this.workerConnection.on(Hf.REQUEST_NEW_URLS, (e2, t2) => {
            this.workerManagerConnection.close(), this.once(VS.REQUEST_NEW_WORKER_URL, (t3) => {
              e2([t3]);
            }), this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then((e3) => {
              this.connectWorkerManager(e3, true);
            }).catch((e3) => {
              t2(e3);
            });
          });
        }
        static intToLong(e2) {
          return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
        }
        async requestToInspectImage() {
          this.sequence++;
          const e2 = oC(this, VS.CLIENT_LOCAL_VIDEO_TRACK), t2 = { appId: this._connectInfo.appId, cname: this._connectInfo.cname, cid: this._connectInfo.cid, sid: this._connectInfo.sid, uid: this._connectInfo.uid, vid: this._connectInfo.vid };
          if (e2) {
            if (!e2.isPlaying)
              return void this.emit(VS.INSPECT_RESULT, void 0, new SE(fE.INVALID_OPERATION, "Only the track being played can be inspected"));
            const i2 = await this.generateRequestData(e2, t2);
            this.workerConnection.sendMessage(i2, true, true);
          } else
            this.emit(VS.INSPECT_RESULT, void 0, new SE(fE.INVALID_OPERATION, "Only the track being published can be inspected"));
        }
        async generateRequestData(e2, t2) {
          let { appId: i2, cname: n2, cid: r2, vid: o2, sid: s2, uid: a2 } = t2;
          const c2 = Date.now(), d2 = await e2.getCurrentFrameImage("image/jpeg", this.quality), u2 = await hw(d2, i2, n2), l2 = this.sequence + "-" + r2 + "-" + a2 + "-" + c2 + "-" + ZI(12, ""), h2 = { appId: i2, cid: r2, cname: n2, deviceId: "", elapse: Ew.intToLong(Number(c2 - this.inspectStartTime)), fileSize: u2.byteLength, jpgEncryption: 2, height: d2.height, width: d2.width, jpg: u2, networkType: 6, osType: 7, requestId: l2, sdkVersion: "4.18.2", sequence: this.sequence, sid: s2, timestamp: Ew.intToLong(c2), uid: a2, vid: o2, service: this._inspectMode, callbackData: this.extraInfo, ossFilePrefix: this.ossFilePrefix };
          void 0 === this.extraInfo && delete h2.callbackData, void 0 === this.ossFilePrefix && delete h2.ossFilePrefix;
          const p2 = Vb(h2);
          if (p2.byteLength < this.workerMessageLengthLimit) {
            if (GE("SHOW_VIDEO_INSPECT_WORKER_MESSAGE")) {
              const e3 = function(e4) {
                for (var t3 = 1; t3 < arguments.length; t3++) {
                  var i3 = null != arguments[t3] ? arguments[t3] : {};
                  t3 % 2 ? pw(Object(i3), true).forEach(function(t4) {
                    _p(e4, t4, i3[t4]);
                  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(i3)) : pw(Object(i3)).forEach(function(t4) {
                    Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(i3, t4));
                  });
                }
                return e4;
              }({}, h2);
              delete e3.jpg, OE.debug("[".concat(this._inspectId, "] Request message for worker of inspect content "), JSON.stringify(e3));
            }
            return p2;
          }
          {
            const t3 = this.quality * this.qualityRatio;
            return this.quality = t3, await this.generateRequestData(e2, { appId: i2, cname: n2, cid: r2, vid: o2, sid: s2, uid: a2 });
          }
        }
        close() {
          this._cancelTokenSource.cancel(), this._cancelTokenSource = pE.CancelToken.source(), this.workerManagerConnection && this.workerManagerConnection.close(), this.workerConnection && this.workerConnection.close(), this.inspectTimer && window.clearInterval(this.inspectTimer), this.inspectTimer = null, this.connectionState = US.CLOSED, this.emit(VS.STATE_CHANGE, xS.CLOSED);
        }
      }
      function mw(e2) {
        let t2 = function() {
          const e3 = gw.pop();
          return e3 ? (e3.offset = e3.limit = 0, e3) : { bytes: new Uint8Array(64), offset: 0, limit: 0 };
        }();
        return function(e3, t3) {
          let i2 = e3.appId;
          void 0 !== i2 && (Dw(t3, 10), Ow(t3, i2));
          let n2 = e3.cid;
          void 0 !== n2 && (Dw(t3, 16), Dw(t3, n2));
          let r2 = e3.cname;
          void 0 !== r2 && (Dw(t3, 26), Ow(t3, r2));
          let o2 = e3.deviceId;
          void 0 !== o2 && (Dw(t3, 34), Ow(t3, o2));
          let s2 = e3.elapse;
          void 0 !== s2 && (Dw(t3, 40), Lw(t3, s2));
          let a2 = e3.fileSize;
          void 0 !== a2 && (Dw(t3, 48), Lw(t3, Tw(a2)));
          let c2 = e3.height;
          void 0 !== c2 && (Dw(t3, 56), Lw(t3, Tw(c2)));
          let d2 = e3.jpg;
          void 0 !== d2 && (Dw(t3, 66), Dw(t3, d2.length), yw(t3, d2));
          let u2 = e3.networkType;
          void 0 !== u2 && (Dw(t3, 72), Lw(t3, Tw(u2)));
          let l2 = e3.osType;
          void 0 !== l2 && (Dw(t3, 80), Lw(t3, Tw(l2)));
          let h2 = e3.requestId;
          void 0 !== h2 && (Dw(t3, 90), Ow(t3, h2));
          let p2 = e3.sdkVersion;
          void 0 !== p2 && (Dw(t3, 98), Ow(t3, p2));
          let _2 = e3.sequence;
          void 0 !== _2 && (Dw(t3, 104), Lw(t3, Tw(_2)));
          let E2 = e3.sid;
          void 0 !== E2 && (Dw(t3, 114), Ow(t3, E2));
          let m2 = e3.timestamp;
          void 0 !== m2 && (Dw(t3, 120), Lw(t3, m2));
          let f2 = e3.uid;
          void 0 !== f2 && (Dw(t3, 128), Dw(t3, f2));
          let S2 = e3.vid;
          void 0 !== S2 && (Dw(t3, 136), Dw(t3, S2));
          let T2 = e3.width;
          void 0 !== T2 && (Dw(t3, 144), Lw(t3, Tw(T2)));
          let g2 = e3.service;
          void 0 !== g2 && (Dw(t3, 152), Dw(t3, g2));
          let R2 = e3.callbackData;
          void 0 !== R2 && (Dw(t3, 162), Dw(t3, R2.length), yw(t3, R2));
          let I2 = e3.ticket;
          void 0 !== I2 && (Dw(t3, 170), Ow(t3, I2));
        }(e2, t2), function(e3) {
          let t3 = e3.bytes, i2 = e3.limit;
          return t3.length === i2 ? t3 : t3.subarray(0, i2);
        }(t2);
      }
      function fw(e2) {
        return function(e3) {
          let t3 = {};
          e:
            for (; !Iw(e3); ) {
              let i2 = ww(e3);
              switch (i2 >>> 3) {
                case 0:
                  break e;
                case 1:
                  t3.code = ww(e3);
                  break;
                case 2:
                  t3.msg = Aw(e3, ww(e3));
                  break;
                case 3:
                  t3.requestId = Aw(e3, ww(e3));
                  break;
                case 4:
                  t3.timestamp = Pw(e3, false);
                  break;
                default:
                  Sw(e3, 7 & i2);
              }
            }
          return t3;
        }({ bytes: t2 = e2, offset: 0, limit: t2.length });
        var t2;
      }
      function Sw(e2, t2) {
        switch (t2) {
          case 0:
            for (; 128 & Nw(e2); )
              ;
            break;
          case 2:
            Rw(e2, ww(e2));
            break;
          case 5:
            Rw(e2, 4);
            break;
          case 1:
            Rw(e2, 8);
            break;
          default:
            throw new Error("Unimplemented type: " + t2);
        }
      }
      function Tw(e2) {
        return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
      }
      let gw = [];
      function Rw(e2, t2) {
        if (e2.offset + t2 > e2.limit)
          throw new Error("Skip past limit");
        e2.offset += t2;
      }
      function Iw(e2) {
        return e2.offset >= e2.limit;
      }
      function Cw(e2, t2) {
        let i2 = e2.bytes, n2 = e2.offset, r2 = e2.limit, o2 = n2 + t2;
        if (o2 > i2.length) {
          let t3 = new Uint8Array(2 * o2);
          t3.set(i2), e2.bytes = t3;
        }
        return e2.offset = o2, o2 > r2 && (e2.limit = o2), n2;
      }
      function vw(e2, t2) {
        let i2 = e2.offset;
        if (i2 + t2 > e2.limit)
          throw new Error("Read past limit");
        return e2.offset += t2, i2;
      }
      function yw(e2, t2) {
        let i2 = Cw(e2, t2.length);
        e2.bytes.set(t2, i2);
      }
      function Aw(e2, t2) {
        let i2 = vw(e2, t2), n2 = String.fromCharCode, r2 = e2.bytes, o2 = "\uFFFD", s2 = "";
        for (let e3 = 0; e3 < t2; e3++) {
          let a2, c2, d2, u2, l2 = r2[e3 + i2];
          0 == (128 & l2) ? s2 += n2(l2) : 192 == (224 & l2) ? e3 + 1 >= t2 ? s2 += o2 : (a2 = r2[e3 + i2 + 1], 128 != (192 & a2) ? s2 += o2 : (u2 = (31 & l2) << 6 | 63 & a2, u2 < 128 ? s2 += o2 : (s2 += n2(u2), e3++))) : 224 == (240 & l2) ? e3 + 2 >= t2 ? s2 += o2 : (a2 = r2[e3 + i2 + 1], c2 = r2[e3 + i2 + 2], 32896 != (49344 & (a2 | c2 << 8)) ? s2 += o2 : (u2 = (15 & l2) << 12 | (63 & a2) << 6 | 63 & c2, u2 < 2048 || u2 >= 55296 && u2 <= 57343 ? s2 += o2 : (s2 += n2(u2), e3 += 2))) : 240 == (248 & l2) ? e3 + 3 >= t2 ? s2 += o2 : (a2 = r2[e3 + i2 + 1], c2 = r2[e3 + i2 + 2], d2 = r2[e3 + i2 + 3], 8421504 != (12632256 & (a2 | c2 << 8 | d2 << 16)) ? s2 += o2 : (u2 = (7 & l2) << 18 | (63 & a2) << 12 | (63 & c2) << 6 | 63 & d2, u2 < 65536 || u2 > 1114111 ? s2 += o2 : (u2 -= 65536, s2 += n2(55296 + (u2 >> 10), 56320 + (1023 & u2)), e3 += 3))) : s2 += o2;
        }
        return s2;
      }
      function Ow(e2, t2) {
        let i2 = t2.length, n2 = 0;
        for (let e3 = 0; e3 < i2; e3++) {
          let r3 = t2.charCodeAt(e3);
          r3 >= 55296 && r3 <= 56319 && e3 + 1 < i2 && (r3 = (r3 << 10) + t2.charCodeAt(++e3) - 56613888), n2 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
        }
        Dw(e2, n2);
        let r2 = Cw(e2, n2), o2 = e2.bytes;
        for (let e3 = 0; e3 < i2; e3++) {
          let n3 = t2.charCodeAt(e3);
          n3 >= 55296 && n3 <= 56319 && e3 + 1 < i2 && (n3 = (n3 << 10) + t2.charCodeAt(++e3) - 56613888), n3 < 128 ? o2[r2++] = n3 : (n3 < 2048 ? o2[r2++] = n3 >> 6 & 31 | 192 : (n3 < 65536 ? o2[r2++] = n3 >> 12 & 15 | 224 : (o2[r2++] = n3 >> 18 & 7 | 240, o2[r2++] = n3 >> 12 & 63 | 128), o2[r2++] = n3 >> 6 & 63 | 128), o2[r2++] = 63 & n3 | 128);
        }
      }
      function Nw(e2) {
        return e2.bytes[vw(e2, 1)];
      }
      function bw(e2, t2) {
        let i2 = Cw(e2, 1);
        e2.bytes[i2] = t2;
      }
      function ww(e2) {
        let t2, i2 = 0, n2 = 0;
        do {
          t2 = Nw(e2), i2 < 32 && (n2 |= (127 & t2) << i2), i2 += 7;
        } while (128 & t2);
        return n2;
      }
      function Dw(e2, t2) {
        for (t2 >>>= 0; t2 >= 128; )
          bw(e2, 127 & t2 | 128), t2 >>>= 7;
        bw(e2, t2);
      }
      function Pw(e2, t2) {
        let i2, n2 = 0, r2 = 0, o2 = 0;
        return i2 = Nw(e2), n2 = 127 & i2, 128 & i2 && (i2 = Nw(e2), n2 |= (127 & i2) << 7, 128 & i2 && (i2 = Nw(e2), n2 |= (127 & i2) << 14, 128 & i2 && (i2 = Nw(e2), n2 |= (127 & i2) << 21, 128 & i2 && (i2 = Nw(e2), r2 = 127 & i2, 128 & i2 && (i2 = Nw(e2), r2 |= (127 & i2) << 7, 128 & i2 && (i2 = Nw(e2), r2 |= (127 & i2) << 14, 128 & i2 && (i2 = Nw(e2), r2 |= (127 & i2) << 21, 128 & i2 && (i2 = Nw(e2), o2 = 127 & i2, 128 & i2 && (i2 = Nw(e2), o2 |= (127 & i2) << 7))))))))), { low: n2 | r2 << 28, high: r2 >>> 4 | o2 << 24, unsigned: t2 };
      }
      function Lw(e2, t2) {
        let i2 = t2.low >>> 0, n2 = (t2.low >>> 28 | t2.high << 4) >>> 0, r2 = t2.high >>> 24, o2 = 0 === r2 ? 0 === n2 ? i2 < 16384 ? i2 < 128 ? 1 : 2 : i2 < 1 << 21 ? 3 : 4 : n2 < 16384 ? n2 < 128 ? 5 : 6 : n2 < 1 << 21 ? 7 : 8 : r2 < 128 ? 9 : 10, s2 = Cw(e2, o2), a2 = e2.bytes;
        switch (o2) {
          case 10:
            a2[s2 + 9] = r2 >>> 7 & 1;
          case 9:
            a2[s2 + 8] = 9 !== o2 ? 128 | r2 : 127 & r2;
          case 8:
            a2[s2 + 7] = 8 !== o2 ? n2 >>> 21 | 128 : n2 >>> 21 & 127;
          case 7:
            a2[s2 + 6] = 7 !== o2 ? n2 >>> 14 | 128 : n2 >>> 14 & 127;
          case 6:
            a2[s2 + 5] = 6 !== o2 ? n2 >>> 7 | 128 : n2 >>> 7 & 127;
          case 5:
            a2[s2 + 4] = 5 !== o2 ? 128 | n2 : 127 & n2;
          case 4:
            a2[s2 + 3] = 4 !== o2 ? i2 >>> 21 | 128 : i2 >>> 21 & 127;
          case 3:
            a2[s2 + 2] = 3 !== o2 ? i2 >>> 14 | 128 : i2 >>> 14 & 127;
          case 2:
            a2[s2 + 1] = 2 !== o2 ? i2 >>> 7 | 128 : i2 >>> 7 & 127;
          case 1:
            a2[s2] = 1 !== o2 ? 128 | i2 : 127 & i2;
        }
      }
      const kw = {}, Mw = {}, Uw = 4294967296, xw = 18446744073709552e3, Vw = xw / 2, jw = Hw(0, true), Fw = Hw(0), Bw = Kw(0, -2147483648, false), Gw = Kw(-1, 2147483647, false), Ww = Kw(-1, -1, true);
      function Hw(e2, t2) {
        let i2, n2, r2;
        return t2 ? (r2 = 0 <= (e2 >>>= 0) && e2 < 256) && (n2 = Mw[e2], n2) ? n2 : (i2 = Kw(e2, 0, true), r2 && (Mw[e2] = i2), i2) : (r2 = -128 <= (e2 |= 0) && e2 < 128) && (n2 = kw[e2], n2) ? n2 : (i2 = Kw(e2, e2 < 0 ? -1 : 0, false), r2 && (kw[e2] = i2), i2);
      }
      function Kw(e2, t2, i2) {
        return { low: 0 | e2, high: 0 | t2, unsigned: !!i2 };
      }
      function Yw(e2, t2) {
        if (isNaN(e2))
          return t2 ? jw : Fw;
        if (t2) {
          if (e2 < 0)
            return jw;
          if (e2 >= xw)
            return Ww;
        } else {
          if (e2 <= -Vw)
            return Bw;
          if (e2 + 1 >= Vw)
            return Gw;
        }
        return e2 < 0 ? t2 ? jw : Fw : Kw(e2 % Uw | 0, e2 / Uw | 0, t2);
      }
      function qw(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      class Jw extends EE {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          if (this._connectionState === e2)
            return;
          const t2 = this._connectionState;
          this._connectionState = e2, this.emit(HS.CONNECTION_STATE_CHANGE, e2, t2);
        }
        get quality() {
          return this._quality;
        }
        set quality(e2) {
          this._quality = e2 > 1 ? 1 : e2 < 0.1 ? 0.1 : e2, this._qualityTimer && (window.clearTimeout(this._qualityTimer), this._qualityTimer = null), this._quality >= 1 || (this._qualityTimer = window.setTimeout(() => {
            this.quality = this._quality / this._qualityRatio;
          }, 6e4));
        }
        constructor(e2) {
          var t2;
          super(), _p(this, "name", "AgoraRTCImageModeration"), _p(this, "_connectionState", WS.CONNECTING), _p(this, "_sequence", 0), _p(this, "_moderationStartTime", void 0), _p(this, "_workerConnection", void 0), _p(this, "_workerMessageLengthLimit", void 0), _p(this, "_qualityRatio", void 0), _p(this, "_connectInfo", void 0), _p(this, "_cancelTokenSource", pE.CancelToken.source()), _p(this, "_retryConfig", void 0), _p(this, "_moderationInterval", void 0), _p(this, "_moderationTimer", null), _p(this, "_moderationMode", 1), _p(this, "_quality", 1), _p(this, "_qualityTimer", null), _p(this, "_ticket", void 0), _p(this, "_moderationIntervalMinimum", void 0), _p(this, "_uploadFailedNum", 0), _p(this, "_uploadNum", 0), _p(this, "_uploadTimer", null), _p(this, "_moderationId", void 0), _p(this, "inspectImage", () => {
            if (this.connectionState !== WS.CONNECTED)
              throw new SE(fE.OPERATION_ABORTED, "image moderation service connection status is ".concat(this.connectionState));
            this._moderationTimer && (window.clearInterval(this._moderationTimer), this._moderationTimer = null), this._moderationTimer = window.setInterval(() => {
              this.connectionState === WS.CONNECTED ? this.requestToInspectImage() : OE.debug("[".concat(this._moderationId, "] Moderation State is not connected , "), this.connectionState);
            }, this._moderationInterval < this._moderationIntervalMinimum ? this._moderationIntervalMinimum : this._moderationInterval), this.requestToInspectImage();
          }), this._moderationId = ZI(5, "image-moderation-"), this._workerMessageLengthLimit = GE("IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT"), this._moderationIntervalMinimum = GE("IMAGE_MODERATION_INTERVAL_MINIMUM"), this._moderationInterval = null !== (t2 = e2.interval) && void 0 !== t2 ? t2 : 1e3, this._qualityRatio = GE("IMAGE_MODERATION_QUALITY_RATIO"), this._moderationStartTime = Number(Date.now()), this._workerConnection = new vC("worker-" + this._moderationId, TE), this.on(HS.STATE_CHANGE, (e3, t3) => {
            OE.debug("[".concat(this._moderationId, "] Moderation operation :").concat(KS[e3], " ").concat(t3 || ""));
          }), this.handleWorkerEvents();
        }
        async init(e2, t2) {
          this.emit(HS.STATE_CHANGE, KS.CONNECT_AP), this._connectInfo = e2;
          const i2 = this._cancelTokenSource.token;
          return this._retryConfig = t2, new Sl((n2, r2) => {
            this.on(HS.CONNECTION_STATE_CHANGE, (e3, t3) => {
              e3 === WS.CONNECTED && n2();
            }), this.requestAP(e2, i2, t2).then((e3) => {
              this.connectWorker(e3);
            }).catch((e3) => {
              r2(e3);
            });
          });
        }
        updateConfig(e2) {
          var t2;
          this._moderationInterval = null !== (t2 = e2.interval) && void 0 !== t2 ? t2 : 1e3, OE.debug("[".concat(this._moderationId, "] updateConfig: ").concat(JSON.stringify(e2))), this.connectionState === WS.CONNECTED && this.inspectImage();
        }
        async requestAP(e2, t2, i2) {
          const n2 = GE("WEBCS_DOMAIN").map((e3) => "https://".concat(e3, "/api/v1")), r2 = await function(e3, t3, i3, n3) {
            let { appId: r3, areaCode: o3, cname: s3, sid: a2, token: c2, uid: d2 } = t3;
            sv++;
            const u2 = "moderation_plugin", l2 = { service_name: u2, json_body: JSON.stringify({ appId: r3, areaCode: o3, cname: s3, command: "allocateEdge", requestId: sv, seq: sv, sid: a2, appToken: c2, ts: Date.now(), uid: d2 + "" }) };
            let h2, p2, _2 = e3[0];
            return RE(async () => {
              h2 = Date.now();
              const e4 = await gg(_2, { data: l2, cancelToken: i3, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" }, params: { action: "wrtc_gateway" } });
              if (p2 = Date.now() - h2, 0 !== e4.code) {
                const t5 = new SE(fE.UNEXPECTED_RESPONSE, "moderation plugin ap error, code" + e4.code, { retry: true, responseTime: p2 });
                throw OE.error(t5.toString()), t5;
              }
              const t4 = JSON.parse(e4.json_body);
              if (200 !== t4.code) {
                const e5 = new SE(fE.UNEXPECTED_RESPONSE, "moderation plugin ap error, code: ".concat(t4.code, ", reason: ").concat(t4.reason), { code: t4.code, responseTime: p2 });
                throw OE.error(e5.toString()), e5;
              }
              if (!t4.servers || !Array.isArray(t4.servers) || 0 === t4.servers.length) {
                const e5 = new SE(fE.UNEXPECTED_RESPONSE, "moderation plugin ap empty server", { code: t4.code, responseTime: p2 });
                throw OE.error(e5.toString()), e5;
              }
              if (!t4.servers.some((e5) => !!e5.wss)) {
                const e5 = new SE(fE.UNEXPECTED_RESPONSE, "moderation plugin ap empty port", { code: t4.code, responseTime: p2 });
                throw OE.error(e5.toString()), e5;
              }
              const n4 = GE("IMAGE_MODERATION_WORKER_HOST");
              return { addressList: t4.servers.map((e5) => {
                let { address: t5, wss: i4 } = e5;
                if (t5 && i4)
                  return "wss://".concat(t5.replace(/\./g, "-"), ".").concat(n4, ":").concat(i4, "/moderation");
              }).filter((e5) => !!e5), workerToken: t4.workerToken, vid: t4.vid, ticket: t4.appTicket, responseTime: p2 };
            }, (t4, i4) => (Pg.apworkerEvent(a2, { success: true, sc: 200, serviceName: u2, responseDetail: JSON.stringify(t4.addressList), firstSuccess: 0 === i4, responseTime: p2, serverIp: e3[i4 % e3.length] }), false), (t4, i4) => (Pg.apworkerEvent(a2, { success: false, sc: t4.data && t4.data.code || 200, serviceName: u2, responseTime: p2, serverIp: e3[i4 % e3.length] }), !!(t4.code !== fE.OPERATION_ABORTED && t4.code !== fE.UNEXPECTED_RESPONSE || t4.data && t4.data.retry) && (_2 = e3[(i4 + 1) % e3.length], true)), n3);
          }(n2, e2, t2, i2);
          this.emit(HS.STATE_CHANGE, KS.AP_CONNECTED);
          const { addressList: o2, ticket: s2 } = r2;
          return this._ticket = s2, o2;
        }
        async connectWorker(e2) {
          this.emit(HS.STATE_CHANGE, KS.CONNECT_WORKER), await this._workerConnection.init(e2, 1e4);
        }
        handleWorkerEvents() {
          this._workerConnection.on(Hf.CONNECTED, async () => {
            this.emit(HS.STATE_CHANGE, KS.WORKER_CONNECTED, this._workerConnection.url), this.connectionState = WS.CONNECTED;
          }), this._workerConnection.on(Hf.CLOSED, () => {
            this.connectionState = WS.CLOSED;
          }), this._workerConnection.on(Hf.FAILED, () => {
            this.connectionState = WS.CLOSED;
          }), this._workerConnection.on(Hf.RECONNECTING, () => {
            this.connectionState = this.connectionState === WS.CONNECTED ? WS.RECONNECTING : WS.CONNECTING;
          }), this._workerConnection.on(Hf.ON_MESSAGE, async (e2) => {
            if (e2.data instanceof ArrayBuffer) {
              const t2 = fw(new Uint8Array(e2.data));
              GE("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && OE.debug("[".concat(this._moderationId, "] Response message for worker of image moderation "), JSON.stringify(t2)), this._uploadNum++, void 0 === t2.code || 0 === t2.code || (this._uploadFailedNum++, OE.error("[".concat(this._moderationId, "] Error response from worke, code is ").concat(t2.code, ", msg is ").concat(t2.msg)), this._uploadTimer || (this._uploadTimer = window.setTimeout(() => {
                Pg.reportApiInvoke(this._connectInfo.sid || null, { name: _f.IMAGE_MODERATION_UPLOAD, options: [this._uploadFailedNum, this._uploadNum, t2.code], tag: Ef.TRACER }).onError(new SE(fE.IMAGE_MODERATION_UPLOAD_FAILED, t2.msg)), this._uploadTimer = null;
              }, GE("IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL"))));
            } else
              OE.error("[".concat(this._moderationId, "] Unexpected message type from worker"));
          }), this._workerConnection.on(Hf.WILL_RECONNECT, (e2, t2) => {
            "recover" === e2 && t2(e2), t2("tryNext");
          }), this._workerConnection.on(Hf.REQUEST_NEW_URLS, (e2, t2) => {
            this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e2).catch(t2);
          });
        }
        static intToLong(e2) {
          return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
        }
        async requestToInspectImage() {
          const e2 = oC(this, HS.CLIENT_LOCAL_VIDEO_TRACK), t2 = { appId: this._connectInfo.appId, cname: this._connectInfo.cname, cid: this._connectInfo.cid, sid: this._connectInfo.sid, uid: this._connectInfo.uid, vid: this._connectInfo.vid };
          if (e2) {
            if (!e2.isPlaying)
              return void (GE("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && OE.debug("Only the track being played can be inspected"));
            this._sequence++;
            const i2 = await this.generateRequestData(e2, t2);
            this._workerConnection.sendMessage(i2, true, true);
          } else
            GE("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && OE.debug("Only the track being published can be inspected");
        }
        async generateRequestData(e2, t2) {
          let { appId: i2, cname: n2, cid: r2, vid: o2, sid: s2, uid: a2 } = t2;
          const c2 = Date.now(), d2 = await e2.getCurrentFrameImage("image/jpeg", this.quality), u2 = await hw(d2, i2, n2), l2 = this._sequence + "-" + r2 + "-" + a2 + "-" + c2 + "-" + ZI(12, ""), h2 = { appId: i2, cid: r2, cname: n2, deviceId: "", elapse: Jw.intToLong(Number(c2 - this._moderationStartTime)), fileSize: d2.buffer.byteLength, height: d2.height, width: d2.width, jpg: u2, networkType: 6, osType: 7, requestId: l2, sdkVersion: "4.18.2", sequence: this._sequence, sid: s2, timestamp: Yw(c2), uid: a2, vid: o2, service: this._moderationMode, ticket: this._ticket }, p2 = mw(h2);
          if (p2.byteLength < this._workerMessageLengthLimit) {
            if (GE("SHOW_IMAGE_MODERATION_WORKER_MESSAGE")) {
              const e3 = function(e4) {
                for (var t3 = 1; t3 < arguments.length; t3++) {
                  var i3 = null != arguments[t3] ? arguments[t3] : {};
                  t3 % 2 ? qw(Object(i3), true).forEach(function(t4) {
                    _p(e4, t4, i3[t4]);
                  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(i3)) : qw(Object(i3)).forEach(function(t4) {
                    Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(i3, t4));
                  });
                }
                return e4;
              }({}, h2);
              delete e3.jpg, OE.debug("[".concat(this._moderationId, "] Request message for worker of image moderation service: "), JSON.stringify(e3));
            }
            return p2;
          }
          {
            const t3 = this.quality * this._qualityRatio;
            return this.quality = t3, await this.generateRequestData(e2, { appId: i2, cname: n2, cid: r2, vid: o2, sid: s2, uid: a2 });
          }
        }
        close() {
          this._cancelTokenSource.cancel(), this._cancelTokenSource = pE.CancelToken.source(), this._workerConnection && this._workerConnection.close(), this._moderationTimer && window.clearInterval(this._moderationTimer), this._moderationTimer = null, this._uploadTimer && window.clearTimeout(this._uploadTimer), this._uploadTimer = null, this.connectionState = WS.CLOSED, this.emit(HS.STATE_CHANGE, KS.CLOSED);
        }
      }
      var Xw, zw, Qw, Zw, $w, eD, tD, iD, nD, rD, oD, sD, aD, cD, dD, uD, lD, hD, pD, _D, ED, mD, fD, SD, TD, gD, RD, ID, CD, vD, yD, AD, OD, ND, bD, wD, DD, PD, LD, kD;
      function MD(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function UD(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? MD(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : MD(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      let xD = (Xw = Dg(), zw = Dg({ argsMap: (e2, t2) => (Array.isArray(t2) || (t2 = [t2]), t2.map((e3) => e3 ? Object(e3).toString() : "null")) }), Qw = Dg({ argsMap: (e2, t2) => (t2 || (t2 = []), Array.isArray(t2) || (t2 = [t2]), t2.map((e3) => e3.getTrackId())) }), Zw = Dg({ argsMap: (e2, t2, i2) => [t2.uid, i2] }), $w = Dg({ argsMap: (e2, t2) => t2.map((e3) => {
        let { user: t3, mediaType: i2 } = e3;
        return [null == t3 ? void 0 : t3.uid, i2];
      }) }), eD = Dg({ argsMap: (e2, t2, i2) => [t2.uid, i2] }), tD = Dg({ argsMap: (e2, t2) => t2.map((e3) => {
        let { user: t3, mediaType: i2 } = e3;
        return { uid: null == t3 ? void 0 : t3.uid, mediaType: i2 };
      }) }), iD = Dg(), nD = Dg(), rD = Dg(), oD = Dg(), sD = Dg(), aD = Dg(), cD = Dg(), dD = Dg(), uD = Dg(), lD = Dg(), hD = Dg(), pD = Dg(), _D = Dg(), ED = Dg(), mD = Dg({ argsMap: (e2, t2) => [t2] }), fD = Dg(), SD = Dg(), TD = Dg(), gD = Dg(), RD = Dg(), ID = Dg(), CD = Dg(), vD = Dg(), yD = Dg(), AD = Dg(), OD = Dg({ argsMap: (e2, t2) => (Array.isArray(t2) || (t2 = [t2]), [JSON.stringify(t2)]) }), ND = Dg(), bD = Dg(), wD = Dg(), DD = Dg(), PD = Dg({ reportResult: true }), LD = Dg(), ag((kD = class extends EE {
        get connectionState() {
          return this._gateway.state;
        }
        get remoteUsers() {
          return this._users;
        }
        get localTracks() {
          return this._p2pChannel.getAllTracks(true);
        }
        get uid() {
          return this._uid;
        }
        get channelName() {
          return this._channelName;
        }
        get mode() {
          return this._config.mode;
        }
        get role() {
          var e2;
          return (null === (e2 = this._config) || void 0 === e2 ? void 0 : e2.role) || "audience";
        }
        get codec() {
          return this._config.codec;
        }
        get audioCodec() {
          return this._config.audioCodec || "opus";
        }
        get isStringUID() {
          return !!this._joinInfo && !!this._joinInfo.stringUid;
        }
        get __className__() {
          return "Client";
        }
        constructor(e2) {
          let t2;
          if (super(), _p(this, "store", void 0), _p(this, "_uid", void 0), _p(this, "_channelName", void 0), _p(this, "_uintUid", void 0), _p(this, "_users", []), _p(this, "_config", void 0), _p(this, "_clientId", void 0), _p(this, "_appId", void 0), _p(this, "_sessionId", null), _p(this, "_key", void 0), _p(this, "_joinInfo", void 0), _p(this, "_gateway", void 0), _p(this, "_statsCollector", void 0), _p(this, "_configDistribute", void 0), _p(this, "_leaveMutex", new Ug("client-leave")), _p(this, "_publishMutex", new Ug("client-publish")), _p(this, "_renewTokenMutex", new Ug("client-renewtoken")), _p(this, "_subscribeMutex", new Ug("client-subscribe")), _p(this, "_encryptionMode", "none"), _p(this, "_encryptionSecret", null), _p(this, "_encryptionSalt", null), _p(this, "_proxyServer", void 0), _p(this, "_turnServer", { servers: [], mode: "auto" }), _p(this, "_cloudProxyServerMode", "disabled"), _p(this, "_isDualStreamEnabled", false), _p(this, "_defaultStreamFallbackType", void 0), _p(this, "_lowStreamParameter", void 0), _p(this, "_streamFallbackTypeCacheMap", /* @__PURE__ */ new Map()), _p(this, "_remoteStreamTypeCacheMap", /* @__PURE__ */ new Map()), _p(this, "_axiosCancelSource", pE.CancelToken.source()), _p(this, "_audioVolumeIndicationInterval", void 0), _p(this, "_networkQualityInterval", void 0), _p(this, "_userOfflineTimeout", void 0), _p(this, "_streamRemovedTimeout", void 0), _p(this, "_injectStreamingClient", void 0), _p(this, "_liveTranscodeStreamingClient", void 0), _p(this, "_liveRawStreamingClient", void 0), _p(this, "_channelMediaRelayClient", void 0), _p(this, "_networkQualitySensitivity", "normal"), _p(this, "_p2pChannel", void 0), _p(this, "_useLocalAccessPoint", false), _p(this, "_setLocalAPVersion", void 0), _p(this, "_joinAndNotLeaveYet", false), _p(this, "_numberOfJoinCount", 0), _p(this, "_remoteDefaultVideoStreamType", void 0), _p(this, "_inspect", void 0), _p(this, "_moderation", void 0), _p(this, "_license", void 0), _p(this, "_handleLocalTrackEnable", (e3, t3, i2) => {
            this.publish(e3, false).then(t3).catch(i2);
          }), _p(this, "_handleLocalTrackDisable", (e3, t3, i2) => {
            this.unpublish(e3).then(t3).catch(i2);
          }), _p(this, "_handleUserOnline", (e3) => {
            if (GE("BLOCK_LOCAL_CLIENT") && ZE(e3.uid, this.channelName))
              return void OE.debug("[".concat(e3.uid, "] will be ignored in local"));
            this.isStringUID && "string" != typeof e3.uid && OE.error("[".concat(this._clientId, "] StringUID is Mixed with UintUID"));
            const t3 = this._users.find((t4) => t4.uid === e3.uid);
            if (t3)
              t3._trust_in_room_ = true;
            else {
              const t4 = new yy(e3.uid, e3.uint_id || e3.uid);
              this._users.push(t4), OE.debug("[".concat(this._clientId, "] user online"), e3.uid), this.safeEmit(yf.USER_JOINED, t4);
            }
          }), _p(this, "_handleUserOffline", (e3) => {
            if (GE("BLOCK_LOCAL_CLIENT") && ZE(e3.uid, this.channelName))
              return;
            const t3 = this._users.find((t4) => t4.uid === e3.uid);
            t3 && (this._handleRemoveStream(e3), aC(this._users, t3), this._remoteStreamTypeCacheMap.delete(t3.uid), this._streamFallbackTypeCacheMap.delete(t3.uid), OE.debug("[".concat(this._clientId, "] user offline"), e3.uid, "reason:", e3.reason), this.safeEmit(yf.USER_LEAVED, t3, e3.reason));
          }), _p(this, "_handleAddAudioOrVideoStream", (e3, t3, i2, n2, r2, o2, s2) => {
            if (GE("BLOCK_LOCAL_CLIENT") && ZE(t3, this.channelName))
              return;
            const a2 = this._users.find((e4) => e4.uid === t3);
            if (!a2)
              return void OE.error("[".concat(this._clientId, "] can not find target user!(on_add_stream)"));
            OE.debug("[".concat(this._clientId, "] stream added with uid ").concat(t3, ", type ").concat(e3)), this.store.subscribe(a2.uid, e3, void 0, void 0, void 0, Date.now());
            const c2 = "audio" === e3 ? a2.hasAudio : a2.hasVideo;
            a2._uintid || (a2._uintid = r2 || t3), "audio" === e3 ? a2._trust_audio_stream_added_state_ = true : a2._trust_video_stream_added_state_ = true, "audio" === e3 ? (a2._audio_added_ = true, void 0 !== i2 && (a2._audioSSRC = i2), void 0 !== n2 && (a2._cname = n2), o2 && (a2._audioOrtc = o2)) : (a2._video_added_ = true, void 0 !== i2 && (a2._videoSSRC = i2), void 0 !== n2 && (a2._cname = n2), void 0 !== s2 && (a2._rtxSsrcId = s2), o2 && (a2._videoOrtc = o2)), ("audio" === e3 ? a2.hasAudio : a2.hasVideo) && !c2 && (OE.info("[".concat(this._clientId, "] remote user ").concat(a2.uid, " published ").concat(e3)), this.safeEmit(yf.USER_PUBLISHED, a2, e3)), "video" === e3 ? Pg.onGatewayStream(this._sessionId, uf.ON_ADD_VIDEO_STREAM, lf.ON_ADD_VIDEO_STREAM, { peer: r2 || t3 }) : Pg.onGatewayStream(this._sessionId, uf.ON_ADD_AUDIO_STREAM, lf.ON_ADD_AUDIO_STREAM, { peer: r2 || t3 }), this._p2pChannel.remoteMediaSsrcChanged(a2, e3, i2).then((t4) => {
              if (t4)
                return OE.debug("[".concat(this._clientId, "] resubscribe ").concat(e3, " for user ").concat(a2.uid, " after rejoin because SSRC id changed.")), this._p2pChannel.unsubscribe(a2, e3, true).then(() => this._subscribe(a2, e3, true).catch((e4) => {
                  OE.error("[".concat(this._clientId, "] resubscribe error"), e4.toString());
                }));
            }), this._p2pChannel.hasPendingRemoteMedia(a2, e3) && (OE.debug("[".concat(this._clientId, "] resubscribe ").concat(e3, " for user ").concat(a2.uid, " after reconnect.")), this._subscribe(a2, e3, true).catch((e4) => {
              OE.error("[".concat(this._clientId, "] resubscribe error"), e4.toString());
            }));
          }), _p(this, "_handleRemoveStream", (e3) => {
            if (GE("BLOCK_LOCAL_CLIENT") && ZE(e3.uid, this.channelName))
              return;
            const t3 = this._users.find((t4) => t4.uid === e3.uid);
            if (!t3)
              return void OE.warning("[".concat(this._clientId, "] can not find target user!(on_remove_stream)"));
            OE.debug("[".concat(this._clientId, "] stream removed with uid ").concat(e3.uid));
            let i2 = () => {
            };
            t3.hasAudio && t3.hasVideo ? i2 = () => {
              OE.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished audio track")), this.safeEmit(yf.USER_UNPUBLISHED, t3, "audio"), OE.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished video track")), this.safeEmit(yf.USER_UNPUBLISHED, t3, "video");
            } : t3.hasVideo ? i2 = () => {
              OE.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished video track")), this.safeEmit(yf.USER_UNPUBLISHED, t3, "video");
            } : t3.hasAudio && (i2 = () => {
              OE.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished audio track")), this.safeEmit(yf.USER_UNPUBLISHED, t3, "audio");
            }), t3._trust_audio_stream_added_state_ = true, t3._trust_video_stream_added_state_ = true, t3._audio_added_ = false, t3._video_added_ = false, this._p2pChannel.unsubscribe(t3).then((e4) => {
              if (e4)
                return this._gateway.unsubscribe(e4, t3.uid);
            }), t3._audioSSRC = void 0, t3._videoSSRC = void 0, t3._audioOrtc = void 0, t3._videoOrtc = void 0, t3._rtxSsrcId = void 0, Pg.onGatewayStream(this._sessionId, uf.ON_REMOVE_STREAM, lf.ON_REMOVE_STREAM, { peer: e3.uint_id || e3.uid }), i2();
          }), _p(this, "_handleSetStreamLocalEnable", (e3, t3, i2) => {
            if (GE("BLOCK_LOCAL_CLIENT") && ZE(t3, this.channelName))
              return;
            const n2 = this._users.find((e4) => e4.uid === t3);
            if (!n2)
              return void OE.error("[".concat(this._clientId, "] can not find target user!(disable_local)"));
            OE.debug("[".concat(this._clientId, "] local ").concat(e3, " ").concat(i2 ? "enabled" : "disabled", " with uid ").concat(t3));
            const r2 = "audio" === e3 ? n2.hasAudio : n2.hasVideo;
            if ("audio" === e3) {
              n2._trust_audio_enabled_state_ = true;
              const e4 = n2._audio_enabled_;
              if (n2._audio_enabled_ = i2, n2._audio_enabled_ === e4)
                return;
              {
                const e5 = n2._audio_enabled_ ? "enable-local-audio" : "disable-local-audio";
                OE.debug("[".concat(this._clientId, "] user-info-updated, uid: ").concat(t3, ", msg: ").concat(e5)), this.safeEmit(yf.USER_INFO_UPDATED, t3, e5);
              }
            } else {
              n2._trust_video_enabled_state_ = true;
              const e4 = n2._video_enabled_;
              if (n2._video_enabled_ = i2, n2._video_enabled_ === e4)
                return;
              {
                const e5 = n2._video_enabled_ ? "enable-local-video" : "disable-local-video";
                OE.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(t3, ", msg: ").concat(e5)), this.safeEmit(yf.USER_INFO_UPDATED, t3, e5);
              }
            }
            const o2 = "audio" === e3 ? n2.hasAudio : n2.hasVideo;
            return r2 !== o2 ? !r2 && o2 ? (OE.info("[".concat(this._clientId, "] remote user ").concat(t3, " published ").concat(e3)), void this.safeEmit(yf.USER_PUBLISHED, n2, e3)) : ("video" === e3 && n2._videoTrack && n2._videoTrack._destroy(), "audio" === e3 && n2._audioTrack, this._p2pChannel.muteRemote(n2, e3), OE.info("[".concat(this._clientId, "] remote user ").concat(t3, " unpublished ").concat(e3)), void this.safeEmit(yf.USER_UNPUBLISHED, n2, e3)) : void 0;
          }), _p(this, "_handleMuteStream", (e3, t3, i2) => {
            if (GE("BLOCK_LOCAL_CLIENT") && ZE(e3, this.channelName))
              return;
            OE.debug("[".concat(this._clientId, "] receive mute message"), e3, t3, i2);
            const n2 = this._users.find((t4) => t4.uid === e3);
            if (!n2)
              return void OE.warning("[".concat(this._clientId, "] can not find remote user, ignore mute event, uid: ").concat(e3));
            const r2 = "audio" === t3 ? n2.hasAudio : n2.hasVideo;
            if ("audio" === t3) {
              n2._trust_audio_mute_state_ = true;
              const t4 = n2._audio_muted_;
              if (n2._audio_muted_ = i2, n2._audio_muted_ === t4)
                return;
              {
                const t5 = n2._audio_muted_ ? "mute-audio" : "unmute-audio";
                OE.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e3, ", msg: ").concat(t5)), this.safeEmit(yf.USER_INFO_UPDATED, e3, t5);
              }
            } else {
              n2._trust_video_mute_state_ = true;
              const t4 = n2._video_muted_;
              if (n2._video_muted_ = i2, n2._video_muted_ === t4)
                return;
              {
                const t5 = n2._video_muted_ ? "mute-video" : "unmute-video";
                OE.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e3, ", msg: ").concat(t5)), this.safeEmit(yf.USER_INFO_UPDATED, e3, t5);
              }
            }
            const o2 = "audio" === t3 ? n2.hasAudio : n2.hasVideo;
            if (r2 !== o2) {
              if (!r2 && o2) {
                return ("audio" === t3 ? n2._audioSSRC : n2._videoSSRC) ? (OE.info("[".concat(this._clientId, "] remote user ").concat(e3, " published ").concat(t3)), void this.safeEmit(yf.USER_PUBLISHED, n2, t3)) : void OE.warning("[".concat(this._clientId, "] remote user ").concat(e3, " receive ").concat(t3, " unmute message  before add stream message, ").concat(t3, " SSRC doesn't exist yet."));
              }
              "video" === t3 && n2._videoTrack && n2._videoTrack._destroy(), "audio" === t3 && n2._audioTrack, this._p2pChannel.muteRemote(n2, t3), OE.info("[".concat(this._clientId, "] remote user ").concat(e3, " unpublished ").concat(t3)), this.safeEmit(yf.USER_UNPUBLISHED, n2, t3);
            }
          }), _p(this, "_handleP2PLost", async (e3) => {
            OE.debug("[".concat(this._clientId, "] receive p2p lost"), e3), parseInt(e3.p2pid, 10) === this.store.p2pId ? await this._p2pChannel.requestReconnect() : OE.warning("[".concat(this._clientId, "] P2PLost stream not found"), e3);
          }), _p(this, "_handleTokenWillExpire", () => {
            OE.debug("[".concat(this._clientId, "] received message onTokenPrivilegeWillExpire")), this.safeEmit(yf.ON_TOKEN_PRIVILEGE_WILL_EXPIRE);
          }), _p(this, "_handleBeforeUnload", (e3) => {
            "beforeunload" === e3.type && void 0 !== e3.returnValue && "" !== e3.returnValue || (this.leave(), OE.info("[".concat(this._clientId, "] auto leave onbeforeunload or pagehide")));
          }), _p(this, "_handleUpdateNetworkQuality", () => {
            if ("normal" === this._networkQualitySensitivity)
              return;
            if (navigator && void 0 !== navigator.onLine && !navigator.onLine)
              return void this.safeEmit(yf.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 });
            const e3 = { downlinkNetworkQuality: 0, uplinkNetworkQuality: 0 };
            e3.uplinkNetworkQuality = this._p2pChannel.getUplinkNetworkQuality(), e3.downlinkNetworkQuality = this._p2pChannel.getDownlinkNetworkQuality(), this.safeEmit(yf.NETWORK_QUALITY, e3);
          }), this._config = e2, this._clientId = ZI(5, "client-"), this.store = new kb(e2.codec, e2.audioCodec, e2.mode, this._clientId), this.store.clientCreated(), e2.proxyServer && this.setProxyServer(e2.proxyServer, true), e2.turnServer && this.setTurnServer(e2.turnServer, true), OE.info("[".concat(this._clientId, "] Initializing AgoraRTC client v").concat(bE, " build: ").concat(NE, ", mode: ").concat(this.mode, ", codec: ").concat(this.codec)), e2.clientRoleOptions)
            try {
              Vf(e2.clientRoleOptions), t2 = Object.assign({}, e2.clientRoleOptions);
            } catch (e3) {
              OE.warning("[".concat(this._clientId, "] ").concat(e3.toString()));
            }
          this._statsCollector = new kI(this.store), this._statsCollector.onStatsException = (e3, t3, i2) => {
            OE.debug("[".concat(this._clientId, "] receive exception msg, code: ").concat(e3, ", msg: ").concat(t3, ", uid: ").concat(i2)), this.safeEmit(yf.EXCEPTION, { code: e3, msg: t3, uid: i2 });
          }, this._statsCollector.onUploadPublishDuration = (e3, t3, i2, n2) => {
            const r2 = this._users.find((t4) => t4.uid === e3);
            r2 && Pg.peerPublishStatus(this._sessionId, { subscribeElapse: n2, audioPublishDuration: t3, videoPublishDuration: i2, peer: r2._uintid });
          }, this.store.useDataChannel = JS().supportDataChannel && GE("SIGNAL_CHANNEL"), this._gateway = new VC(this.store, { clientId: this._clientId, mode: this.mode, codec: this.codec, websocketRetryConfig: e2.websocketRetryConfig || TE, httpRetryConfig: e2.httpRetryConfig || TE, forceWaitGatewayResponse: void 0 === e2.forceWaitGatewayResponse || e2.forceWaitGatewayResponse, statsCollector: this._statsCollector, role: e2.role, clientRoleOptions: t2 }), this._configDistribute = new fv(), this._p2pChannel = new bb(this.store, this._statsCollector), this._handleP2PChannelEvents(), this._handleGatewayEvents(), this._handleGatewaySignalEvents();
        }
        async join(e2, t2, i2, n2, r2) {
          const o2 = ++this._numberOfJoinCount;
          this.store.joinStart(), n2 && (this.store.uid = n2);
          const s2 = Ub(), a2 = xb() ? window.isSecureContext : "Browser Not Support";
          if (!xb() && !s2 || !window.isSecureContext) {
            const e3 = "The website must be running in a secure context (About secure context: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts ), otherwise the media collection will be restricted by the browser";
            OE.warning(e3);
          }
          const c2 = $I();
          "DISCONNECTED" === this.connectionState && (this.store.avoidJoinStart = Math.round(Date.now()), OE.debug("[".concat(this._clientId, "] set avoidJoinStart to ").concat(this.store.avoidJoinStart)));
          const d2 = Pg.reportApiInvoke(c2, { name: _f.JOIN, options: [e2, t2, i2, n2], states: { isHttps: s2, isSecureContext: a2 }, tag: Ef.TRACER });
          Pg.setAppId(e2);
          try {
            if (!i2 && null !== i2)
              throw new SE(fE.INVALID_PARAMS, "Invalid token: ".concat(i2, ". If you don not use token, set it to null"));
            i2 && Xm(i2, "token", 1, 2047), Xm(e2, "appid", 1, 2047), Qm(t2), n2 && Zm(n2), r2 && Xm(r2, "optionalInfo", 1, 2047);
          } catch (e3) {
            throw d2.onError(e3), e3;
          }
          if (OE.info("[".concat(this._clientId, "] start join channel ").concat(t2, ", join number: ").concat(o2)), this._leaveMutex.isLocked) {
            OE.debug("[".concat(this._clientId, "] join: waiting leave operation"));
            (await this._leaveMutex.lock())(), OE.debug("[".concat(this._clientId, "] join: continue"));
          }
          if (this._joinAndNotLeaveYet = true, "DISCONNECTED" !== this.connectionState) {
            const e3 = new SE(fE.INVALID_OPERATION, "[".concat(this._clientId, "] Client already in connecting/connected state"));
            throw d2.onError(e3), e3;
          }
          this._sessionId || (this._sessionId = c2, this.store.sessionId = this._sessionId), this._gateway.state = "CONNECTING";
          const u2 = UD({ clientId: this._clientId, appId: e2, sid: this._sessionId, cname: t2, uid: "string" != typeof n2 ? n2 : null, turnServer: this._turnServer, proxyServer: this._proxyServer, token: i2 || e2, cloudProxyServer: this._cloudProxyServerMode, optionalInfo: r2, license: this._license, useLocalAccessPoint: this._useLocalAccessPoint }, void 0 !== this._remoteDefaultVideoStreamType && { defaultVideoStream: this._remoteDefaultVideoStreamType });
          if (this._useLocalAccessPoint && (u2.setLocalAPVersion = this._setLocalAPVersion), "string" == typeof n2 && (u2.stringUid = n2, this._uintUid ? (u2.uid = this._uintUid, this._uintUid = void 0) : u2.uid = 0), "none" !== this._encryptionMode && this._encryptionSecret) {
            if (u2.aesmode = this._encryptionMode, u2.aespassword = await (async (e3) => {
              const t3 = pC("MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCMnXAHkKIGAM+x4N22gCI+Wyu\nSTM9ztkT3uYslTT2PuKmZfPzhH6kVdO7PTjGCOZnAsyb3oTtWat0KcxQ4jxvqQV+\nHvYl3iI1Yd4vl2c3qRMJPLtRDfNxa2Mcxgq7e9aEUibzdd0st+OJAy3tOj/Y0aVy\nxQiYDz3vqa6bP29adwIDAQAB"), i3 = await window.crypto.subtle.importKey("spki", t3, { name: "RSA-OAEP", hash: "SHA-256" }, true, ["encrypt"]), n3 = Ag(e3), r3 = await window.crypto.subtle.encrypt({ name: "RSA-OAEP" }, i3, n3);
              return _C(new Uint8Array(r3));
            })(this._encryptionSecret), !this._joinAndNotLeaveYet)
              throw new SE(fE.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
            this._encryptionSalt && (u2.aessalt = this._encryptionSalt);
          }
          this._startSession(this._sessionId, { channel: t2, appId: e2 });
          const l2 = this._sessionId;
          setTimeout(() => {
            "CONNECTING" === this.connectionState && l2 === this._sessionId && Pg.joinChannelTimeout(this._sessionId, 5);
          }, 5e3);
          try {
            let n3;
            const r3 = u2.cloudProxyServer;
            if (["proxy3", "proxy4", "proxy5"].includes(r3)) {
              const e3 = GE("PROXY_SERVER_TYPE3");
              Array.isArray(e3) ? u2.proxyServer = e3[0] : u2.proxyServer = e3;
            }
            if (Pg.setProxyServer(u2.proxyServer), OE.setProxyServer(u2.proxyServer), this.store.requestAPStart(), u2.stringUid && !u2.uid) {
              const e3 = await dv(u2.stringUid, u2, this._axiosCancelSource.token, this._config.httpRetryConfig || TE, this.store);
              OE.debug("[".concat(this._clientId, "] getUserAccount Success ").concat(u2.stringUid, " => ").concat(e3)), u2.uid = e3, n3 = await cv(u2, this._axiosCancelSource.token, this._config.httpRetryConfig || TE, true, this.store);
            } else
              n3 = await cv(u2, this._axiosCancelSource.token, this._config.httpRetryConfig || TE, true, this.store);
            if (!this._joinAndNotLeaveYet)
              throw new SE(fE.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
            this.store.requestAPEnd(), setTimeout(() => {
              this._configDistribute.startGetConfigDistribute(u2, this._axiosCancelSource.token), this._configDistribute.on(vS.UPDATE_BITRATE_LIMIT, (e3) => {
                this._p2pChannel.updateBitrateLimit(e3);
              });
            }, 0), this._key = i2 || e2;
            const o3 = n3.gatewayInfo;
            this._joinInfo = UD(UD({}, u2), {}, { cid: o3.cid, uid: u2.uid ? u2.uid : o3.uid, vid: o3.vid, apResponse: o3.res, uni_lbs_ip: o3.uni_lbs_ip, gatewayAddrs: o3.gatewayAddrs });
            const s3 = await this._joinGateway();
            if (!this._joinAndNotLeaveYet)
              throw new SE(fE.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
            d2.onSuccess(s3), this._appId = e2, this._channelName = u2.cname, this._uid = s3, this.store.uid = s3, setTimeout(() => {
              this._networkQualityInterval && window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = window.setInterval(this._handleUpdateNetworkQuality, 2e3), window.addEventListener(Hh() ? "beforeunload" : "pagehide", this._handleBeforeUnload);
            }, 0);
            const a3 = u2.stringUid ? "string uid: ".concat(u2.stringUid, ",uid: ").concat(u2.uid) : "uid: ".concat(this._uid);
            return OE.info("[".concat(this._clientId, "] Joining channel success: channel: ").concat(t2, ",").concat(a3)), setTimeout(() => {
              OE.startUpload();
            }, 5e3), this.store.joinEnd(), h2 = this, zE.includes(h2) || zE.push(h2), s3;
          } catch (e3) {
            const t3 = Array.isArray(e3) ? e3[0] : e3;
            throw t3 && t3.code === fE.OPERATION_ABORTED ? OE.warning("[".concat(this._clientId, "] join number: ").concat(o2, ", Joining channel failed, rollback"), t3) : OE.error("[".concat(this._clientId, "] join number: ").concat(o2, ", Joining channel failed, rollback"), t3), t3.code !== fE.OPERATION_ABORTED && this._numberOfJoinCount === o2 && (this._gateway.state = "DISCONNECTED", this._reset()), d2.onError(t3), t3;
          }
          var h2;
        }
        _joinGateway() {
          if (!this._joinInfo || !this._key)
            throw new SE(fE.INVALID_OPERATION);
          return this._gateway.join(this._joinInfo, this._key, !("disabled" !== this._joinInfo.cloudProxyServer || this._joinInfo.proxyServer || !GE("JOIN_WITH_FALLBACK_SIGNAL_PROXY"))).then((e2) => e2).catch((e2) => {
            if (e2.code === fE.INIT_WEBSOCKET_TIMEOUT)
              return this._gateway.leave(true, vf.FALLBACK), e2;
            if (e2.code === fE.INIT_DATACHANNEL_TIMEOUT)
              return this._gateway.leave(true, vf.FALLBACK), e2;
            throw e2;
          }).then((e2) => {
            if (e2 instanceof SE) {
              if (e2.code === fE.INIT_WEBSOCKET_TIMEOUT) {
                if (OE.info("[".concat(this._clientId, "] join timeout, fallback to proxy")), !this._joinInfo || !this._key)
                  throw new SE(fE.INVALID_OPERATION);
                this._joinInfo.cloudProxyServer = "fallback", this._cloudProxyServerMode = "fallback", this.store.cloudProxyServerMode = "fallback";
                const e3 = GE("PROXY_SERVER_TYPE3");
                if (Array.isArray(e3))
                  if (this._joinInfo.apUrl) {
                    const t3 = /^https?:\/\/(.+?)(\/.*)?$/.exec(this._joinInfo.apUrl)[1].split("."), i2 = t3.slice(t3.length - 2).join(".");
                    e3.forEach((e4) => {
                      this._joinInfo && e4.includes(i2) && (this._joinInfo.proxyServer = e4);
                    }), this._joinInfo.proxyServer || (this._joinInfo.proxyServer = e3[0]);
                  } else
                    this._joinInfo.proxyServer = e3[0];
                else
                  this._joinInfo.proxyServer = e3;
                const t2 = GE("LOG_UPLOAD_SERVER").match(/.+:(\d{1,5})$/);
                t2 && t2[1] && "443" !== t2[1] && OE.setProxyServer(this._joinInfo.proxyServer), "443" !== GE("STATS_COLLECTOR_PORT").toString() && Pg.setProxyServer(this._joinInfo.proxyServer);
                return Pg.reportApiInvoke(this._sessionId, { name: _f.JOIN_FALLBACK_TO_PROXY, options: [this._joinInfo.proxyServer], tag: Ef.TRACER }).onSuccess(), this.safeEmit(yf.JOIN_FALLBACK_TO_PROXY, this._joinInfo.proxyServer), GE("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE") && this._joinInfo.turnServer.servers.forEach((e4) => {
                  "forceturn" in e4 && (e4.forceturn = true);
                }), this._gateway.join(this._joinInfo, this._key);
              }
              if (OE.info("[".concat(this._clientId, "] join by datachannel timeout, fallback to websocket")), !this._joinInfo || !this._key)
                throw new SE(fE.INVALID_OPERATION);
              return Pg.reportApiInvoke(this._sessionId, { name: _f.DATACHANNEL_FAILBACK, options: [this.store.clientId], tag: Ef.TRACER }).onSuccess(), this._joinGateway();
            }
            return e2;
          }).then((e2) => e2);
        }
        async leave() {
          OE.info("[".concat(this._clientId, "] Leaving channel")), window.removeEventListener(Hh() ? "beforeunload" : "pagehide", this._handleBeforeUnload), this._reset(), function(e3) {
            const t2 = zE.indexOf(e3);
            -1 !== t2 && zE.splice(t2, 1);
          }(this);
          const e2 = await this._leaveMutex.lock();
          if ("DISCONNECTED" === this.connectionState)
            return OE.info("[".concat(this._clientId, "] Leaving channel repeated, success")), void e2();
          await this._gateway.leave("CONNECTED" !== this.connectionState), OE.info("[".concat(this._clientId, "] Leaving channel success")), this._joinAndNotLeaveYet = false, this.store.resetJoinChannelServiceRecords(), e2();
        }
        async publish(e2) {
          let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (Array.isArray(e2) || (e2 = [e2]), 0 === e2.length)
            throw new SE(fE.INVALID_PARAMS, "track list is empty");
          if ("audience" === this._gateway.role)
            throw new SE(fE.INVALID_OPERATION, "audience can not publish stream");
          for (const i3 of e2) {
            if (!(i3 instanceof Vg))
              throw new SE(fE.INVALID_PARAMS, "parameter is not local track");
            if (!i3._enabled && t2)
              throw new SE(fE.TRACK_IS_DISABLED, "can not publish a disabled track: ".concat(i3.getTrackId()));
          }
          OE.info("[".concat(this._clientId, "] Publishing tracks, id ").concat(e2.map((e3) => "".concat(e3.getTrackId(), " "))));
          const i2 = await this._publishMutex.lock();
          await this._configDistribute.awaitConfigDistributeComplete(), t2 && e2.forEach((e3) => {
            const t3 = this._configDistribute.getBitrateLimit();
            e3 instanceof Cy && t3 && e3.setBitrateLimit(t3.uplink);
          });
          try {
            await this._publishHighStream(e2), OE.info("[".concat(this._clientId, "] Publish success, id ").concat(e2.map((e3) => "".concat(e3.getTrackId(), " "))));
          } catch (e3) {
            throw OE.error("[".concat(this._clientId, "] publish error"), e3.toString()), e3;
          } finally {
            i2();
          }
        }
        async unpublish(e2) {
          if (!this._joinInfo || void 0 === this._uid)
            throw new SE(fE.INVALID_OPERATION, "Can't unpublish stream, haven't joined yet!");
          e2 ? Array.isArray(e2) || (e2 = [e2]) : e2 = this._p2pChannel.getAllTracks(true), OE.info("[".concat(this._clientId, "] Unpublish tracks, tracks ").concat(e2.map((e3) => "".concat(e3.getTrackId(), " ")), " "));
          const t2 = await this._publishMutex.lock();
          try {
            const i2 = await this._p2pChannel.unpublish(e2);
            i2 && await this._gateway.unpublish(i2, this._uid), OE.info("[".concat(this._clientId, "] Unpublish success,tracks ").concat(e2.map((e3) => "".concat(e3.getTrackId()))));
          } catch (e3) {
            throw OE.error("[".concat(this._clientId, "] unpublish error"), e3.toString()), e3;
          } finally {
            t2 && t2();
          }
        }
        async subscribe(e2, t2) {
          return this._subscribe(e2, t2);
        }
        async _subscribe(e2, t2, i2) {
          if (Ym(t2, "mediaType", ["audio", "video"]), !this._joinInfo)
            throw new SE(fE.INVALID_OPERATION, "Can't subscribe stream, not joined");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
            throw new SE(fE.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
          if (!this._users.find((t3) => t3 === e2)) {
            const t3 = new SE(fE.INVALID_REMOTE_USER, "user is not in the channel");
            throw OE.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", this user is not in the channel")), t3;
          }
          if (!e2.hasAudio && !e2.hasVideo) {
            const t3 = new SE(fE.INVALID_REMOTE_USER, "user is not published");
            throw OE.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", user is not published")), t3;
          }
          if (!(i2 || ("audio" !== t2 || e2.hasAudio && void 0 !== e2._audioSSRC) && ("video" !== t2 || e2.hasVideo && void 0 !== e2._videoSSRC))) {
            const i3 = new SE(fE.REMOTE_USER_IS_NOT_PUBLISHED);
            throw OE.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType ").concat(t2, ", remote track is not published")), i3;
          }
          const n2 = "audio" === t2 ? e2._audioSSRC : e2._videoSSRC, r2 = "audio" === t2 ? e2._audioOrtc : e2._videoOrtc, o2 = "video" === t2 ? e2._rtxSsrcId : void 0, s2 = { stream_type: "audio" === t2 ? AS.AUDIO : AS.VIDEO, ssrcId: n2 }, a2 = await this._subscribeMutex.lock();
          OE.info("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, ", mediaType: ").concat(t2));
          try {
            if (await this._p2pChannel.hasRemoteMediaWithLock(e2, t2))
              await this._p2pChannel.unmuteRemote(e2, t2);
            else
              try {
                DI.markSubscribeStart(this.store.clientId, n2), this.store.subscribe(e2.uid, t2, Date.now()), await this._p2pChannel.subscribe(e2, t2, n2, o2, r2);
                try {
                  await this._gateway.subscribe(e2.uid, s2, true);
                } catch (i4) {
                  if ((null == i4 ? void 0 : i4.code) !== fE.WS_ABORT)
                    throw await this._p2pChannel.unsubscribe(e2, t2), i4;
                  await this._p2pChannel.unsubscribe(e2, t2, true), this._p2pChannel.setPendingRemoteMedia(e2, t2);
                }
                this.store.subscribe(e2.uid, t2, void 0, Date.now()), this._p2pChannel.reportSubscribeEvent(true, null, e2, t2);
              } catch (i4) {
                throw this._p2pChannel.reportSubscribeEvent(false, null == i4 ? void 0 : i4.code, e2, t2), i4;
              }
            OE.info("[".concat(this._clientId, "] subscribe success user ").concat(e2.uid, ", mediaType: ").concat(t2)), this._defaultStreamFallbackType && this.setStreamFallbackOption(e2.uid, this._defaultStreamFallbackType).catch((e3) => {
              OE.warning("[".concat(this._clientId, "] auto set fallback failed"), e3);
            });
            const i3 = "audio" === t2 ? e2._audioTrack : e2._videoTrack;
            if (!i3)
              throw new SE(fE.UNEXPECTED_ERROR, "can not find remote track in user object");
            return i3;
          } catch (t3) {
            throw OE.error("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, " error"), t3), t3;
          } finally {
            a2();
          }
        }
        async massSubscribe(e2) {
          if (zm(e2, "subscribeList"), !this._joinInfo)
            throw new SE(fE.INVALID_OPERATION, "Can't subscribe stream, not joined");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
            throw new SE(fE.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
          const t2 = Date.now(), i2 = /* @__PURE__ */ new Map(), n2 = await this._subscribeMutex.lock();
          OE.info("[".concat(this._clientId, "]start massSubscribe user ").concat(e2.map((e3) => {
            let { user: t3, mediaType: i3 } = e3;
            return "user: ".concat(null == t3 ? void 0 : t3.uid, ", mediaType: ").concat(i3);
          }).join("; ")));
          const r2 = (e2 = [...e2]).map((e3) => {
            let { user: t3, mediaType: i3 } = e3;
            return { user: t3, mediaType: i3 };
          }), o2 = await this._p2pChannel.globalLock();
          try {
            var s2;
            for (let t3 = e2.length - 1; t3 >= 0; t3--) {
              const n3 = e2[t3], { user: o3, mediaType: s3 } = n3;
              if (Ym(s3, "mediaType", ["audio", "video"]), !o3) {
                const e3 = new SE(fE.INVALID_PARAMS, "user property does not exist in subscribeList item");
                throw OE.error("[".concat(this._clientId, "] user property does not exist in subscribeList item")), e3;
              }
              if (!this._users.find((e3) => e3 === o3)) {
                const i3 = new SE(fE.INVALID_REMOTE_USER, "user is not in the channel");
                OE.error("[".concat(this._clientId, "] can not massSubscribe ").concat(o3.uid, ", this user is not in the channel")), r2[t3].error = i3, e2.splice(t3, 1);
                continue;
              }
              if ("audio" === s3 && (!o3.hasAudio || void 0 === o3._audioSSRC) || "video" === s3 && (!o3.hasVideo || void 0 === o3._videoSSRC)) {
                const i3 = new SE(fE.REMOTE_USER_IS_NOT_PUBLISHED);
                OE.error("[".concat(this._clientId, "] can not subscribe ").concat(o3.uid, " with mediaType ").concat(s3, ", remote user is not published")), r2[t3].error = i3, e2.splice(t3, 1);
                continue;
              }
              const a3 = cS.Video | cS.LwoVideo, c2 = i2.get(o3);
              if (c2) {
                if ("video" === s3 ? c2 & a3 : c2 & cS.Audio) {
                  e2.splice(t3, 1), OE.warning("[".concat(this._clientId, "] repeat massSubscribe user:").concat(o3.uid, ", mediaType:").concat(s3, " twice"));
                  continue;
                }
                i2.set(o3, c2 | ("video" === s3 ? a3 : cS.Audio));
              } else
                i2.set(o3, "video" === s3 ? a3 : cS.Audio);
            }
            for (let t3 = e2.length - 1; t3 >= 0; t3--) {
              const n3 = e2[t3], { user: r3, mediaType: o3 } = n3, s3 = cS.Video | cS.LwoVideo;
              if (this._p2pChannel.hasRemoteMedia(r3, o3)) {
                await this._p2pChannel.unmuteRemoteNoLock(r3, o3);
                const n4 = i2.get(r3);
                i2.set(r3, "video" === o3 ? n4 ^ s3 : n4 ^ cS.Audio), e2.splice(t3, 1);
              }
            }
            this.store.massSubscribe(e2.map((e3) => ({ userId: e3.user.uid, type: e3.mediaType })), t2);
            const a2 = zi(s2 = Array.from(i2.entries())).call(s2, (e3, t3) => {
              let [i3, n3] = t3;
              if (0 === n3)
                return e3;
              const r3 = { stream_id: i3.uid, stream_type: n3 };
              return n3 & cS.Audio && (r3.audio_ssrc = i3._audioSSRC), n3 & cS.Video && (r3.video_ssrc = i3._videoSSRC), e3.push(r3), e3;
            }, []);
            try {
              e2.length > 0 && await this._p2pChannel.massSubscribeNoLock(e2.map((e3) => {
                let { user: t3, mediaType: i4 } = e3;
                return { user: t3, mediaType: i4, ssrcId: i4 === AS.VIDEO ? t3._videoSSRC : t3._audioSSRC, rtxSsrcId: i4 === AS.VIDEO ? t3._rtxSsrcId : void 0 };
              }));
              const i3 = /* @__PURE__ */ new Map();
              if (a2.length > 0) {
                const e3 = await this._gateway.subscribeAll(a2, true);
                ((null == e3 ? void 0 : e3.users) || []).forEach((e4) => {
                  let { stream_id: t3, video_error_code: n3, audio_error_code: r3, error_code: o3 } = e4;
                  (n3 || r3 || o3) && i3.set(t3, { video_error_code: n3, audio_error_code: r3, error_code: o3 });
                });
              }
              if (Array.from(i3.entries()).length > 0) {
                const e3 = Array.from(i3.entries()).map((e4) => {
                  let t3, [i4, n3] = e4;
                  n3.error_code || n3.video_error_code && n3.audio_error_code ? t3 = void 0 : n3.video_error_code ? t3 = AS.VIDEO : n3.audio_error_code && (t3 = AS.AUDIO);
                  return { user: this.remoteUsers.find((e5) => e5.uid === i4), mediaType: t3 };
                });
                await this._p2pChannel.massUnsubscribeNoLock(e3);
              }
              for (const e3 of r2) {
                const t3 = i3.get(e3.user.uid);
                if (t3) {
                  const i4 = t3.error_code || "audio" === e3.mediaType && t3.audio_error_code || "video" === e3.mediaType && t3.video_error_code;
                  if (i4) {
                    const t4 = IC(i4);
                    OE.error("user:".concat(e3.user.uid, " mediaType:").concat(e3.mediaType, " has massSubscribe error ").concat(t4.desc)), e3.error = new SE(fE.SUBSCRIBE_FAILED, "code ".concat(i4, ": ").concat(t4.desc));
                  }
                }
                e3.error || ("video" === e3.mediaType ? e3.track = e3.user.videoTrack : e3.track = e3.user.audioTrack);
              }
              return this.store.massSubscribe(r2.filter((e3) => !e3.error).map((e3) => ({ userId: e3.user.uid, type: e3.mediaType })), void 0, Date.now()), r2.forEach((e3) => {
                var i4;
                Pg.subscribe(this.store.sessionId, { succ: !!e3.error, ec: (null === (i4 = e3.error) || void 0 === i4 ? void 0 : i4.code) || null, video: e3.mediaType === AS.VIDEO, audio: e3.mediaType === AS.AUDIO, peerid: e3.user.uid, subscribeRequestid: e3.mediaType === AS.VIDEO ? e3.user._videoSSRC : e3.user._audioSSRC, p2pid: this.store.p2pId, eventElapse: Math.floor(performance.now() - t2) }, true);
              }), OE.info("[".concat(this._clientId, "] massSubscribe success ").concat(e2.map((e3) => {
                let { user: t3, mediaType: i4 } = e3;
                return "user: ".concat(null == t3 ? void 0 : t3.uid, ", mediaType: ").concat(i4);
              }).join("; "))), r2;
            } catch (t3) {
              throw await this._p2pChannel.massUnsubscribeNoLock(e2), t3;
            }
          } finally {
            o2(), n2();
          }
        }
        async unsubscribe(e2, t2) {
          if (t2 && Ym(t2, "mediaType", ["audio", "video"]), !this._joinInfo)
            throw new SE(fE.INVALID_OPERATION, "Can't unsubscribe stream, haven't joined yet!");
          if (!this._users.find((t3) => t3 === e2)) {
            const t3 = new SE(fE.INVALID_REMOTE_USER, "user is not in the channel");
            throw OE.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e2.uid, ", user is not in the channel")), t3;
          }
          OE.info("[".concat(this._clientId, "] unsubscribe uid: ").concat(e2.uid, ", mediaType: ").concat(t2));
          const i2 = await this._subscribeMutex.lock();
          try {
            const n2 = await this._p2pChannel.unsubscribe(e2, t2);
            n2 && await this._gateway.unsubscribe(n2, e2.uid), OE.info("[".concat(this._clientId, "] unsubscribe success uid: ").concat(e2.uid, ", mediaType: ").concat(t2));
          } catch (t3) {
            if (t3.code === fE.DISCONNECT_P2P)
              return void OE.warning("disconnecting p2p, abort unsubscribe request.");
            throw OE.error("[".concat(this._clientId, "] unsubscribe user ").concat(e2.uid, " error"), t3.toString()), t3;
          } finally {
            i2();
          }
        }
        async massUnsubscribe(e2) {
          if (zm(e2, "unsubscribeList"), !this._joinInfo)
            throw new SE(fE.INVALID_OPERATION, "Can't unsubscribeAll stream, haven't joined yet!");
          OE.info("[".concat(this._clientId, "] start massUnsubscribe ").concat(e2.map((e3) => {
            let { user: t3, mediaType: i2 } = e3;
            return "user: ".concat(null == t3 ? void 0 : t3.uid, ", mediaType: ").concat(i2, ";");
          }).join())), e2 = [...e2];
          const t2 = /* @__PURE__ */ new Map();
          for (let i2 = e2.length - 1; i2 >= 0; i2--) {
            const { user: n2, mediaType: r2 } = e2[i2];
            if (!n2) {
              const e3 = new SE(fE.INVALID_PARAMS, "user property does not exist in unsubscribeList item");
              throw OE.error("[".concat(this._clientId, "] user property does not exist in unsubscribeList item")), e3;
            }
            Ym(r2, "mediaType", ["video", "audio", void 0]);
            if (!this._users.find((e3) => e3 === n2)) {
              OE.warning("[".concat(this._clientId, "] can not unsubscribe ").concat(n2.uid, ", user is not in the channel")), e2.splice(i2, 1);
              continue;
            }
            const o2 = cS.Video | cS.LwoVideo;
            if (t2.has(n2)) {
              const s2 = t2.get(n2);
              let a2;
              switch (r2) {
                case "video":
                  a2 = s2 & o2;
                  break;
                case "audio":
                  a2 = s2 & cS.Audio;
                  break;
                default:
                  a2 = s2 & (cS.Audio | o2);
              }
              if (a2) {
                OE.warning("[".concat(this._clientId, "] repeat massUnsubscribe user:").concat(n2.uid, ",mediaType:").concat(r2, " twice.")), e2.splice(i2, 1);
                continue;
              }
              r2 ? "audio" === r2 ? t2.set(n2, s2 | cS.Audio) : "video" === r2 && t2.set(n2, s2 | o2) : t2.set(n2, s2 | cS.Audio | o2);
            } else
              r2 ? "audio" === r2 ? t2.set(n2, cS.Audio) : "video" === r2 && t2.set(n2, o2) : t2.set(n2, cS.Audio | o2);
          }
          try {
            const t3 = await this._p2pChannel.massUnsubscribe(e2);
            t3 && await this._gateway.massUnsubscribe(t3), OE.info("[".concat(this._clientId, "] massUnsubscribe success ").concat(e2.map((e3) => {
              let { user: t4, mediaType: i2 } = e3;
              return "user: ".concat(null == t4 ? void 0 : t4.uid, ", mediaType: ").concat(i2, ";");
            }).join()));
          } catch (e3) {
            if (e3.code === fE.DISCONNECT_P2P)
              return void OE.warning("[".concat(this._clientId, "] disconnecting p2p, abort unsubscribe request."));
            throw OE.error("[".concat(this._clientId, "] massUnsubscribe error"), e3.toString()), e3;
          }
        }
        setLowStreamParameter(e2) {
          !function(e3) {
            if (!e3)
              throw new SE(fE.INVALID_PARAMS);
            $m(e3.width) || Jm(e3.width, "streamParameter.width"), $m(e3.height) || Jm(e3.height, "streamParameter.height"), $m(e3.framerate) || Jm(e3.framerate, "streamParameter.framerate"), $m(e3.bitrate) || qm(e3.bitrate, "streamParameter.bitrate");
          }(e2), (!e2.width && e2.height || e2.width && !e2.height) && OE.warning("[".concat(this._clientId, "] The width and height parameters take effect only when both are set")), OE.info("[".concat(this._clientId, "] set low stream parameter to"), JSON.stringify(e2));
          const t2 = this._configDistribute.getLowStreamConfigDistribute();
          t2 && t2.bitrate && e2.bitrate && t2.bitrate < e2.bitrate && (e2.bitrate = t2.bitrate), this._lowStreamParameter = e2;
        }
        async enableDualStream() {
          if (!JS().supportDualStream)
            throw Pg.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: false }), new SE(fE.NOT_SUPPORTED, "Your browser is not support dual stream");
          if (this._isDualStreamEnabled)
            throw new SE(fE.INVALID_OPERATION, "Dual stream is already enabled");
          if (this._p2pChannel.canPublishLowStream())
            try {
              await this._publishLowStream();
            } catch (e2) {
              throw Pg.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: false }), e2;
            }
          this._isDualStreamEnabled = true, Pg.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: true }), OE.info("[".concat(this._clientId, "] enable dual stream"));
        }
        async disableDualStream() {
          if (this._isDualStreamEnabled) {
            if (!this._joinInfo)
              throw new SE(fE.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
            if (this._p2pChannel.getLocalMedia(bS.LocalVideoLowTrack))
              try {
                const e2 = await this._p2pChannel.unpublishLowStream();
                e2 && await this._gateway.unpublish(e2, this._joinInfo.stringUid || this._joinInfo.uid);
              } catch (e2) {
                throw Pg.streamSwitch(this._sessionId, { lts: Date.now(), isdual: false, succ: false }), e2;
              }
            this._isDualStreamEnabled = false, Pg.streamSwitch(this._sessionId, { lts: Date.now(), isdual: false, succ: true }), OE.info("[".concat(this._clientId, "] disable dual stream"));
          }
        }
        async setClientRole(e2, t2) {
          if (function(e3) {
            Ym(e3, "role", ["audience", "host"]);
          }(e2), t2 && Vf(t2), "rtc" === this.mode)
            throw OE.warning("[".concat(this._clientId, "]rtc mode can not use setClientRole")), new SE(fE.INVALID_OPERATION, "rtc mode can not use setClientRole");
          if (t2 && t2.level && "host" === e2)
            throw new SE(fE.INVALID_OPERATION, "host mode can not set audience latency level");
          if ("audience" === e2 && this._p2pChannel.hasLocalMedia())
            throw new SE(fE.INVALID_OPERATION, "can not set client role to audience when publishing stream");
          await this._gateway.setClientRole(e2, t2), this._config.role = e2, OE.info("[".concat(this._clientId, "] set client role to ").concat(e2, ", level: ").concat(t2 && t2.level));
        }
        setProxyServer(e2, t2) {
          if (Xm(e2, "proxyServer"), !t2) {
            if ("DISCONNECTED" !== this.connectionState)
              throw new SE(fE.INVALID_OPERATION, "Set proxy server before join channel");
            if ("disabled" !== this._cloudProxyServerMode || this._useLocalAccessPoint)
              throw new SE(fE.INVALID_OPERATION, "You have already set the proxy");
          }
          this._proxyServer = e2, Pg.setProxyServer(this._proxyServer), OE.setProxyServer(this._proxyServer), OE.info("[".concat(this._clientId, "] Set proxy server ").concat(t2 ? "by initialize call" : "", " success."));
        }
        setTurnServer(e2, t2) {
          if (Array.isArray(e2) || (e2 = [e2]), !t2) {
            if ("DISCONNECTED" !== this.connectionState)
              throw new SE(fE.INVALID_OPERATION, "Set turn server before join channel");
            if ("disabled" !== this._cloudProxyServerMode || this._useLocalAccessPoint)
              throw new SE(fE.INVALID_OPERATION, "You have already set the proxy");
          }
          if (Uf(e2))
            return this._turnServer = { servers: e2, mode: "original-manual" }, void OE.info("[".concat(this._clientId, "] Set original turnserver ").concat(t2 ? "by initialize call" : "", " success: ").concat(e2.map((e3) => e3.urls).join(","), "."));
          e2.forEach((e3) => xf(e3)), this._turnServer = { servers: e2, mode: "manual" }, OE.info("[".concat(this._clientId, "] Set turnserver ").concat(t2 ? "by initialize call" : "", " success."));
        }
        setLicense(e2) {
          if ("DISCONNECTED" !== this.connectionState) {
            throw new SE(fE.INVALID_OPERATION, "you should set license before join channel");
          }
          if (Xm(e2, "license", 32, 32), !/^[A-Za-z\d]+$/.test(e2))
            throw new SE(fE.INVALID_PARAMS, "license should only contains characters from A-Z a-z 0-9");
          this._license = e2, OE.info("[".concat(this._clientId, "] set license success"), e2);
        }
        startProxyServer(e2) {
          if ("DISCONNECTED" !== this.connectionState)
            throw new SE(fE.INVALID_OPERATION, "Start proxy server before join channel");
          if (this._proxyServer || "manual" === this._turnServer.mode || this._useLocalAccessPoint)
            throw new SE(fE.INVALID_OPERATION, "You have already set the proxy");
          const t2 = [3, 4, 5];
          let i2;
          switch (void 0 === e2 && (e2 = 3), e2) {
            case 1:
            case 2:
              throw new SE(fE.NOT_SUPPORTED, "proxy mode 1/2 has been deprecated and not supported.");
            case 3:
              i2 = "proxy3";
              break;
            case 4:
              i2 = "proxy4";
              break;
            case 5:
              i2 = "proxy5";
              break;
            default:
              throw new SE(fE.INVALID_PARAMS, "proxy server mode must be ".concat(t2.join("|")));
          }
          this._cloudProxyServerMode = i2, this.store.cloudProxyServerMode = i2, OE.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode);
        }
        stopProxyServer() {
          if ("DISCONNECTED" !== this.connectionState)
            throw new SE(fE.INVALID_OPERATION, "Stop proxy server after leave channel");
          Pg.setProxyServer(), OE.setProxyServer(), this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled", OE.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode), this._proxyServer = void 0, this._turnServer = { mode: "auto", servers: [] };
        }
        setLocalAccessPointsV2(e2) {
          if (!e2.accessPoints)
            throw new SE(fE.INVALID_PARAMS, "accessPoints is required.");
          zm(e2.accessPoints.serverList, "accessPoints.serverList"), Xm(e2.accessPoints.domain, "accessPoints.domain");
          const t2 = (e3, t3) => {
            qm(e3, t3, 0, 65535, true);
          };
          let i2 = 443;
          if (e2.accessPoints.port && (t2(e2.accessPoints.port, "accessPoints.port"), i2 = e2.accessPoints.port), this._proxyServer || "disabled" !== this._cloudProxyServerMode)
            throw new SE(fE.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
          GE("CLOSE_AFB_FOR_LOCAL_AP") && (BE("JOIN_WITH_FALLBACK_SIGNAL_PROXY", false), BE("JOIN_WITH_FALLBACK_MEDIA_PROXY", false));
          const n2 = /^((\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/, r2 = e2.accessPoints.domain, o2 = e2.accessPoints.serverList.map((e3) => n2.test(e3) ? "".concat(e3.replace(/\./g, "-"), ".").concat(r2) : e3), s2 = o2.map((e3) => "".concat(e3, ":").concat(i2));
          this._useLocalAccessPoint = true, this._setLocalAPVersion = 2, BE("WEBCS_DOMAIN", s2), BE("WEBCS_DOMAIN_BACKUP_LIST", s2), BE("GATEWAY_DOMAINS", [r2]), e2.report && e2.report.hostname && Array.isArray(e2.report.hostname) && e2.report.hostname.length ? (zm(e2.report.hostname, "report.hostname"), BE("EVENT_REPORT_DOMAIN", e2.report.hostname[0]), BE("EVENT_REPORT_BACKUP_DOMAIN", e2.report.hostname[1] || e2.report.hostname[0])) : (BE("EVENT_REPORT_DOMAIN", o2[0]), BE("EVENT_REPORT_BACKUP_DOMAIN", o2[1] || o2[0]));
          let a2 = 6443;
          e2.report && e2.report.port && (t2(e2.report.port, "report.port"), a2 = e2.report.port), BE("STATS_COLLECTOR_PORT", a2), e2.report ? BE("ENABLE_EVENT_REPORT", true) : BE("ENABLE_EVENT_REPORT", false);
          let c2 = "";
          e2.log && e2.log.hostname && Array.isArray(e2.log.hostname) && e2.log.hostname.length ? (zm(e2.log.hostname, "log.hostname"), c2 = e2.log.hostname[0]) : c2 = o2[0];
          let d2 = 6444;
          e2.log && e2.log.port && (t2(e2.log.port, "log.port"), d2 = e2.log.port), BE("LOG_UPLOAD_SERVER", "".concat(c2, ":").concat(d2));
          let u2 = [];
          e2.cds && e2.cds.hostname && Array.isArray(e2.cds.hostname) && e2.cds.hostname.length ? (zm(e2.cds.hostname, "cds.hostname"), u2 = e2.cds.hostname) : u2 = o2;
          let l2 = 443;
          e2.cds && e2.cds.port && (t2(e2.cds.port, "cds.port"), l2 = e2.cds.port), BE("CDS_AP", u2.map((e3) => "".concat(e3, ":").concat(l2))), e2.cds ? BE("ENABLE_CONFIG_DISTRIBUTE", true) : BE("ENABLE_CONFIG_DISTRIBUTE", false), OE.info("set local access point v2 success");
        }
        setLocalAccessPoints(e2, t2) {
          if (zm(e2, "serverList"), Xm(t2, "domain"), this._proxyServer || "disabled" !== this._cloudProxyServerMode)
            throw new SE(fE.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
          const i2 = /^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/;
          e2 = e2.map((e3) => i2.test(e3) ? "".concat(e3.replace(/\./g, "-"), ".").concat(t2) : e3), this._useLocalAccessPoint = true, this._setLocalAPVersion = 1, BE("WEBCS_DOMAIN", e2), BE("WEBCS_DOMAIN_BACKUP_LIST", e2), BE("GATEWAY_DOMAINS", [t2]), BE("EVENT_REPORT_DOMAIN", e2[0]), BE("EVENT_REPORT_BACKUP_DOMAIN", e2[1] || e2[0]), BE("LOG_UPLOAD_SERVER", "".concat(e2[0], ":6444")), OE.info("[".concat(this._clientId, "] set local access point success"));
        }
        async setRemoteDefaultVideoStreamType(e2) {
          if (Ym(e2, "streamType", [0, 1]), this._remoteDefaultVideoStreamType = e2, this._joinInfo)
            try {
              await this._gateway.setDefaultRemoteVideoStreamType(e2), this._joinInfo.defaultVideoStream = this._remoteDefaultVideoStreamType;
            } catch (e3) {
              throw OE.error("[".concat(this._clientId, "] set default remote video stream type error"), e3.toString()), e3;
            }
          else
            OE.debug("[".concat(this._clientId, "] haven't joined yet, cache remoteDefaultVideoStreamType ").concat(e2));
        }
        async setRemoteVideoStreamType(e2, t2) {
          Ym(t2, "streamType", [0, 1]);
          try {
            await this._gateway.setRemoteVideoStreamType(e2, t2), setTimeout(() => {
              const t3 = this._users.find((t4) => t4.uid === e2);
              t3 && t3.videoTrack && t3.videoTrack.updateMediaStreamTrackResolution();
            }, 2e3);
          } catch (e3) {
            throw OE.error("[".concat(this._clientId, "] set remote video stream type error"), e3.toString()), e3;
          }
          OE.info("[".concat(this._clientId, "] set remote ").concat(e2, " video stream type to ").concat(t2)), this._remoteStreamTypeCacheMap.set(e2, t2);
        }
        async setStreamFallbackOption(e2, t2) {
          Ym(t2, "fallbackType", [0, 1, 2]);
          try {
            await this._gateway.setStreamFallbackOption(e2, t2);
          } catch (e3) {
            throw OE.error("[".concat(this._clientId, "] set stream fallback option"), e3.toString()), e3;
          }
          OE.info("[".concat(this._clientId, "] set remote ").concat(e2, " stream fallback type to ").concat(t2)), this._streamFallbackTypeCacheMap.set(e2, t2);
        }
        setEncryptionConfig(e2, t2, i2) {
          !function(e3) {
            Ym(e3, "encryptionMode", ["aes-128-xts", "aes-256-xts", "aes-128-ecb", "sm4-128-ecb", "aes-128-gcm", "aes-256-gcm", "aes-128-gcm2", "aes-256-gcm2", "none"]);
          }(e2), Xm(t2, "secret");
          if (["aes-128-gcm2", "aes-256-gcm2"].includes(e2)) {
            if (!i2 || !(i2 instanceof Uint8Array && 32 === i2.length))
              throw new SE(fE.INVALID_PARAMS, "salt must be an Uint8Array and exactly equal to 32 bytes");
          } else if (i2)
            throw new SE(fE.INVALID_PARAMS, "current encrypt mode does not need salt");
          new RegExp(`^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*,.<>?/:;'"|{}\\[\\]])(?=.{8,})`).test(t2) || OE.warning("The secret is not strong:\n      The secret must contain at least 1 lowercase alphabetical character,\n      The secret must contain at least 1 uppercase alphabetical character,\n      The secret must contain at least 1 numeric character,\n      The secret must contain at least one special character,\n      The secret must be eight characters or longer.\n      "), this._encryptionMode = e2, this._encryptionSecret = t2, i2 && (this._encryptionSalt = _C(i2));
        }
        async renewToken(e2) {
          if (Xm(e2, "token", 1, 2047), !this._key || !this._joinInfo)
            throw new SE(fE.INVALID_OPERATION, "renewToken should not be called before user join");
          const t2 = this._key;
          this._key = e2, this._joinInfo && (this._joinInfo.token = e2);
          const i2 = await this._renewTokenMutex.lock();
          try {
            if (GE("USE_NEW_TOKEN")) {
              OE.debug("[".concat(this._clientId, "] start renew token with ticket from unilbs"));
              const t3 = await _v(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || TE);
              OE.debug("[".concat(this._clientId, "] get ticket from unilbs success")), await this._gateway.renewToken({ token: e2, ticket: t3 });
            } else
              OE.debug("[".concat(this._clientId, "] start renew token without ticket")), await this._gateway.renewToken({ token: e2 });
            OE.debug("[".concat(this._clientId, "] renewToken success"));
          } catch (e3) {
            throw this._key = t2, this._joinInfo.token = t2, OE.error("[".concat(this._clientId, "] renewToken failed"), e3.toString()), e3;
          } finally {
            i2();
          }
        }
        enableAudioVolumeIndicator() {
          this._audioVolumeIndicationInterval ? OE.warning("you have already enabled audio volume indicator!") : this._audioVolumeIndicationInterval = window.setInterval(() => {
            const e2 = this._p2pChannel.getAudioLevels();
            this.safeEmit(yf.VOLUME_INDICATOR, e2);
          }, GE("AUDIO_VOLUME_INDICATION_INTERVAL") || 2e3);
        }
        getRTCStats() {
          const e2 = this._statsCollector.getRTCStats(), t2 = this._gateway.getInChannelInfo();
          return e2.Duration = Math.round(t2.duration / 1e3), e2;
        }
        async startLiveStreaming(e2, t2) {
          if (!t2) {
            if ("h264" !== this.codec)
              throw new SE(fE.LIVE_STREAMING_INVALID_RAW_STREAM, "raw streaming is only support h264");
            if (!this._p2pChannel.hasLocalMedia())
              throw new SE(fE.LIVE_STREAMING_INVALID_RAW_STREAM, "can not find stream to raw streaming");
          }
          if (this._liveRawStreamingClient && this._liveRawStreamingClient.hasUrl(e2) || this._liveTranscodeStreamingClient && this._liveTranscodeStreamingClient.hasUrl(e2))
            throw new SE(fE.LIVE_STREAMING_TASK_CONFLICT);
          const i2 = t2 ? Kf.TRANSCODE : Kf.RAW;
          return this._createLiveStreamingClient(i2).startLiveStreamingTask(e2, i2);
        }
        setLiveTranscoding(e2) {
          return this._createLiveStreamingClient(Kf.TRANSCODE).setTranscodingConfig(e2);
        }
        async stopLiveStreaming(e2) {
          const t2 = [this._liveRawStreamingClient, this._liveTranscodeStreamingClient].filter((t3) => t3 && t3.hasUrl(e2));
          if (!t2.length)
            throw new SE(fE.INVALID_PARAMS, "can not find live streaming url to stop");
          await Sl.all(t2.map((t3) => t3 && t3.stopLiveStreamingTask(e2)));
        }
        async addInjectStreamUrl(e2, t2) {
          if (!this._joinInfo)
            throw new SE(fE.INVALID_OPERATION, "can not addInjectStreamUrl, no joininfo");
          const i2 = this._createLiveStreamingClient(Kf.INJECT);
          i2.setInjectStreamConfig(t2, 0), await i2.startLiveStreamingTask(e2, Kf.INJECT);
        }
        async removeInjectStreamUrl() {
          var e2;
          const t2 = this._createLiveStreamingClient(Kf.INJECT), i2 = Array.from(IR(e2 = t2.streamingTasks).call(e2)).find((e3) => e3.mode === Kf.INJECT);
          if (!this._joinInfo || !i2)
            throw new SE(fE.INVALID_OPERATION, "can remove addInjectStreamUrl, no joininfo or inject task");
          await t2.stopLiveStreamingTask(i2.url);
        }
        async startChannelMediaRelay(e2) {
          yv(e2);
          const t2 = this._createChannelMediaRelayClient();
          await t2.startChannelMediaRelay(e2);
        }
        async updateChannelMediaRelay(e2) {
          yv(e2);
          const t2 = this._createChannelMediaRelayClient();
          await t2.updateChannelMediaRelay(e2);
        }
        async stopChannelMediaRelay() {
          const e2 = this._createChannelMediaRelayClient();
          await e2.stopChannelMediaRelay(), this._statsCollector.onStatsChanged && (this._statsCollector.onStatsChanged = void 0);
        }
        sendStreamMessage(e2) {
          let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (!this._joinInfo)
            throw new SE(fE.INVALID_OPERATION, "can not send data stream, not joined");
          if ("string" == typeof e2) {
            e2 = new TextEncoder().encode(e2);
          }
          if (new Blob([e2]).size > 1024)
            throw new SE(fE.INVALID_PARAMS, "stream message out of range.");
          return this._gateway.signal.request(bf.DATA_STREAM, { payload: _C(e2) }, !t2);
        }
        sendMetadata(e2) {
          if (!this._joinInfo)
            throw new SE(fE.INVALID_OPERATION, "can not send metadata, not joined");
          if (new Blob([e2]).size > 1024)
            throw new SE(fE.METADATA_OUT_OF_RANGE);
          return this._gateway.signal.request(bf.SEND_METADATA, { session_id: this._joinInfo.sid, metadata: _C(e2) });
        }
        async sendCustomReportMessage(e2) {
          if (Array.isArray(e2) || (e2 = [e2]), e2.forEach(cf), !this._joinInfo)
            throw new SE(fE.INVALID_OPERATION, "can not send custom report, not joined");
          await Pg.sendCustomReportMessage(this._joinInfo.sid, e2);
        }
        getLocalAudioStats() {
          return this._statsCollector.getLocalAudioTrackStats();
        }
        getRemoteAudioStats() {
          return this._statsCollector.getRemoteAudioTrackStats();
        }
        getLocalVideoStats() {
          return this._statsCollector.getLocalVideoTrackStats();
        }
        getRemoteVideoStats() {
          return this._statsCollector.getRemoteVideoTrackStats();
        }
        getRemoteNetworkQuality() {
          return this._statsCollector.getRemoteNetworkQualityStats();
        }
        async pickSVCLayer(e2, t2) {
          Ym(t2.spatialLayer, "spatialLayer", [0, 1, 2, 3]), Ym(t2.temporalLayer, "temporalLayer", [0, 1, 2, 3]);
          try {
            await this._gateway.pickSVCLayer(e2, t2);
          } catch (e3) {
            throw OE.error("[".concat(this._clientId, "] pick SVC layer failed"), e3.toString()), e3;
          }
        }
        _reset() {
          if (OE.debug("[".concat(this._clientId, "] reset client")), this._axiosCancelSource.cancel(), this._axiosCancelSource = pE.CancelToken.source(), this._streamFallbackTypeCacheMap = /* @__PURE__ */ new Map(), this._remoteStreamTypeCacheMap = /* @__PURE__ */ new Map(), this._configDistribute.stopGetConfigDistribute(), this._joinInfo = void 0, this._proxyServer = void 0, this._defaultStreamFallbackType = void 0, this._sessionId = null, this.store.sessionId = null, this._statsCollector.reset(), this._key = void 0, this._appId = void 0, this._uid = void 0, this.store.uid = void 0, this._channelName = void 0, this._encryptionMode = "none", this._encryptionSecret = null, this._encryptionSalt = null, this._users.forEach((e2) => {
            e2._audioTrack && e2._audioTrack._destroy(), e2._videoTrack && e2._videoTrack._destroy();
          }), this._users = [], this._audioVolumeIndicationInterval && (window.clearInterval(this._audioVolumeIndicationInterval), this._audioVolumeIndicationInterval = void 0), "fallback" === this._cloudProxyServerMode && (this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled"), this._p2pChannel.reset(), this._publishMutex = new Ug("client-publish"), this._subscribeMutex = new Ug("client-subscribe"), this._networkQualityInterval && (window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = void 0), this._injectStreamingClient && (this._injectStreamingClient.terminate(), this._injectStreamingClient.removeAllListeners(), this._injectStreamingClient = void 0), this._liveRawStreamingClient && (this._liveRawStreamingClient.terminate(), this._liveRawStreamingClient.removeAllListeners(), this._liveRawStreamingClient = void 0), this._liveTranscodeStreamingClient && (this._liveTranscodeStreamingClient.terminate(), this._liveTranscodeStreamingClient.removeAllListeners(), this._liveTranscodeStreamingClient = void 0), this._channelMediaRelayClient && (this._channelMediaRelayClient.dispose(), this._channelMediaRelayClient = void 0), this._inspect)
            try {
              this._inspect.close(), this._inspect = void 0;
            } catch (e2) {
            }
          if (this._moderation)
            try {
              this.setImageModeration(false);
            } catch (e2) {
            }
        }
        _startSession(e2, t2) {
          const i2 = e2 || $I();
          e2 ? OE.debug("[".concat(this._clientId, "] new Session ").concat(i2)) : OE.debug("[".concat(this._clientId, "] renewSession ").concat(this._sessionId, " => ").concat(i2)), this._sessionId = i2, this.store.sessionId = i2, t2 ? Pg.sessionInit(this._sessionId, { lts: new Date().getTime(), cname: t2.channel, appid: t2.appId, mode: this.mode }) : this._joinInfo ? Pg.sessionInit(this._sessionId, { lts: new Date().getTime(), cname: this._joinInfo.cname, appid: this._joinInfo.appId, mode: this.mode }) : this._gateway.joinInfo && Pg.sessionInit(this._sessionId, { lts: new Date().getTime(), cname: this._gateway.joinInfo.cname, appid: this._gateway.joinInfo.appId, mode: this.mode }), this._joinInfo && (this._joinInfo.sid = i2), this._gateway.joinInfo && (this._gateway.joinInfo.sid = i2);
        }
        async _publishHighStream(e2) {
          if (!this._joinInfo || void 0 === this._uid)
            throw new SE(fE.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
            throw new SE(fE.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
          if ("auto" === this._turnServer.mode && GE("FORCE_TURN") && !GE("TURN_ENABLE_TCP") && !GE("TURN_ENABLE_UDP"))
            throw new SE(fE.UNEXPECTED_ERROR, "force TURN With No TURN Configuration");
          OE.debug("[".concat(this._clientId, "] publish high stream"));
          try {
            const i2 = await this._p2pChannel.publish(e2, this._isDualStreamEnabled, this._lowStreamParameter), n2 = (await i2.next()).value;
            if (n2) {
              var t2;
              let e3;
              try {
                e3 = await this._gateway.publish(this._uid, n2, true);
              } catch (e4) {
                if (e4.code !== fE.DISCONNECT_P2P)
                  throw i2.throw(e4), e4;
              }
              await i2.next((null === (t2 = e3) || void 0 === t2 ? void 0 : t2.ortc) || []);
            }
            this._p2pChannel.reportPublishEvent(true, null);
            for (const t3 of e2)
              t3 instanceof Cy && t3._encoderConfig && this._gateway.setVideoProfile(t3._encoderConfig), !t3.muted && t3.enabled || await this._p2pChannel.muteLocalTrack(t3);
          } catch (t3) {
            if (this._p2pChannel.reportPublishEvent(false, null == t3 ? void 0 : t3.code, e2), (null == t3 ? void 0 : t3.code) === fE.WS_ABORT)
              return;
            throw t3;
          }
        }
        async _publishLowStream() {
          if (!this._joinInfo || void 0 === this._uid)
            throw new SE(fE.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
            throw new SE(fE.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
          OE.debug("[".concat(this._clientId, "] publish low stream"));
          const e2 = this._configDistribute.getLowStreamConfigDistribute();
          e2 && e2.bitrate && (this._lowStreamParameter || (this._lowStreamParameter = { width: 160, height: 120, framerate: 15, bitrate: 50 }), this._lowStreamParameter && this._lowStreamParameter.bitrate && e2.bitrate < this._lowStreamParameter.bitrate && (this._lowStreamParameter.bitrate = e2.bitrate));
          try {
            const e3 = await this._p2pChannel.publishLowStream(this._lowStreamParameter), i2 = (await e3.next()).value;
            if (i2) {
              var t2;
              let n2;
              try {
                n2 = await this._gateway.publish(this._uid, i2, true);
              } catch (t3) {
                if (t3.code !== fE.DISCONNECT_P2P)
                  throw e3.throw(t3), t3;
              }
              e3.next((null === (t2 = n2) || void 0 === t2 ? void 0 : t2.ortc) || []), this._p2pChannel.reportPublishEvent(true, null, void 0, true);
            }
          } catch (e3) {
            if (this._p2pChannel.reportPublishEvent(false, null == e3 ? void 0 : e3.code, void 0, true), (null == e3 ? void 0 : e3.code) === fE.WS_ABORT)
              return;
            throw e3;
          }
        }
        _createLiveStreamingClient(e2) {
          if (!this._joinInfo || !this._appId) {
            return new SE(fE.INVALID_OPERATION, "can not create live streaming client, please join channel first").throw();
          }
          const t2 = () => new Cv(this._joinInfo, this._config.websocketRetryConfig || TE, this._config.httpRetryConfig || TE), i2 = (e3) => {
            e3.onLiveStreamError = (e4, t3) => {
              Pg.reportApiInvoke(this._sessionId, { name: _f.ON_LIVE_STREAM_ERROR, options: [e4, t3], tag: Ef.TRACER }).onSuccess(), this.safeEmit(yf.LIVE_STREAMING_ERROR, e4, t3);
            }, e3.onLiveStreamWarning = (e4, t3) => {
              Pg.reportApiInvoke(this._sessionId, { name: _f.ON_LIVE_STREAM_WARNING, options: [e4, t3], tag: Ef.TRACER }).onSuccess(), this.safeEmit(yf.LIVE_STREAMING_WARNING, e4, t3);
            }, e3.on($f.REQUEST_WORKER_MANAGER_LIST, (e4, t3, i3) => {
              if (!this._joinInfo)
                return i3(new SE(fE.INVALID_OPERATION, "can not find join info to get worker manager"));
              hv(e4, this._joinInfo, this._axiosCancelSource.token, TE).then(t3).catch(i3);
            });
          };
          switch (e2) {
            case Kf.RAW:
              return this._liveRawStreamingClient || (this._liveRawStreamingClient = t2(), i2(this._liveRawStreamingClient)), this._liveRawStreamingClient;
            case Kf.TRANSCODE:
              return this._liveTranscodeStreamingClient || (this._liveTranscodeStreamingClient = t2(), i2(this._liveTranscodeStreamingClient)), this._liveTranscodeStreamingClient;
            case Kf.INJECT:
              return this._injectStreamingClient || (this._injectStreamingClient = t2(), this._injectStreamingClient.on($f.REQUEST_WORKER_MANAGER_LIST, (e3, t3, i3) => {
                if (!this._joinInfo)
                  return i3(new SE(fE.INVALID_OPERATION, "can not find join info to get worker manager"));
                hv(e3, this._joinInfo, this._axiosCancelSource.token, TE).then(t3).catch(i3);
              }), this._injectStreamingClient.onInjectStatusChange = (e3, t3, i3) => {
                this.emit(yf.INJECT_STREAM_STATUS, e3, t3, i3);
              }), this._injectStreamingClient;
          }
        }
        _createChannelMediaRelayClient() {
          if (!this._joinInfo) {
            return new SE(fE.INVALID_OPERATION, "can not create channel media relay client, please join channel first").throw();
          }
          if (!this._channelMediaRelayClient) {
            const { sendResolutionWidth: e2, sendResolutionHeight: t2 } = this.getLocalVideoStats(), i2 = { width: e2, height: t2 };
            this._channelMediaRelayClient = new Ov(this._joinInfo, this._clientId, this._config.websocketRetryConfig || TE, this._config.httpRetryConfig || TE, i2), this._channelMediaRelayClient.on("state", (e3) => {
              e3 === rS.RELAY_STATE_FAILURE && this._channelMediaRelayClient && this._channelMediaRelayClient.dispose(), this.safeEmit(yf.CHANNEL_MEDIA_RELAY_STATE, e3);
            }), this._channelMediaRelayClient.on("event", (e3) => {
              this.safeEmit(yf.CHANNEL_MEDIA_RELAY_EVENT, e3);
            }), this._statsCollector.onStatsChanged = (e3, t3) => {
              var i3;
              "resolution" === e3 && (null === (i3 = this._channelMediaRelayClient) || void 0 === i3 || i3.setVideoProfile(t3));
            };
          }
          return this._channelMediaRelayClient;
        }
        _handleGatewayEvents() {
          this._gateway.on(aS.DISCONNECT_P2P, async () => {
            await this._p2pChannel.disconnectForReconnect();
          }), this._gateway.on(aS.CONNECTION_STATE_CHANGE, (e2, t2, i2) => {
            var n2;
            if (i2 === vf.FALLBACK)
              return;
            const r2 = () => {
              this.safeEmit(yf.CONNECTION_STATE_CHANGE, e2, t2, i2);
            };
            if (Pg.reportApiInvoke(this._sessionId || (null === (n2 = this._gateway.joinInfo) || void 0 === n2 ? void 0 : n2.sid) || null, { name: _f.CONNECTION_STATE_CHANGE, options: [e2, t2, i2], tag: Ef.TRACER }).onSuccess(JSON.stringify({ cur: e2, prev: t2, reason: i2 })), OE.info("[".concat(this._clientId, "] connection state change: ").concat(t2, " -> ").concat(e2)), "DISCONNECTED" === e2)
              return this._reset(), void r2();
            if ("RECONNECTING" === e2)
              this._users.forEach((e3) => {
                e3._trust_in_room_ = false, e3._trust_audio_enabled_state_ = false, e3._trust_video_enabled_state_ = false, e3._trust_audio_mute_state_ = false, e3._trust_video_mute_state_ = false, e3._trust_audio_stream_added_state_ = false, e3._trust_video_stream_added_state_ = false, e3._audioSSRC = void 0, e3._videoSSRC = void 0, e3._videoOrtc = void 0, e3._audioOrtc = void 0, e3._cname = void 0, e3._rtxSsrcId = void 0;
              }), this._userOfflineTimeout && window.clearTimeout(this._userOfflineTimeout), this._streamRemovedTimeout && window.clearTimeout(this._streamRemovedTimeout), this._userOfflineTimeout = void 0, this._streamRemovedTimeout = void 0;
            else if ("CONNECTED" === e2) {
              var o2;
              this._streamFallbackTypeCacheMap.forEach((e3, t3) => {
                this._gateway.setStreamFallbackOption(t3, e3).catch((e4) => {
                  OE.warning("[".concat(this._clientId, "] auto set stream fallback option failed"), e4);
                });
              }), this._remoteStreamTypeCacheMap.forEach((e3, t3) => {
                this._gateway.setRemoteVideoStreamType(t3, e3).catch((e4) => {
                  OE.warning("[".concat(this._clientId, "] auto set remote stream type failed"), e4);
                });
              }), void 0 !== this._remoteDefaultVideoStreamType && void 0 === (null === (o2 = this._joinInfo) || void 0 === o2 ? void 0 : o2.defaultVideoStream) && this.setRemoteDefaultVideoStreamType(this._remoteDefaultVideoStreamType).then(() => {
                OE.debug("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway connected"));
              }).catch((e3) => {
                OE.error("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway failed, ").concat(e3));
              }), this._p2pChannel.republish(), this._userOfflineTimeout = window.setTimeout(() => {
                if ("CONNECTED" !== this.connectionState)
                  return;
                this._userOfflineTimeout = void 0;
                this._users.filter((e3) => !e3._trust_in_room_).forEach((e3) => {
                  OE.debug("[".concat(this._clientId, "] user offline timeout, emit user offline ").concat(e3.uid)), this._handleUserOffline({ uid: e3.uid });
                });
              }, 3e3), this._streamRemovedTimeout = window.setTimeout(() => {
                "CONNECTED" === this.connectionState && (this._streamRemovedTimeout = void 0, this._users.forEach((e3) => {
                  e3._trust_audio_mute_state_ || (OE.debug("[".concat(this._clientId, "] auto dispatch audio unmute event ").concat(e3.uid)), this._handleMuteStream(e3.uid, "audio", false)), e3._trust_video_mute_state_ || (OE.debug("[".concat(this._clientId, "] auto dispatch video unmute event ").concat(e3.uid)), this._handleMuteStream(e3.uid, "video", false)), e3._trust_audio_enabled_state_ || (OE.debug("[".concat(this._clientId, "] auto dispatch enable local audio ").concat(e3.uid)), this._handleSetStreamLocalEnable("audio", e3.uid, true)), e3._trust_video_enabled_state_ || (OE.debug("[".concat(this._clientId, "] auto dispatch enable local video ").concat(e3.uid)), this._handleSetStreamLocalEnable("video", e3.uid, true)), e3._trust_video_stream_added_state_ || (OE.debug("[".concat(this._clientId, "] auto dispatch reset video stream added ").concat(e3.uid)), this._handleResetAddStream(e3, "video")), e3._trust_audio_stream_added_state_ || (OE.debug("[".concat(this._clientId, "] auto dispatch reset audio stream added ").concat(e3.uid)), this._handleResetAddStream(e3, "audio")), e3._video_added_ || e3._audio_added_ || (OE.debug("[".concat(this._clientId, "] auto dispatch stream remove ").concat(e3.uid)), this._handleRemoveStream({ uid: e3.uid, uint_id: e3._uintid }));
                }));
              }, 1e3);
            }
            r2();
          }), this._gateway.on(aS.REQUEST_NEW_GATEWAY_LIST, (e2, t2) => {
            if (!this._joinInfo)
              return t2(new SE(fE.UNEXPECTED_ERROR, "can not recover, no join info"));
            av(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || TE, this.store).then((t3) => {
              this._joinInfo && (this._joinInfo.apResponse = t3.gatewayInfo.res, this._joinInfo.gatewayAddrs = t3.gatewayInfo.gatewayAddrs, this._joinInfo.uni_lbs_ip = t3.gatewayInfo.uni_lbs_ip), e2(t3.gatewayInfo.gatewayAddrs.map((e3) => {
                if (this._joinInfo && this._joinInfo.proxyServer) {
                  const t4 = e3.address.split(":");
                  return "wss://".concat(this._joinInfo.proxyServer, "/ws/?h=").concat(t4[0], "&p=").concat(t4[1]);
                }
                return "wss://".concat(e3.address);
              }));
            }).catch(t2);
          }), this._gateway.on(aS.NETWORK_QUALITY, (e2) => {
            "normal" === this._networkQualitySensitivity && this.safeEmit(yf.NETWORK_QUALITY, e2);
          }), this._gateway.on(aS.STREAM_TYPE_CHANGE, (e2, t2) => {
            this.safeEmit(yf.STREAM_TYPE_CHANGED, e2, t2);
            Pg.reportApiInvoke(this._sessionId, { name: _f.STREAM_TYPE_CHANGE, options: [e2, t2], tag: Ef.TRACER }).onSuccess(JSON.stringify({ uid: e2, streamType: t2 }));
          }), this._gateway.on(aS.IS_P2P_DISCONNECTED, (e2) => {
            this._p2pChannel.isP2PDisconnected() ? e2(true) : this._p2pChannel.hasLocalMedia() || this._p2pChannel.hasRemoteMedia() ? e2(false) : e2(true);
          }), this._gateway.on(aS.NEED_RENEW_SESSION, () => {
            this._startSession();
          }), this._gateway.on(aS.REQUEST_P2P_CONNECTION_PARAMS, async (e2, t2, i2) => {
            try {
              t2(await this._p2pChannel.startP2PConnection(e2));
            } catch (e3) {
              i2(e3);
            }
          }), this._gateway.on(aS.JOIN_RESPONSE, (e2, t2) => {
            const { dtlsParameters: i2, iceParameters: n2, candidates: r2, rtpCapabilities: o2, setup: s2, cname: a2 } = GO(e2.ortc, t2);
            this._p2pChannel.connect(n2, i2, r2, o2, s2, a2);
          }), this._gateway.on(aS.REQUEST_DC_CONNECTION_PARAMS, (e2) => {
            e2(this._p2pChannel.getEstablishParams());
          }), this._gateway.on(aS.RESET_SIGNAL, (e2) => {
            this._p2pChannel.resetConnection(e2), this._handleGatewaySignalEvents();
          }), this._gateway.on(aS.DATACHANNEL_FAILBACK, () => {
            this._joinGateway();
          }), this._gateway.on(aS.DATACHANNEL_PRECONNECT, async (e2, t2, i2, n2) => {
            var r2, o2, s2, a2, c2, d2;
            await this._p2pChannel.startP2PConnection({ turnServer: null === (r2 = this._joinInfo) || void 0 === r2 ? void 0 : r2.turnServer }, true);
            const u2 = function(e3, t3) {
              let i3;
              return t3 && t3.ip && "number" == typeof t3.port ? (i3 = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t3.ip, port: t3.port.toString(), type: "host", extension: {} }], OE.debug("Using remote candidate from AP ".concat(t3.ip, ":").concat(t3.port)), t3.ip6 && (i3.push({ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t3.ip6, port: t3.port.toString(), type: "host", extension: {} }), OE.debug("Using IPV6 remote candidate from AP ".concat(t3.ip6, ":").concat(t3.port)))) : i3 = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: e3.ip, port: e3.port.toString(), type: "host", extension: {} }], i3;
            }(e2, t2);
            return this._p2pChannel.preConnect({ iceUfrag: "".concat(null === (o2 = this._joinInfo) || void 0 === o2 ? void 0 : o2.apResponse.cid, "_").concat(null === (s2 = this._joinInfo) || void 0 === s2 ? void 0 : s2.apResponse.cert), icePwd: "".concat(null === (a2 = this._joinInfo) || void 0 === a2 ? void 0 : a2.apResponse.cid, "_").concat(null === (c2 = this._joinInfo) || void 0 === c2 ? void 0 : c2.apResponse.cert) }, { fingerprints: [{ hashFunction: "sha-256", fingerprint: null !== (d2 = GE("FINGERPRINT")) && void 0 !== d2 ? d2 : e2.fingerprint }] }, u2, { send: { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, recv: { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] } }, "active", "o/i14u9pJrxRKAsu").then(i2).catch(n2);
          });
        }
        _handleGatewaySignalEvents() {
          this._gateway.signal.on(Df.ON_USER_ONLINE, this._handleUserOnline), this._gateway.signal.on(Df.ON_USER_OFFLINE, this._handleUserOffline), this._gateway.signal.on(Df.ON_ADD_AUDIO_STREAM, (e2) => this._handleAddAudioOrVideoStream("audio", e2.uid, e2.ssrcId, e2.cname, e2.uint_id, e2.ortc)), this._gateway.signal.on(Df.ON_ADD_VIDEO_STREAM, (e2) => this._handleAddAudioOrVideoStream("video", e2.uid, e2.ssrcId, e2.cname, e2.uint_id, e2.ortc, e2.rtxSsrcId)), this._gateway.signal.on(Df.ON_REMOVE_STREAM, this._handleRemoveStream), this._gateway.signal.on(Df.ON_P2P_LOST, this._handleP2PLost), this._gateway.signal.on(Df.MUTE_AUDIO, (e2) => this._handleMuteStream(e2.uid, "audio", true)), this._gateway.signal.on(Df.UNMUTE_AUDIO, (e2) => this._handleMuteStream(e2.uid, "audio", false)), this._gateway.signal.on(Df.MUTE_VIDEO, (e2) => this._handleMuteStream(e2.uid, "video", true)), this._gateway.signal.on(Df.UNMUTE_VIDEO, (e2) => this._handleMuteStream(e2.uid, "video", false)), this._gateway.signal.on(Df.RECEIVE_METADATA, (e2) => {
            const t2 = pC(e2.metadata);
            this.safeEmit(yf.RECEIVE_METADATA, e2.uid, t2);
          }), this._gateway.signal.on(Df.ON_DATA_STREAM, (e2) => {
            e2.seq && delete e2.seq, e2.payload = pC(e2.payload), this.safeEmit(yf.STREAM_MESSAGE, e2.uid, e2.payload), this.onStreamMessage && this.onStreamMessage(e2);
          }), this._gateway.signal.on(Df.ON_CRYPT_ERROR, () => {
            hC(() => {
              OE.warning("[".concat(this._clientId, "] on crypt error")), this.safeEmit(yf.CRYPT_ERROR);
            }, this._sessionId);
          }), this._gateway.signal.on(Df.ON_TOKEN_PRIVILEGE_WILL_EXPIRE, this._handleTokenWillExpire), this._gateway.signal.on(Df.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
            OE.warning("[".concat(this._clientId, "] received message onTokenPrivilegeDidExpire, please get new token and join again")), this._gateway.leave(true), this.safeEmit(yf.ON_TOKEN_PRIVILEGE_DID_EXPIRE), this._reset();
          }), this._gateway.signal.on(Df.ON_STREAM_FALLBACK_UPDATE, (e2) => {
            OE.debug("[".concat(this._clientId, "] stream fallback peerId: ").concat(e2.stream_id, ", attr: ").concat(e2.stream_type)), this.safeEmit(yf.STREAM_FALLBACK, e2.stream_id, 1 === e2.stream_type ? "fallback" : "recover");
          }), this._gateway.signal.on(Df.ON_PUBLISH_STREAM, (e2) => {
            this.uid === this._uid && (this._p2pChannel.reportPublishEvent(true, null, void 0, false, JSON.stringify({ proxy: e2.proxy })), OE.info("[".concat(this._clientId, "] on publish stream, ").concat(JSON.stringify(e2))));
          }), this._gateway.signal.on(Df.ENABLE_LOCAL_VIDEO, (e2) => {
            this._handleSetStreamLocalEnable("video", e2.uid, true);
          }), this._gateway.signal.on(Df.DISABLE_LOCAL_VIDEO, (e2) => {
            this._handleSetStreamLocalEnable("video", e2.uid, false);
          }), this._gateway.signal.on(Nf.REQUEST_TIMEOUT, (e2, t2) => {
            if (this._joinInfo)
              switch (e2) {
                case bf.PUBLISH: {
                  if (!t2)
                    return;
                  const e3 = (t2 = t2).ortc;
                  if (e3) {
                    var i2, n2, r2, o2;
                    const s2 = e3.some((e4) => {
                      let { stream_type: t3 } = e4;
                      return t3 === sS.Audio;
                    }), a2 = e3.some((e4) => {
                      let { stream_type: t3 } = e4;
                      return t3 !== sS.Audio;
                    }), c2 = e3.some((e4) => {
                      let { stream_type: t3 } = e4;
                      return t3 === sS.Screen || t3 === sS.ScreenLow;
                    });
                    "offer" === t2.state && Pg.publish(this._joinInfo.sid, { eventElapse: DI.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: false, ec: fE.TIMEOUT, audio: s2, video: a2, p2pid: t2.p2p_id, publishRequestid: this.store.pubId, screenshare: c2, audioName: s2 ? null === (i2 = e3.find((e4) => {
                      let { stream_type: t3 } = e4;
                      return t3 === sS.Audio;
                    })) || void 0 === i2 || null === (n2 = i2.ssrcs[0]) || void 0 === n2 ? void 0 : n2.ssrcId.toString() : void 0, videoName: a2 ? null === (r2 = e3.find((e4) => {
                      let { stream_type: t3 } = e4;
                      return t3 !== sS.Audio;
                    })) || void 0 === r2 || null === (o2 = r2.ssrcs[0]) || void 0 === o2 ? void 0 : o2.ssrcId.toString() : void 0 });
                  }
                  break;
                }
                case bf.SUBSCRIBE:
                  (t2 = t2) && Pg.subscribe(this._joinInfo.sid, { succ: false, ec: fE.TIMEOUT, audio: t2.stream_type === AS.AUDIO, video: t2.stream_type === AS.VIDEO, peerid: t2.stream_id, subscribeRequestid: t2.ssrcId, p2pid: this.store.p2pId, eventElapse: DI.measureFromSubscribeStart(this.store.clientId, t2.ssrcId) });
              }
          }), this._gateway.signal.on(Df.ON_P2P_OK, (e2) => {
            this.uid, this._uid;
          }), this._gateway.signal.on(Df.ON_PUBLISHED_USER_LIST, (e2) => {
            if (null == e2 || !e2.users)
              return;
            GE("BLOCK_LOCAL_CLIENT") && (e2.users = e2.users.filter((e3) => !ZE(e3.audio_ssrc, this.channelName)));
            const t2 = [], i2 = [];
            for (const n2 of e2.users) {
              let e3 = this._users.find((e4) => e4.uid === n2.stream_id);
              e3 ? e3._trust_in_room_ = true : (e3 = new yy(n2.stream_id, n2.stream_id), this._users.push(e3), 0 === this.getListeners(yf.PUBLISHED_USER_LIST).length && (OE.debug("[".concat(this._clientId, "] user online"), n2.stream_id), this.safeEmit(yf.USER_JOINED, e3)));
              const r2 = cS.Audio & n2.stream_type, o2 = (cS.Video | cS.LwoVideo) & n2.stream_type, s2 = r2 && e3.hasAudio, a2 = o2 && e3.hasVideo;
              o2 && (e3._trust_video_stream_added_state_ = true, e3._video_added_ = true, e3._videoSSRC = n2.video_ssrc, e3._rtxSsrcId = n2.video_rtx), r2 && (e3._trust_audio_stream_added_state_ = true, e3._audio_added_ = true, e3._audioSSRC = n2.audio_ssrc), r2 && !s2 && 0 === this.getListeners(yf.PUBLISHED_USER_LIST).length && (OE.info("[".concat(this._clientId, "] remote user ").concat(e3.uid, " published audio")), this.safeEmit(yf.USER_PUBLISHED, e3, "audio")), o2 && !a2 && 0 === this.getListeners(yf.PUBLISHED_USER_LIST).length && (OE.info("[".concat(this._clientId, "] remote user ").concat(e3.uid, " published video")), this.safeEmit(yf.USER_PUBLISHED, e3, "video")), (r2 && !s2 || o2 && !a2) && t2.push(e3), o2 && this._p2pChannel.hasPendingRemoteMedia(e3, "video") && i2.push({ user: e3, mediaType: "video" }), r2 && this._p2pChannel.hasPendingRemoteMedia(e3, "audio") && i2.push({ user: e3, mediaType: "audio" });
            }
            i2.length > 0 && (OE.debug("[".concat(this._clientId, "] RE massSubscribe after reconnect ").concat(i2.map((e3) => "user: ".concat(e3.user.uid, ", mediaType: ").concat(e3.mediaType)).join("; "), " ")), this.massSubscribe(i2).catch((e3) => {
              OE.error("[".concat(this._clientId, "] mass resubscribe error"), e3.toString());
            })), this.getListeners(yf.PUBLISHED_USER_LIST).length > 0 ? (OE.info("[".concat(this._clientId, "] client emit user-list event, users: ").concat(t2.map((e3) => e3.uid).join(", "))), this.safeEmit(yf.PUBLISHED_USER_LIST, t2)) : OE.info("[".concat(this._clientId, "] client not emit user-list event case there is no user-list listener, users: ").concat(t2.map((e3) => e3.uid).join(", ")));
          });
        }
        _handleP2PChannelEvents() {
          this._p2pChannel.on(DS.RequestMuteLocal, async (e2, t2, i2) => {
            if (this._joinInfo)
              try {
                await this._gateway.muteLocal(e2, this._joinInfo.stringUid || this._joinInfo.uid), t2();
              } catch (e3) {
                e3.code === fE.DISCONNECT_P2P ? t2() : i2(e3);
              }
            else
              t2();
          }), this._p2pChannel.on(DS.RequestUnmuteLocal, async (e2, t2, i2) => {
            if (this._joinInfo)
              try {
                await this._gateway.unmuteLocal(e2, this._joinInfo.stringUid || this._joinInfo.uid), t2();
              } catch (e3) {
                e3.code === fE.DISCONNECT_P2P ? t2() : i2(e3);
              }
            else
              t2();
          }), this._p2pChannel.on(DS.RequestRePublish, (e2, t2, i2) => {
            this.publish(e2, false).then(t2).catch(i2);
          }), this._p2pChannel.on(DS.RequestReSubscribe, async (e2, t2, i2) => {
            try {
              for (const { user: t3, kind: i3 } of e2)
                i3 === AS.VIDEO ? await this.subscribe(t3, "video") : await this.subscribe(t3, "audio");
              t2();
            } catch (e3) {
              i2(e3);
            }
          }), this._p2pChannel.on(DS.RequestUploadStats, (e2, t2) => {
            this._gateway.uploadStats(e2, t2);
          }), this._p2pChannel.on(DS.MediaReconnectStart, (e2) => {
            this.safeEmit(yf.MEDIA_RECONNECT_START, e2);
          }), this._p2pChannel.on(DS.MediaReconnectEnd, (e2) => {
            this.safeEmit(yf.MEDIA_RECONNECT_END, e2);
          }), this._p2pChannel.on(DS.NeedSignalRTT, (e2) => {
            e2(this._gateway.getSignalRTT());
          }), this._p2pChannel.on(DS.RequestRestartICE, async (e2) => {
            const t2 = await this._p2pChannel.restartICE(e2), i2 = await t2.next();
            if (i2.done)
              return;
            const n2 = i2.value;
            let r2;
            try {
              r2 = await this._gateway.restartICE({ iceParameters: n2 });
            } catch (e3) {
              return void t2.throw(e3);
            }
            const { iceParameters: o2 } = function(e3) {
              const t3 = e3.iceParameters;
              return { iceParameters: { iceUfrag: t3.iceUfrag, icePwd: t3.icePwd } };
            }(r2);
            await t2.next({ remoteIceParameters: o2 });
          }), this._p2pChannel.on(DS.RequestReconnect, async () => {
            this._gateway.reconnect();
          }), this._p2pChannel.on(DS.RequestReconnectPC, async () => {
            var e2;
            const { iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 } = await this._p2pChannel.startP2PConnection({ turnServer: null === (e2 = this._joinInfo) || void 0 === e2 ? void 0 : e2.turnServer }), { gatewayEstablishParams: r2, gatewayAddress: o2 } = await this._gateway.reconnectPC({ iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 }), { dtlsParameters: s2, iceParameters: a2, candidates: c2, rtpCapabilities: d2, setup: u2, cname: l2 } = GO(r2, o2);
            await this._p2pChannel.connect(a2, s2, c2, d2, u2, l2), await this._p2pChannel.republish(), await this._p2pChannel.reSubscribe();
          }), this._p2pChannel.on(DS.RequestUnpublishForReconnectPC, async (e2, t2, i2) => {
            this._joinInfo && void 0 !== this._uid ? (await this._gateway.unpublish(e2, this._uid), t2()) : i2();
          }), this._p2pChannel.on(DS.P2PLost, () => {
            this.safeEmit(yf.P2P_LOST, this.store.uid);
          }), this._p2pChannel.on(DS.UpdateVideoEncoder, (e2) => {
            e2._encoderConfig && this._gateway.setVideoProfile(e2._encoderConfig);
          }), this._p2pChannel.on(DS.ConnectionTypeChange, (e2) => {
            this.safeEmit(yf.IS_USING_CLOUD_PROXY, e2);
          }), this._p2pChannel.on(DS.RequestLowStreamParameter, (e2) => {
            e2(this._lowStreamParameter || { width: 160, height: 120, framerate: 15, bitrate: 50 });
          }), this._p2pChannel.on(DS.QueryClientConnectionState, (e2) => {
            e2(this.connectionState);
          });
        }
        getKeyMetrics() {
          return this.store.keyMetrics;
        }
        async enableContentInspect(e2) {
          if ("CONNECTED" !== this.connectionState || !this._joinInfo)
            throw new SE(fE.INVALID_OPERATION, "[".concat(this._clientId, "] Client did not join channel"));
          if (this._inspect)
            throw new SE(fE.INVALID_OPERATION, "[".concat(this._clientId, "] Inspect content service already in connecting/connected state"));
          if (!e2)
            throw new SE(fE.INVALID_PARAMS, "[".concat(this._clientId, "] inspectConfig is necessary"));
          if (!e2.inspectType || !Array.isArray(e2.inspectType))
            throw new SE(fE.INVALID_PARAMS, "[".concat(this._clientId, "] inspectConfig.inspectType is necessary and is an instance of Array."));
          {
            const t2 = [...new Set(e2.inspectType)];
            t2.forEach((e3) => {
              if (!["supervise", "moderation"].includes(e3))
                throw new SE(fE.INVALID_PARAMS, "[".concat(this._clientId, "] ").concat(e3, " is not a valid inspect type."));
            }), e2.inspectType = t2;
          }
          if (e2 && e2.extraInfo && e2.extraInfo.length > 1024)
            throw new SE(fE.INVALID_PARAMS, "[".concat(this._clientId, "] inspectConfig.extraInfo length cannot exceed 1024 bytes"));
          try {
            const t2 = new Ew(e2);
            this._inspect = t2, this.handleVideoInspectEvents(this._inspect), await t2.init({ appId: this._joinInfo.appId, areaCode: "", cname: this._joinInfo.cname, sid: this._joinInfo.sid, token: this._joinInfo.token, uid: this._joinInfo.uid, cid: this._joinInfo.cid, vid: this._joinInfo.vid ? Number(this._joinInfo.vid) : 0 }, TE);
          } catch (e3) {
            throw Array.isArray(e3) ? e3[0] : e3;
          }
        }
        async disableContentInspect() {
          if (!this._inspect)
            throw new SE(fE.INVALID_OPERATION, "[".concat(this._clientId, "] inspectVideoContent not started"));
          try {
            this._inspect.close(), this._inspect = void 0;
          } catch (e2) {
            throw Array.isArray(e2) ? e2[0] : e2;
          }
        }
        async setImageModeration(e2, t2) {
          if (Km(e2, "enabled"), e2) {
            if (!t2)
              throw new SE(fE.INVALID_PARAMS, "[".concat(this._clientId, "] config is necessary"));
            if (qm(t2.interval, "interval", 1e3, 1 / 0), "CONNECTED" !== this.connectionState || !this._joinInfo)
              throw new SE(fE.INVALID_OPERATION, "[".concat(this._clientId, '] can not enable image moderation, not joined"'));
            try {
              if (this._moderation)
                return void this._moderation.updateConfig(t2);
              const e3 = new Jw(t2);
              this._moderation = e3, this.handleImageModerationEvents(this._moderation), await e3.init({ appId: this._joinInfo.appId, areaCode: "", cname: this._joinInfo.cname, sid: this._joinInfo.sid, token: this._joinInfo.token, uid: this._joinInfo.uid, cid: this._joinInfo.cid, vid: this._joinInfo.vid ? Number(this._joinInfo.vid) : 0 }, TE);
            } catch (e3) {
              throw Array.isArray(e3) ? e3[0] : e3;
            }
          } else {
            if (!this._moderation)
              throw new SE(fE.INVALID_OPERATION, "[".concat(this._clientId, "] image moderation not started"));
            try {
              this._moderation.close(), this._moderation.removeAllListeners(), this._moderation = void 0;
            } catch (e3) {
              throw Array.isArray(e3) ? e3[0] : e3;
            }
          }
        }
        handleImageModerationEvents(e2) {
          e2.on(HS.CONNECTION_STATE_CHANGE, (t2, i2) => {
            switch (this.emit(yf.IMAGE_MODERATION_CONNECTION_STATE_CHANGE, t2, i2), t2) {
              case WS.CONNECTED:
                if ("CONNECTED" !== this.connectionState)
                  throw this.setImageModeration(false), new SE(fE.OPERATION_ABORTED, "Image moderation was cancelled because it left the channel");
                e2.inspectImage();
            }
          }), e2.on(HS.CLIENT_LOCAL_VIDEO_TRACK, (e3) => {
            e3(this.localTracks.filter((e4) => "video" === e4.trackMediaType)[0]);
          });
        }
        handleVideoInspectEvents(e2) {
          e2.on(VS.CONNECTION_STATE_CHANGE, (t2, i2) => {
            switch (this.emit(yf.CONTENT_INSPECT_CONNECTION_STATE_CHANGE, t2, i2), i2) {
              case US.CONNECTED:
                if ("CONNECTED" !== this.connectionState)
                  return void this.emit(yf.CONTENT_INSPECT_ERROR, new SE(fE.OPERATION_ABORTED, "Content inspect was cancelled because it left the channel"));
                e2.inspectImage();
            }
          }), e2.on(VS.INSPECT_RESULT, (e3, t2) => {
            var i2;
            if ((null == t2 ? void 0 : t2.code) === fE.INVALID_OPERATION && "DISCONNECTED" === this.connectionState)
              return OE.debug("Stop inspect content because that has left channel"), null == this || null === (i2 = this._inspect) || void 0 === i2 || i2.close(), void (this._inspect = void 0);
            this.emit(yf.CONTENT_INSPECT_RESULT, e3, t2);
          }), e2.on(VS.CLIENT_LOCAL_VIDEO_TRACK, (e3) => {
            e3(this.localTracks.filter((e4) => "video" === e4.trackMediaType)[0]);
          });
        }
        getJoinChannelServiceRecords() {
          return OE.debug("getJoinChannelServiceRecords"), this.store.joinChannelServiceRecords;
        }
        async setPublishAudioFilterEnabled(e2) {
          Km(e2, "enabled"), BE("ENABLE_PUBLISH_AUDIO_FILTER", e2), this._joinInfo && await this._gateway.setPublishAudioFilterEnabled(e2);
        }
        _handleResetAddStream(e2, t2) {
          switch (t2) {
            case "audio":
              e2._audio_added_ = false, e2._trust_audio_stream_added_state_ = true;
              break;
            case "video":
              e2._video_added_ = false, e2._trust_video_stream_added_state_ = true;
          }
        }
      }).prototype, "leave", [Xw], Object.getOwnPropertyDescriptor(kD.prototype, "leave"), kD.prototype), ag(kD.prototype, "publish", [zw], Object.getOwnPropertyDescriptor(kD.prototype, "publish"), kD.prototype), ag(kD.prototype, "unpublish", [Qw], Object.getOwnPropertyDescriptor(kD.prototype, "unpublish"), kD.prototype), ag(kD.prototype, "subscribe", [Zw], Object.getOwnPropertyDescriptor(kD.prototype, "subscribe"), kD.prototype), ag(kD.prototype, "massSubscribe", [$w], Object.getOwnPropertyDescriptor(kD.prototype, "massSubscribe"), kD.prototype), ag(kD.prototype, "unsubscribe", [eD], Object.getOwnPropertyDescriptor(kD.prototype, "unsubscribe"), kD.prototype), ag(kD.prototype, "massUnsubscribe", [tD], Object.getOwnPropertyDescriptor(kD.prototype, "massUnsubscribe"), kD.prototype), ag(kD.prototype, "setLowStreamParameter", [iD], Object.getOwnPropertyDescriptor(kD.prototype, "setLowStreamParameter"), kD.prototype), ag(kD.prototype, "enableDualStream", [nD], Object.getOwnPropertyDescriptor(kD.prototype, "enableDualStream"), kD.prototype), ag(kD.prototype, "disableDualStream", [rD], Object.getOwnPropertyDescriptor(kD.prototype, "disableDualStream"), kD.prototype), ag(kD.prototype, "setClientRole", [oD], Object.getOwnPropertyDescriptor(kD.prototype, "setClientRole"), kD.prototype), ag(kD.prototype, "setProxyServer", [sD], Object.getOwnPropertyDescriptor(kD.prototype, "setProxyServer"), kD.prototype), ag(kD.prototype, "setTurnServer", [aD], Object.getOwnPropertyDescriptor(kD.prototype, "setTurnServer"), kD.prototype), ag(kD.prototype, "setLicense", [cD], Object.getOwnPropertyDescriptor(kD.prototype, "setLicense"), kD.prototype), ag(kD.prototype, "startProxyServer", [dD], Object.getOwnPropertyDescriptor(kD.prototype, "startProxyServer"), kD.prototype), ag(kD.prototype, "stopProxyServer", [uD], Object.getOwnPropertyDescriptor(kD.prototype, "stopProxyServer"), kD.prototype), ag(kD.prototype, "setLocalAccessPointsV2", [lD], Object.getOwnPropertyDescriptor(kD.prototype, "setLocalAccessPointsV2"), kD.prototype), ag(kD.prototype, "setLocalAccessPoints", [hD], Object.getOwnPropertyDescriptor(kD.prototype, "setLocalAccessPoints"), kD.prototype), ag(kD.prototype, "setRemoteDefaultVideoStreamType", [pD], Object.getOwnPropertyDescriptor(kD.prototype, "setRemoteDefaultVideoStreamType"), kD.prototype), ag(kD.prototype, "setRemoteVideoStreamType", [_D], Object.getOwnPropertyDescriptor(kD.prototype, "setRemoteVideoStreamType"), kD.prototype), ag(kD.prototype, "setStreamFallbackOption", [ED], Object.getOwnPropertyDescriptor(kD.prototype, "setStreamFallbackOption"), kD.prototype), ag(kD.prototype, "setEncryptionConfig", [mD], Object.getOwnPropertyDescriptor(kD.prototype, "setEncryptionConfig"), kD.prototype), ag(kD.prototype, "renewToken", [fD], Object.getOwnPropertyDescriptor(kD.prototype, "renewToken"), kD.prototype), ag(kD.prototype, "enableAudioVolumeIndicator", [SD], Object.getOwnPropertyDescriptor(kD.prototype, "enableAudioVolumeIndicator"), kD.prototype), ag(kD.prototype, "startLiveStreaming", [TD], Object.getOwnPropertyDescriptor(kD.prototype, "startLiveStreaming"), kD.prototype), ag(kD.prototype, "setLiveTranscoding", [gD], Object.getOwnPropertyDescriptor(kD.prototype, "setLiveTranscoding"), kD.prototype), ag(kD.prototype, "stopLiveStreaming", [RD], Object.getOwnPropertyDescriptor(kD.prototype, "stopLiveStreaming"), kD.prototype), ag(kD.prototype, "addInjectStreamUrl", [ID], Object.getOwnPropertyDescriptor(kD.prototype, "addInjectStreamUrl"), kD.prototype), ag(kD.prototype, "removeInjectStreamUrl", [CD], Object.getOwnPropertyDescriptor(kD.prototype, "removeInjectStreamUrl"), kD.prototype), ag(kD.prototype, "startChannelMediaRelay", [vD], Object.getOwnPropertyDescriptor(kD.prototype, "startChannelMediaRelay"), kD.prototype), ag(kD.prototype, "updateChannelMediaRelay", [yD], Object.getOwnPropertyDescriptor(kD.prototype, "updateChannelMediaRelay"), kD.prototype), ag(kD.prototype, "stopChannelMediaRelay", [AD], Object.getOwnPropertyDescriptor(kD.prototype, "stopChannelMediaRelay"), kD.prototype), ag(kD.prototype, "sendCustomReportMessage", [OD], Object.getOwnPropertyDescriptor(kD.prototype, "sendCustomReportMessage"), kD.prototype), ag(kD.prototype, "pickSVCLayer", [ND], Object.getOwnPropertyDescriptor(kD.prototype, "pickSVCLayer"), kD.prototype), ag(kD.prototype, "enableContentInspect", [bD], Object.getOwnPropertyDescriptor(kD.prototype, "enableContentInspect"), kD.prototype), ag(kD.prototype, "disableContentInspect", [wD], Object.getOwnPropertyDescriptor(kD.prototype, "disableContentInspect"), kD.prototype), ag(kD.prototype, "setImageModeration", [DD], Object.getOwnPropertyDescriptor(kD.prototype, "setImageModeration"), kD.prototype), ag(kD.prototype, "getJoinChannelServiceRecords", [PD], Object.getOwnPropertyDescriptor(kD.prototype, "getJoinChannelServiceRecords"), kD.prototype), ag(kD.prototype, "setPublishAudioFilterEnabled", [LD], Object.getOwnPropertyDescriptor(kD.prototype, "setPublishAudioFilterEnabled"), kD.prototype), kD);
      class VD extends zg {
        set currentState(e2) {
          e2 !== this._currentState && (this._currentState = e2, this.safeEmit(Lf.AUDIO_SOURCE_STATE_CHANGE, this._currentState));
        }
        get currentState() {
          return this._currentState;
        }
        constructor(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          super(), _p(this, "audioBuffer", void 0), _p(this, "sourceNode", void 0), _p(this, "startPlayTime", 0), _p(this, "startPlayOffset", 0), _p(this, "pausePlayTime", 0), _p(this, "options", void 0), _p(this, "currentLoopCount", 0), _p(this, "currentPlaybackSpeed", 100), _p(this, "_currentState", "stopped"), this.audioBuffer = e2, this.options = t2, this.startPlayOffset = this.options.startPlayTime || 0;
        }
        createWebAudioDiagram() {
          return this.context.createGain();
        }
        get duration() {
          return this.audioBuffer.duration;
        }
        get playbackSpeed() {
          return this.currentPlaybackSpeed;
        }
        get currentTime() {
          return "stopped" === this.currentState ? 0 : "paused" === this.currentState ? this.pausePlayTime : ((this.context.currentTime - this.startPlayTime) * (this.playbackSpeed / 100) + this.startPlayOffset) % this.audioBuffer.duration;
        }
        updateOptions(e2) {
          "stopped" === this.currentState ? (this.options = e2, this.startPlayOffset = this.options.startPlayTime || 0) : OE.warning("can not set audio source options");
        }
        startProcessAudioBuffer() {
          this.sourceNode && this.stopProcessAudioBuffer(), this.sourceNode = this.createSourceNode(), this.startSourceNode(), this.currentState = "playing";
        }
        pauseProcessAudioBuffer() {
          this.sourceNode && "playing" === this.currentState && (this.pausePlayTime = this.currentTime, this.sourceNode.onended = null, this.sourceNode.stop(), this.sourceNode.buffer = null, this.sourceNode = this.createSourceNode(), this.currentState = "paused");
        }
        seekAudioBuffer(e2) {
          this.sourceNode && (this.sourceNode.onended = null, "playing" === this.currentState && this.sourceNode.stop(), this.sourceNode = this.createSourceNode(), "playing" === this.currentState ? (this.startPlayOffset = e2, this.startSourceNode()) : "paused" === this.currentState && (this.pausePlayTime = e2));
        }
        resumeProcessAudioBuffer() {
          "paused" === this.currentState && this.sourceNode && (this.startPlayOffset = this.pausePlayTime, this.pausePlayTime = 0, this.startSourceNode(), this.currentState = "playing");
        }
        stopProcessAudioBuffer() {
          if (this.sourceNode) {
            this.sourceNode.onended = null;
            try {
              this.sourceNode.stop();
            } catch (e2) {
            }
            this.reset();
          }
        }
        setAudioBufferPlaybackSpeed(e2) {
          this.sourceNode && ("playing" === this.currentState && (this.startPlayOffset = this.currentTime, this.startPlayTime = this.context.currentTime), this.sourceNode.playbackRate.value = e2 / 100), this.currentPlaybackSpeed = e2;
        }
        startSourceNode() {
          this.sourceNode && this.sourceNode.buffer && (this.sourceNode.start(0, this.startPlayOffset), this.startPlayTime = this.context.currentTime, this.sourceNode.onended = this.handleSourceNodeEnded.bind(this));
        }
        createSourceNode() {
          const e2 = this.context.createBufferSource();
          return e2.buffer = this.audioBuffer, e2.loop = !!this.options.loop, e2.connect(this.outputNode), e2.playbackRate.value = this.currentPlaybackSpeed / 100, e2;
        }
        handleSourceNodeEnded() {
          if (this.currentLoopCount += 1, this.options.cycle && this.options.cycle > this.currentLoopCount)
            return this.startPlayOffset = 0, this.sourceNode = void 0, void this.startProcessAudioBuffer();
          this.reset();
        }
        reset() {
          this.startPlayOffset = this.options.startPlayTime || 0, this.currentState = "stopped", this.sourceNode && (this.sourceNode.disconnect(), this.sourceNode = void 0), this.currentLoopCount = 0;
        }
      }
      const jD = /* @__PURE__ */ new Map();
      async function FD(e2, t2) {
        let i2 = null;
        if ("string" == typeof e2) {
          const t3 = jD.get(e2);
          if (t3)
            return OE.debug("use cached audio resource: ", e2), t3;
          try {
            i2 = (await RE(() => pE.get(e2, { responseType: "arraybuffer" }), void 0, void 0, { maxRetryCount: 3 })).data;
          } catch (e3) {
            throw new SE(fE.FETCH_AUDIO_FILE_FAILED, e3.toString());
          }
        } else {
          const t3 = new Sl((t4, i3) => {
            const n3 = new FileReader();
            n3.onload = (e3) => {
              e3.target ? t4(e3.target.result) : i3(new SE(fE.READ_LOCAL_AUDIO_FILE_ERROR));
            }, n3.onerror = () => {
              i3(new SE(fE.READ_LOCAL_AUDIO_FILE_ERROR));
            }, n3.readAsArrayBuffer(e2);
          });
          i2 = await t3;
        }
        const n2 = await function(e3) {
          const t3 = Hg();
          return new Sl((i3, n3) => {
            t3.decodeAudioData(e3, (e4) => {
              i3(e4);
            }, (e4) => {
              n3(new SE(fE.DECODE_AUDIO_FILE_FAILED, e4.toString()));
            });
          });
        }(i2);
        return "string" == typeof e2 && t2 && jD.set(e2, n2), n2;
      }
      function BD(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function GD(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? BD(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : BD(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      function WD(e2, t2, i2, n2) {
        i2.optimizationMode && (n2 && n2.width && n2.height ? (i2.encoderConfig = GD(GD({}, n2), {}, { bitrateMin: n2.bitrateMin, bitrateMax: n2.bitrateMax }), "motion" !== i2.optimizationMode && "detail" !== i2.optimizationMode || (t2.contentHint = i2.optimizationMode, t2.contentHint === i2.optimizationMode ? OE.debug("[".concat(e2, "] set content hint to"), i2.optimizationMode) : OE.debug("[".concat(e2, "] set content hint failed")))) : OE.warning("[".concat(e2, "] can not apply optimization mode bitrate config, no encoderConfig")));
      }
      const HD = xh().name;
      function KD(e2, t2, i2, n2) {
        let r2, o2 = 0, s2 = null;
        return new Sl((a2, c2) => {
          setTimeout(() => {
            r2 && (r2(), a2(o2));
          }, t2), r2 = Jg(() => {
            !function() {
              o2 > n2 && r2 && (r2(), a2(o2));
              const t3 = i2.getContext("2d");
              if (!t3) {
                const e3 = new SE(fE.UNEXPECTED_ERROR, "can not get canvas 2d context.");
                return OE.error(e3.toString()), void c2(e3);
              }
              t3.drawImage(e2, 0, 0, 160, 120);
              const d2 = t3.getImageData(0, 0, i2.width, i2.height), u2 = Math.floor(d2.data.length / 3);
              if (s2) {
                for (let e3 = 0; e3 < u2; e3 += 3)
                  if (d2.data[e3] !== s2[e3])
                    return o2 += 1, void (s2 = d2.data);
                s2 = d2.data;
              } else
                s2 = d2.data;
            }();
          }, 30);
        });
      }
      class YD {
        constructor(e2, t2) {
          _p(this, "id", 0), _p(this, "element", void 0), _p(this, "peerPair", void 0), _p(this, "context", void 0), _p(this, "audioPlayerElement", void 0), _p(this, "audioTrack", void 0), YD.count += 1, this.id = YD.count, this.element = e2, this.context = t2;
        }
        initPeers() {
          this.peerPair = [new RTCPeerConnection(), new RTCPeerConnection()], this.peerPair[1].ontrack = (e2) => {
            const t2 = document.createElement("audio");
            t2.srcObject = new MediaStream([e2.track]), t2.play(), this.audioPlayerElement = t2;
          };
        }
        async switchSdp() {
          if (!this.peerPair)
            return;
          const e2 = async (e3, t3) => {
            const i2 = "offer" === t3 ? await e3.createOffer() : await e3.createAnswer();
            return await e3.setLocalDescription(i2), "complete" === e3.iceGatheringState ? e3.localDescription : new Sl((t4) => {
              e3.onicegatheringstatechange = () => {
                "complete" === e3.iceGatheringState && t4(e3.localDescription);
              };
            });
          }, t2 = async (e3, t3) => await e3.setRemoteDescription(t3);
          try {
            const i2 = await e2(this.peerPair[0], "offer");
            await t2(this.peerPair[1], i2);
            const n2 = await e2(this.peerPair[1], "answer");
            await t2(this.peerPair[0], n2);
          } catch (e3) {
            throw new SE(fE.LOCAL_AEC_ERROR, e3.toString()).print();
          }
        }
        async getTracksFromMediaElement(e2) {
          if (this.audioTrack)
            return this.audioTrack;
          let t2;
          try {
            e2 instanceof HTMLVideoElement && (e2.captureStream ? e2.captureStream() : e2.mozCaptureStream()), t2 = this.context.createMediaStreamDestination();
            this.context.createMediaElementSource(e2).connect(t2);
          } catch (e3) {
            throw new SE(fE.LOCAL_AEC_ERROR, e3.toString()).print();
          }
          if (!t2) {
            throw new SE(fE.LOCAL_AEC_ERROR, "no dest node when local aec").print();
          }
          const i2 = t2.stream.getAudioTracks()[0];
          return this.audioTrack = i2, i2;
        }
        getElement() {
          return this.element;
        }
        async startEchoCancellation() {
          this.context.resume(), this.peerPair && this.close(), this.initPeers();
          const e2 = this.element, t2 = await this.getTracksFromMediaElement(e2);
          this.peerPair && this.peerPair[0].addTrack(t2), await this.switchSdp();
        }
        close() {
          OE.debug("close echo cancellation unit, id is", this.id), this.audioPlayerElement && this.audioPlayerElement.pause(), this.peerPair && this.peerPair.forEach((e2) => {
            e2.close();
          }), this.peerPair = void 0, this.audioPlayerElement = void 0;
        }
      }
      var qD, JD;
      _p(YD, "count", 0);
      const XD = window.AudioContext || window.webkitAudioContext;
      const zD = new (qD = Dg({ report: Pg }), ag((JD = class {
        constructor() {
          _p(this, "units", []), _p(this, "context", void 0);
        }
        processExternalMediaAEC(e2) {
          if (!this._doesEnvironmentNeedAEC())
            return OE.debug("the system does not need to process local aec"), -1;
          this.context || (this.context = new XD());
          let t2 = this.units.find((t3) => t3 && t3.getElement() === e2);
          return t2 || (t2 = new YD(e2, this.context), this.units.push(t2)), t2.startEchoCancellation(), OE.debug("start processing local audio echo cancellation, id is", t2.id), t2.id;
        }
        _doesEnvironmentNeedAEC() {
          return xh().name !== wh.SAFARI;
        }
      }).prototype, "processExternalMediaAEC", [qD], Object.getOwnPropertyDescriptor(JD.prototype, "processExternalMediaAEC"), JD.prototype), JD)();
      function QD(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function ZD(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? QD(Object(i2), true).forEach(function(t3) {
            _p(e2, t3, i2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : QD(Object(i2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          });
        }
        return e2;
      }
      const $D = window || document;
      function eP(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        if (!$D)
          return;
        const i2 = tP._cspEventHandlerPointer;
        if (i2 && t2)
          return void console.error(i2, t2);
        const n2 = (e3) => {
          if (!(e3 && e3.blockedURI && (tP.onSecurityPolicyViolation || tP.getListeners(BS.SECURITY_POLICY_VIOLATION).length > 0)))
            return;
          const t3 = e3.blockedURI;
          GE("CSP_DETECTED_HOSTNAME_LIST").some((e4) => t3.includes(e4)) && (tP.onSecurityPolicyViolation && "function" == typeof tP.onSecurityPolicyViolation && tP.onSecurityPolicyViolation(e3), tP.getListeners(BS.SECURITY_POLICY_VIOLATION).length > 0 && tP.safeEmit(BS.SECURITY_POLICY_VIOLATION, e3));
        };
        i2 && $D.removeEventListener("securitypolicyviolation", i2), (t2 || e2 && "function" == typeof e2 || tP.getListeners(BS.SECURITY_POLICY_VIOLATION).length > 0) && $D.addEventListener("securitypolicyviolation", n2), tP._cspEventHandlerPointer = n2;
      }
      BE("PROCESS_ID", "process-".concat(ZI(8, ""), "-").concat(ZI(4, ""), "-").concat(ZI(4, ""), "-").concat(ZI(4, ""), "-").concat(ZI(12, ""))), function() {
        const e2 = xh();
        qS.getDisplayMedia = function(e3) {
          if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia)
            return true;
          return false;
        }(), qS.getStreamFromExtension = e2.name === wh.CHROME && Number(e2.version) > 34, qS.supportUnifiedPlan = function() {
          if (!window.RTCRtpTransceiver)
            return false;
          if (!("currentDirection" in RTCRtpTransceiver.prototype))
            return false;
          const e3 = new RTCPeerConnection();
          let t2 = false;
          try {
            e3.addTransceiver("audio"), t2 = true;
          } catch (e4) {
          }
          return e3.close(), t2;
        }(), qS.supportMinBitrate = e2.name === wh.CHROME || e2.name === wh.EDGE, qS.supportSetRtpSenderParameters = function() {
          const e3 = xh();
          if (!window.RTCRtpSender || !window.RTCRtpSender.prototype.setParameters || !window.RTCRtpSender.prototype.getParameters)
            return false;
          return !!rp() || (!(!Hh() && !Fh()) || e3.name === wh.FIREFOX && Number(e3.version) >= 64);
        }(), e2.name === wh.SAFARI && (Number(e2.version) >= 14 ? qS.supportDualStream = true : qS.supportDualStream = false), qS.webAudioMediaStreamDest = function() {
          const e3 = xh();
          if (e3.name === wh.SAFARI && Number(e3.version) < 12)
            return false;
          return true;
        }(), qS.supportReplaceTrack = function() {
          if (!window.RTCRtpSender)
            return false;
          if ("function" == typeof RTCRtpSender.prototype.replaceTrack)
            return true;
          return false;
        }(), qS.supportWebGL = "undefined" != typeof WebGLRenderingContext, qS.supportRequestFrame = !!window.CanvasCaptureMediaStreamTrack, rp() || (qS.webAudioWithAEC = true), qS.supportShareAudio = function() {
          const e3 = xh();
          if ((e3.os === bh.WIN_10 || e3.os === bh.WIN_81 || e3.os === bh.WIN_7 || e3.os === bh.LINUX || e3.os === bh.MAC_OS) && e3.name === wh.CHROME && Number(e3.version) >= 74)
            return true;
          return false;
        }(), qS.supportDualStreamEncoding = function() {
          const e3 = xh();
          if (GE("DISABLE_WEBAUDIO"))
            return true;
          return "Safari" === e3.name && Number(e3.version) >= 14 || !!("Chrome" === e3.name && /Windows/i.test(e3.os || "") && Number(e3.version) >= 100 && GE("CHROME_DUAL_STREAM_USE_ENCODING"));
        }(), qS.supportDataChannel = function() {
          if (qh(76) || function(e3) {
            const t2 = xh();
            return !(t2.name !== wh.FIREFOX || !t2.osVersion) && Number(t2.version) >= e3;
          }(68) || function(e3) {
            const t2 = xh();
            return !(t2.name !== wh.SAFARI || !t2.osVersion) && Number(t2.version) >= e3;
          }(14))
            return true;
          return false;
        }(), qS.supportPCSetConfiguration = function() {
          const e3 = window.RTCPeerConnection;
          return !Kh() && !!e3 && e3.prototype.setConfiguration instanceof Function;
        }(), qS.supportWebRTCEncodedTransform = function() {
          const e3 = xh();
          return "Chrome" === e3.name && Number(e3.version) >= 86;
        }(), OE.info("browser compatibility", JSON.stringify(qS), JSON.stringify(e2));
      }(), function() {
        let e2;
        try {
          e2 = window.localStorage.getItem("websdk_ng_global_parameter");
        } catch (e3) {
          return void OE.error("Error loading sdk config", e3.message);
        }
        if (e2)
          try {
            const t2 = JSON.parse(window.atob(e2)), i2 = Date.now();
            OE.debug("Loading global parameters from cache", t2), Object.keys(t2).forEach((e3) => {
              if (Object.prototype.hasOwnProperty.call(WE, e3)) {
                const { value: n2, expires: r2 } = t2[e3];
                if (r2 && r2 <= i2)
                  return;
                HE[e3] = n2, WE[e3] = n2;
              }
            });
          } catch (t2) {
            OE.error("Error loading mutableParamsCache: ".concat(e2), t2.message);
          }
      }(), Array.isArray(HE.AREAS) && HE.AREAS.length > 0 && qC(HE.AREAS, true);
      const tP = function(e2) {
        const t2 = new EE(), i2 = e2, n2 = { getListeners: t2.getListeners.bind(t2), on: (e3, i3) => (function(e4, t3) {
          e4 === BS.SECURITY_POLICY_VIOLATION && eP(t3, true);
        }(e3, i3), t2.on.bind(t2)(e3, i3)), addListener: t2.addListener.bind(t2), once: t2.once.bind(t2), off: t2.off.bind(t2), removeAllListeners: t2.removeAllListeners.bind(t2), emit: t2.emit.bind(t2), safeEmit: t2.safeEmit.bind(t2) };
        return ZD(ZD({}, i2), n2);
      }({ __CLIENT_LIST__: zE, __TRACK_LIST__: QE, VERSION: bE, BUILD: NE, setParameter: (e2, t2, i2) => {
        OE.debug("setParameter key:".concat(e2, ", value:").concat(JSON.stringify(t2))), BE(e2, t2, i2);
      }, getParameter: GE, getSupportedCodec: async function() {
        let e2 = { audio: [], video: [] };
        try {
          let t2 = new RTCPeerConnection();
          t2.addTransceiver("video", { direction: "recvonly" }), t2.addTransceiver("audio", { direction: "recvonly" });
          const i2 = (await t2.createOffer()).sdp;
          if (!i2)
            return e2;
          t2.close(), t2 = null, e2 = function(e3) {
            const t3 = { video: [], audio: [] };
            return e3.match(/ VP8/i) && t3.video.push("VP8"), e3.match(/ VP9/i) && t3.video.push("VP9"), e3.match(/ AV1/i) && t3.video.push("AV1"), e3.match(/ H264/i) && t3.video.push("H264"), e3.match(/ H265/i) && t3.video.push("H265"), e3.match(/ opus/i) && t3.audio.push("OPUS"), e3.match(/ PCMU/i) && t3.audio.push("PCMU"), e3.match(/ PCMA/i) && t3.audio.push("PCMA"), e3.match(/ G722/i) && t3.audio.push("G722"), t3;
          }(i2);
        } catch (e3) {
          throw new SE(fE.CREATE_OFFER_FAILED, e3.toString && e3.toString()).print();
        }
        return e2;
      }, checkSystemRequirements: function() {
        const e2 = Pg.reportApiInvoke(null, { name: _f.CHECK_SYSTEM_REQUIREMENTS, options: [], tag: Ef.TRACER });
        let t2 = false;
        try {
          const e3 = window.RTCPeerConnection, i3 = navigator.mediaDevices && navigator.mediaDevices.getUserMedia, n3 = window.WebSocket;
          t2 = !!(e3 && i3 && n3);
        } catch (e3) {
          return OE.error("check system requirement failed: ", e3), false;
        }
        let i2 = false;
        const n2 = xh();
        n2.name === wh.CHROME && Number(n2.version) >= 58 && (!Gh() || Bh()) && (i2 = true), n2.name === wh.FIREFOX && Number(n2.version) >= 56 && (i2 = true), n2.name === wh.OPERA && Number(n2.version) >= 45 && (i2 = true), n2.name === wh.SAFARI && Number(n2.version) >= 11 && (i2 = true), (ip() || xh().name === wh.QQ) && (i2 = true), OE.debug("checkSystemRequirements, api:", t2, "browser", i2);
        const r2 = t2 && i2;
        return e2.onSuccess(r2), r2;
      }, getDevices: function(e2) {
        return lR.enumerateDevices(true, true, e2);
      }, getMicrophones: function(e2) {
        return lR.getRecordingDevices(e2);
      }, getCameras: function(e2) {
        return lR.getCamerasDevices(e2);
      }, getElectronScreenSources: eR, getPlaybackDevices: function(e2) {
        return lR.getSpeakers(e2);
      }, createClient: function() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { codec: "vp8", audioCodec: "opus", mode: "rtc" };
        const t2 = Pg.reportApiInvoke(null, { name: _f.CREATE_CLIENT, options: [e2], tag: Ef.TRACER });
        try {
          Mf(e2);
        } catch (e3) {
          throw t2.onError(e3), e3;
        }
        return void 0 === e2.audioCodec && (e2.audioCodec = "opus"), t2.onSuccess(), new xD(UD(UD({ forceWaitGatewayResponse: true }, e2), {}, { role: "rtc" === e2.mode ? "host" : e2.role || "audience" }));
      }, createCameraVideoTrack: async function() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        const t2 = Pg.reportApiInvoke(null, { tag: Ef.TRACER, name: _f.CREATE_CAM_VIDEO_TRACK, options: [GD({}, e2)] }), i2 = Mv(e2), n2 = ZI(8, "track-cam-");
        let r2 = null;
        OE.info("start create camera video track with config", JSON.stringify(e2), "trackId", n2);
        try {
          r2 = (await aR({ video: i2 }, n2)).getVideoTracks()[0] || null;
        } catch (e3) {
          throw t2.onError(e3), e3;
        }
        if (!r2) {
          const e3 = new SE(fE.UNEXPECTED_ERROR, "can not find track in media stream");
          return t2.onError(e3), e3.throw();
        }
        e2.optimizationMode && WD(n2, r2, e2, UE(e2.encoderConfig));
        const o2 = new vy(r2, e2, i2, e2.scalabiltyMode ? VE(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, n2);
        return t2.onSuccess(o2.getTrackId()), OE.info("create camera video success, trackId:", n2), o2;
      }, createCustomVideoTrack: function(e2) {
        const t2 = Pg.reportApiInvoke(null, { tag: Ef.TRACER, name: _f.CREATE_CUSTOM_VIDEO_TRACK, options: [e2] }), i2 = new Cy(e2.mediaStreamTrack, { width: e2.width, height: e2.height, frameRate: e2.frameRate, bitrateMax: e2.bitrateMax, bitrateMin: e2.bitrateMin }, e2.scalabiltyMode ? VE(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, ZI(8, "track-cus-"), [lS.CUSTOM_TRACK]);
        return t2.onSuccess(i2.getTrackId()), OE.info("create custom video track success with config", e2, "trackId", i2.getTrackId()), i2;
      }, createScreenVideoTrack: async function() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "disable";
        const i2 = Pg.reportApiInvoke(null, { tag: Ef.TRACER, name: _f.CREATE_SCREEN_VIDEO_TRACK, options: [GD({}, e2), t2] });
        e2.encoderConfig ? "string" == typeof e2.encoderConfig || e2.encoderConfig.width && e2.encoderConfig.height || (e2.encoderConfig.width = { max: 1920 }, e2.encoderConfig.height = { max: 1080 }) : e2.encoderConfig = "1080p_2";
        const n2 = Uv(e2), r2 = ZI(8, "track-scr-v-");
        let o2 = null, s2 = null;
        const a2 = JS();
        if (!a2.supportShareAudio && "enable" === t2) {
          const e3 = new SE(fE.NOT_SUPPORTED, "your browser or platform is not support share-screen with audio");
          return i2.onError(e3), e3.throw();
        }
        OE.info("start create screen video track with config", e2, "withAudio", t2, "trackId", r2);
        try {
          const e3 = await aR({ screen: n2, screenAudio: "auto" === t2 ? a2.supportShareAudio : "enable" === t2 }, r2);
          o2 = e3.getVideoTracks()[0] || null, s2 = e3.getAudioTracks()[0] || null;
        } catch (e3) {
          throw i2.onError(e3), e3;
        }
        if (!o2) {
          const e3 = new SE(fE.UNEXPECTED_ERROR, "can not find track in media stream");
          return i2.onError(e3), e3.throw();
        }
        if (!s2 && "enable" === t2) {
          o2 && o2.stop();
          const e3 = new SE(fE.SHARE_AUDIO_NOT_ALLOWED);
          return i2.onError(e3), e3.throw();
        }
        e2.optimizationMode || (e2.optimizationMode = "detail"), e2.optimizationMode && (WD(r2, o2, e2, e2.encoderConfig && xE(e2.encoderConfig)), e2.encoderConfig && "string" != typeof e2.encoderConfig && (e2.encoderConfig.bitrateMin = e2.encoderConfig.bitrateMax));
        const c2 = new Cy(o2, e2.encoderConfig ? xE(e2.encoderConfig) : {}, e2.scalabiltyMode ? VE(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, r2, [lS.SCREEN_TRACK]);
        if (!s2)
          return i2.onSuccess(c2.getTrackId()), OE.info("create screen video track success", "video:", c2.getTrackId()), c2;
        const d2 = new yI(s2, void 0, ZI(8, "track-scr-a-"), false, true);
        return i2.onSuccess([c2.getTrackId(), d2.getTrackId()]), OE.info("create screen video track success", "video:", c2.getTrackId(), "audio:", d2.getTrackId()), [c2, d2];
      }, createMicrophoneAndCameraTracks: async function() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const i2 = Pg.reportApiInvoke(null, { tag: Ef.TRACER, name: _f.CREATE_MIC_AND_CAM_TRACKS, options: [e2, t2] }), n2 = Mv(t2), r2 = xv(e2), o2 = ZI(8, "track-mic-"), s2 = ZI(8, "track-cam-");
        let a2 = null, c2 = null;
        OE.info("start create camera video track(".concat(s2, ") and microphone audio track(").concat(o2, ") with config, audio: ").concat(JSON.stringify(e2), ", video: ").concat(JSON.stringify(t2)));
        try {
          const e3 = await aR({ audio: r2, video: n2 }, "".concat(o2, "-").concat(s2));
          a2 = e3.getAudioTracks()[0], c2 = e3.getVideoTracks()[0];
        } catch (e3) {
          throw i2.onError(e3), e3;
        }
        if (!a2 || !c2) {
          const e3 = new SE(fE.UNEXPECTED_ERROR, "can not find tracks in media stream");
          return i2.onError(e3), e3.throw();
        }
        t2.optimizationMode && WD(s2, c2, t2, UE(t2.encoderConfig));
        const d2 = new AI(a2, e2, r2, o2), u2 = new vy(c2, t2, n2, t2.scalabiltyMode ? VE(t2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, t2.optimizationMode, s2);
        return i2.onSuccess([d2.getTrackId(), u2.getTrackId()]), OE.info("create camera video track(".concat(s2, ") and microphone audio track(").concat(o2, ") success")), [d2, u2];
      }, createMicrophoneAudioTrack: async function() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        const t2 = Pg.reportApiInvoke(null, { tag: Ef.TRACER, name: _f.CREATE_MIC_AUDIO_TRACK, options: [e2] }), i2 = xv(e2), n2 = ZI(8, "track-mic-");
        let r2 = null;
        OE.info("start create microphone audio track with config", JSON.stringify(e2), "trackId", n2);
        try {
          r2 = (await aR({ audio: i2 }, n2)).getAudioTracks()[0] || null;
        } catch (e3) {
          throw t2.onError(e3), e3;
        }
        if (!r2) {
          const e3 = new SE(fE.UNEXPECTED_ERROR, "can not find track in media stream");
          return t2.onError(e3), e3.throw();
        }
        const o2 = new AI(r2, e2, i2, n2);
        return t2.onSuccess(o2.getTrackId()), OE.info("create microphone audio track success, trackId:", n2), o2;
      }, createCustomAudioTrack: function(e2) {
        const t2 = Pg.reportApiInvoke(null, { tag: Ef.TRACER, name: _f.CREATE_CUSTOM_AUDIO_TRACK, options: [e2] }), i2 = new yI(e2.mediaStreamTrack, e2.encoderConfig ? FE(e2.encoderConfig) : {}, ZI(8, "track-cus-"), false, true);
        return OE.info("create custom audio track success with config", e2, "trackId", i2.getTrackId()), t2.onSuccess(i2.getTrackId()), i2;
      }, createBufferSourceAudioTrack: async function(e2) {
        const t2 = Pg.reportApiInvoke(null, { tag: Ef.TRACER, name: _f.CREATE_BUFFER_AUDIO_TRACK, options: [e2] });
        if (GE("DISABLE_WEBAUDIO"))
          throw new SE(fE.NOT_SUPPORTED, "can not create BufferSourceAudioTrack when WebAudio disabled");
        const i2 = ZI(8, "track-buf-");
        OE.info("start create buffer source audio track with config", JSON.stringify(e2), "trackId", i2);
        const n2 = e2.source;
        if (!(e2.source instanceof AudioBuffer))
          try {
            e2.source = await FD(e2.source, e2.cacheOnlineFile);
          } catch (e3) {
            return t2.onError(e3), e3.throw();
          }
        const r2 = new VD(e2.source), o2 = new OI(n2, r2, e2.encoderConfig ? FE(e2.encoderConfig) : {}, i2);
        return OE.info("create buffer source audio track success, trackId:", i2), t2.onSuccess(o2.getTrackId()), o2;
      }, setAppType: function(e2) {
        if (OE.debug("setAppType: ".concat(e2)), !(Number.isInteger(e2) && e2 >= 0))
          throw OE.debug("Invalid appType"), new SE(fE.INVALID_PARAMS, "invalid app type", e2);
        BE("APP_TYPE", Math.floor(e2));
      }, setLogLevel: function(e2) {
        OE.setLogLevel(e2);
      }, enableLogUpload: function() {
        GE("USE_NEW_LOG") ? BE("UPLOAD_LOG", true) : OE.enableLogUpload();
      }, disableLogUpload: function() {
        GE("USE_NEW_LOG") ? BE("UPLOAD_LOG", false) : OE.disableLogUpload();
      }, createChannelMediaRelayConfiguration: function() {
        return new vv();
      }, checkAudioTrackIsActive: async function(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
        const i2 = Pg.reportApiInvoke(null, { tag: Ef.TRACER, name: _f.CHECK_AUDIO_TRACK_IS_ACTIVE, options: [t2] });
        if (!(e2 instanceof yI || e2 instanceof nb)) {
          const e3 = new SE(fE.INVALID_TRACK, "the parameter is not a audio track");
          return i2.onError(e3), e3.throw();
        }
        t2 && t2 < 1e3 && (t2 = 1e3);
        const n2 = e2 instanceof yI ? e2.getTrackLabel() : "remote_track", r2 = e2.getVolumeLevel();
        let o2 = r2, s2 = r2;
        const a2 = Date.now();
        return new Sl((r3) => {
          const c2 = setInterval(() => {
            const d2 = e2.getVolumeLevel();
            o2 = d2 > o2 ? d2 : o2, s2 = d2 < s2 ? d2 : s2;
            const u2 = o2 - s2 > 1e-4, l2 = Date.now() - a2;
            if (u2 || l2 > t2) {
              clearInterval(c2);
              const t3 = u2, s3 = { duration: l2, deviceLabel: n2, maxVolumeLevel: o2, result: t3 };
              OE.info("[track-".concat(e2.getTrackId(), "] check audio track active completed. ").concat(JSON.stringify(s3))), i2.onSuccess(s3), r3(t3);
            }
          }, 200);
        });
      }, checkVideoTrackIsActive: async function(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
        const i2 = Pg.reportApiInvoke(null, { tag: Ef.TRACER, name: _f.CHECK_VIDEO_TRACK_IS_ACTIVE, options: [t2] });
        if (!(e2 instanceof Cy || e2 instanceof ib)) {
          const e3 = new SE(fE.INVALID_TRACK, "the parameter is not a video track");
          return i2.onError(e3), e3.throw();
        }
        const n2 = 4;
        t2 && t2 < 1e3 && (t2 = 1e3);
        const r2 = e2 instanceof Cy ? e2.getTrackLabel() : "remote_track", o2 = e2.getMediaStreamTrack(true), s2 = document.createElement("video");
        s2.style.width = "1px", s2.style.height = "1px", s2.setAttribute("muted", ""), s2.muted = true, s2.setAttribute("playsinline", ""), s2.controls = false, (Hh() || Fh()) && (s2.style.opacity = "0.01", s2.style.position = "fixed", s2.style.left = "0", s2.style.top = "0", document.body.appendChild(s2)), s2.srcObject = new MediaStream([o2]), s2.play();
        const a2 = document.createElement("canvas");
        a2.width = 160, a2.height = 120;
        let c2 = 0, d2 = 0;
        try {
          const e3 = Date.now();
          c2 = await KD(s2, t2, a2, n2), d2 = Date.now() - e3;
        } catch (e3) {
          throw i2.onError(e3), e3;
        }
        HD === wh.SAFARI && (s2.pause(), s2.remove()), s2.srcObject = null;
        const u2 = c2 > n2, l2 = { duration: d2, changedPicNum: c2, deviceLabel: r2, result: u2 };
        return OE.info("[track-".concat(e2.getTrackId(), "] check video track active completed. ").concat(JSON.stringify(l2))), i2.onSuccess(l2), u2;
      }, setArea: qC, audioElementPlayCenter: pR, processExternalMediaAEC: function(e2) {
        zD.processExternalMediaAEC(e2);
      }, registerExtensions: function(e2) {
        e2.forEach((e3) => {
          const t2 = e3;
          t2.__registered__ = true, t2.logger.hookLog = OE.extLog, t2.reporter.hookApiInvoke = Pg.extApiInvoke, t2.parameters && Object.keys(t2.parameters).forEach((e4) => {
            t2.parameters[e4] = GE(e4);
          });
        });
      }, ChannelMediaRelayError: oS, ChannelMediaRelayEvent: nS, ChannelMediaRelayState: rS, RemoteStreamFallbackType: _S, RemoteStreamType: pS, ConnectionDisconnectedReason: vf, AudienceLatencyLevelType: Cf, AREAS: SS });
      return Object.defineProperties(tP, { onAudioAutoplayFailed: { get: () => vg.onAudioAutoplayFailed, set: (e2) => {
        vg.onAudioAutoplayFailed = e2;
      } }, onAutoplayFailed: { get: () => vg.onAutoplayFailed, set: (e2) => {
        vg.onAutoplayFailed = e2;
      } }, _onSecurityPolicyViolation: { value: void 0, writable: true }, _cspEventHandlerPointer: { value: void 0, writable: true }, onSecurityPolicyViolation: { get: () => tP._onSecurityPolicyViolation, set(e2) {
        tP._onSecurityPolicyViolation = e2, eP(e2);
      } } }), lR.on(ff.CAMERA_DEVICE_CHANGED, (e2) => {
        OE.info("camera device changed", JSON.stringify(e2)), tP.onCameraChanged && tP.onCameraChanged(e2), tP.safeEmit(BS.CAMERA_CHANGED, e2);
      }), lR.on(ff.RECORDING_DEVICE_CHANGED, (e2) => {
        OE.info("microphone device changed", JSON.stringify(e2)), tP.onMicrophoneChanged && tP.onMicrophoneChanged(e2), tP.safeEmit(BS.MICROPHONE_CHANGED, e2);
      }), lR.on(ff.PLAYOUT_DEVICE_CHANGED, (e2) => {
        OE.debug("playout device changed", JSON.stringify(e2)), tP.onPlaybackDeviceChanged && tP.onPlaybackDeviceChanged(e2), tP.safeEmit(BS.PLAYBACK_DEVICE_CHANGED, e2);
      }), pR.onAutoplayFailed = () => {
        OE.info("detect audio element autoplay failed"), vg.onAudioAutoplayFailed && vg.onAudioAutoplayFailed();
      }, Gg.on("autoplay-failed", () => {
        OE.info("detect webaudio autoplay failed"), vg.onAudioAutoplayFailed && vg.onAudioAutoplayFailed(), tP.safeEmit(BS.AUTOPLAY_FAILED);
      }), window && (window.__ARTC__ = tP), tP;
    });
  }
});
export default require_AgoraRTC_N_production();
/*! formdata-polyfill. MIT License. Jimmy W?rting <https://jimmy.warting.se/opensource> */
//# sourceMappingURL=agora-rtc-sdk-ng.js.map
